package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/open-policy-agent/opa/v1/ast"
	"github.com/open-policy-agent/opa/v1/loader"
)

// getSupportedLanguages returns all supported language codes
func getSupportedLanguages() []string {
	return []string{"en", "zh", "es", "fr", "de", "ja", "pt"}
}

// docTemplates contains template strings for each language
type docTemplates struct {
	Severity           string
	Description        string
	ReasonForViolation string
	Recommendation     string
	ResourceTypes      string
	ResourceTypesDesc  string
	AutoGenerated      string
	// For packs
	IncludedRules     string
	IncludedRulesDesc string
	// For index pages
	Rules           string
	TotalRules      string
	RulesBySeverity string
	SeverityHigh    string
	SeverityMedium  string
	SeverityLow     string
	RuleID          string
	Name            string
	DescriptionCol  string
	Packs           string
	TotalPacks      string
	AvailablePacks  string
	PackID          string
	RulesCount      string
}

var docTemplatesMap = map[string]docTemplates{
	"en": {
		Severity:           "Severity",
		Description:        "Description",
		ReasonForViolation: "Reason for Violation",
		Recommendation:     "Recommendation",
		ResourceTypes:      "Resource Types",
		ResourceTypesDesc:  "This rule applies to the following resource types:",
		AutoGenerated:      "",
		IncludedRules:      "Included Rules",
		IncludedRulesDesc:  "This compliance pack includes the following rules:",
		Rules:              "Rules",
		TotalRules:         "Total rules:",
		RulesBySeverity:    "Rules by Severity",
		SeverityHigh:       "High",
		SeverityMedium:     "Medium",
		SeverityLow:        "Low",
		RuleID:             "Rule ID",
		Name:               "Name",
		DescriptionCol:     "Description",
		Packs:              "Packs",
		TotalPacks:         "Total packs:",
		AvailablePacks:     "Available Packs",
		PackID:             "Pack ID",
		RulesCount:         "Rules",
	},
	"zh": {
		Severity:           "严重程度",
		Description:        "描述",
		ReasonForViolation: "违规原因",
		Recommendation:     "建议",
		ResourceTypes:      "资源类型",
		ResourceTypesDesc:  "此规则适用于以下资源类型：",
		AutoGenerated:      "_此文档由策略元数据自动生成。_",
		IncludedRules:      "包含的规则",
		IncludedRulesDesc:  "此合规包包含以下规则：",
		Rules:              "规则",
		TotalRules:         "规则总数：",
		RulesBySeverity:    "按严重程度分类",
		SeverityHigh:       "高",
		SeverityMedium:     "中",
		SeverityLow:        "低",
		RuleID:             "规则 ID",
		Name:               "名称",
		DescriptionCol:     "描述",
		Packs:              "合规包",
		TotalPacks:         "合规包总数：",
		AvailablePacks:     "可用的合规包",
		PackID:             "合规包 ID",
		RulesCount:         "规则数",
	},
	"es": {
		Severity:           "Severidad",
		Description:        "Descripción",
		ReasonForViolation: "Razón de la Violación",
		Recommendation:     "Recomendación",
		ResourceTypes:      "Tipos de Recurso",
		ResourceTypesDesc:  "Esta regla se aplica a los siguientes tipos de recursos:",
		AutoGenerated:      "_Este documento se genera automáticamente a partir de los metadatos de la política._",
		IncludedRules:      "Reglas Incluidas",
		IncludedRulesDesc:  "Este paquete de cumplimiento incluye las siguientes reglas:",
		Rules:              "Reglas",
		TotalRules:         "Total de reglas:",
		RulesBySeverity:    "Reglas por Severidad",
		SeverityHigh:       "Alta",
		SeverityMedium:     "Media",
		SeverityLow:        "Baja",
		RuleID:             "ID de Regla",
		Name:               "Nombre",
		DescriptionCol:     "Descripción",
		Packs:              "Paquetes",
		TotalPacks:         "Total de paquetes:",
		AvailablePacks:     "Paquetes Disponibles",
		PackID:             "ID de Paquete",
		RulesCount:         "Reglas",
	},
	"fr": {
		Severity:           "Gravité",
		Description:        "Description",
		ReasonForViolation: "Raison de la Violation",
		Recommendation:     "Recommandation",
		ResourceTypes:      "Types de Ressources",
		ResourceTypesDesc:  "Cette règle s'applique aux types de ressources suivants :",
		AutoGenerated:      "_Ce document est généré automatiquement à partir des métadonnées de la politique._",
		IncludedRules:      "Règles Incluses",
		IncludedRulesDesc:  "Ce pack de conformité comprend les règles suivantes :",
		Rules:              "Règles",
		TotalRules:         "Total des règles :",
		RulesBySeverity:    "Règles par Gravité",
		SeverityHigh:       "Élevée",
		SeverityMedium:     "Moyenne",
		SeverityLow:        "Faible",
		RuleID:             "ID de Règle",
		Name:               "Nom",
		DescriptionCol:     "Description",
		Packs:              "Packs",
		TotalPacks:         "Total des packs :",
		AvailablePacks:     "Packs Disponibles",
		PackID:             "ID de Pack",
		RulesCount:         "Règles",
	},
	"de": {
		Severity:           "Schweregrad",
		Description:        "Beschreibung",
		ReasonForViolation: "Grund für die Verletzung",
		Recommendation:     "Empfehlung",
		ResourceTypes:      "Ressourcentypen",
		ResourceTypesDesc:  "Diese Regel gilt für die folgenden Ressourcentypen:",
		AutoGenerated:      "_Dieses Dokument wird automatisch aus den Richtlinien-Metadaten generiert._",
		IncludedRules:      "Enthaltene Regeln",
		IncludedRulesDesc:  "Dieses Compliance-Paket enthält die folgenden Regeln:",
		Rules:              "Regeln",
		TotalRules:         "Gesamtanzahl der Regeln:",
		RulesBySeverity:    "Regeln nach Schweregrad",
		SeverityHigh:       "Hoch",
		SeverityMedium:     "Mittel",
		SeverityLow:        "Niedrig",
		RuleID:             "Regel-ID",
		Name:               "Name",
		DescriptionCol:     "Beschreibung",
		Packs:              "Pakete",
		TotalPacks:         "Gesamtanzahl der Pakete:",
		AvailablePacks:     "Verfügbare Pakete",
		PackID:             "Paket-ID",
		RulesCount:         "Regeln",
	},
	"ja": {
		Severity:           "重大度",
		Description:        "説明",
		ReasonForViolation: "違反の理由",
		Recommendation:     "推奨事項",
		ResourceTypes:      "リソースタイプ",
		ResourceTypesDesc:  "このルールは次のリソースタイプに適用されます：",
		AutoGenerated:      "_このドキュメントはポリシーメタデータから自動生成されます。_",
		IncludedRules:      "含まれるルール",
		IncludedRulesDesc:  "このコンプライアンスパックには次のルールが含まれています：",
		Rules:              "ルール",
		TotalRules:         "ルールの合計：",
		RulesBySeverity:    "重大度別のルール",
		SeverityHigh:       "高",
		SeverityMedium:     "中",
		SeverityLow:        "低",
		RuleID:             "ルールID",
		Name:               "名前",
		DescriptionCol:     "説明",
		Packs:              "パック",
		TotalPacks:         "パックの合計：",
		AvailablePacks:     "利用可能なパック",
		PackID:             "パックID",
		RulesCount:         "ルール数",
	},
	"pt": {
		Severity:           "Severidade",
		Description:        "Descrição",
		ReasonForViolation: "Razão da Violação",
		Recommendation:     "Recomendação",
		ResourceTypes:      "Tipos de Recurso",
		ResourceTypesDesc:  "Esta regra se aplica aos seguintes tipos de recursos:",
		AutoGenerated:      "_Este documento é gerado automaticamente a partir dos metadados da política._",
		IncludedRules:      "Regras Incluídas",
		IncludedRulesDesc:  "Este pacote de conformidade inclui as seguintes regras:",
		Rules:              "Regras",
		TotalRules:         "Total de regras:",
		RulesBySeverity:    "Regras por Severidade",
		SeverityHigh:       "Alta",
		SeverityMedium:     "Média",
		SeverityLow:        "Baixa",
		RuleID:             "ID da Regra",
		Name:               "Nome",
		DescriptionCol:     "Descrição",
		Packs:              "Pacotes",
		TotalPacks:         "Total de pacotes:",
		AvailablePacks:     "Pacotes Disponíveis",
		PackID:             "ID do Pacote",
		RulesCount:         "Regras",
	},
}

type RuleMeta struct {
	ID             string            `json:"id"`
	Name           map[string]string `json:"name"`
	Severity       string            `json:"severity"`
	Description    map[string]string `json:"description"`
	Reason         map[string]string `json:"reason"`
	Recommendation map[string]string `json:"recommendation"`
	ResourceTypes  []string          `json:"resource_types"`
}

type PackMeta struct {
	ID          string            `json:"id"`
	Name        map[string]string `json:"name"`
	Description map[string]string `json:"description"`
	Rules       []string          `json:"rules"`
	Path        string            `json:"-"`
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	projectRoot, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}

	docsDir := filepath.Join(projectRoot, "docs", "docs")

	// Generate rule documentation and collect rules for validation
	// Traverse provider-first structure: policies/{provider}/rules/
	policiesDir := filepath.Join(projectRoot, "policies")
	providerRules, err := generateRulesDocs(policiesDir, docsDir)
	if err != nil {
		return fmt.Errorf("failed to generate rules docs: %w", err)
	}

	// Generate pack documentation with validation
	// Traverse provider-first structure: policies/{provider}/packs/
	if err := generatePacksDocs(policiesDir, docsDir, providerRules); err != nil {
		return fmt.Errorf("failed to generate packs docs: %w", err)
	}

	fmt.Println("✅ Policy documentation generated successfully")
	return nil
}

func generateRulesDocs(policiesDir, docsDir string) (map[string]map[string]bool, error) {
	// Read provider directories from policies root
	providers, err := os.ReadDir(policiesDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read policies directory: %w", err)
	}

	providerRules := make(map[string]map[string]bool)

	for _, provider := range providers {
		if !provider.IsDir() {
			continue
		}

		providerName := provider.Name()
		// Skip non-provider directories
		if providerName == "testdata" || providerName == "embed.go" {
			continue
		}

		// Check for provider-first structure: {provider}/rules/
		providerRulesDir := filepath.Join(policiesDir, providerName, "rules")
		if _, err := os.Stat(providerRulesDir); os.IsNotExist(err) {
			continue // Skip if rules directory doesn't exist
		}

		providerDocsDir := filepath.Join(docsDir, "policies", providerName, "rules")

		if err := os.MkdirAll(providerDocsDir, 0755); err != nil {
			return nil, fmt.Errorf("failed to create docs directory: %w", err)
		}

		rules, err := loadRules(providerRulesDir, filepath.Join(policiesDir, providerName))
		if err != nil {
			return nil, fmt.Errorf("failed to load rules for %s: %w", providerName, err)
		}

		providerRules[providerName] = make(map[string]bool)
		for _, rule := range rules {
			// Store stripped ID for validation
			ruleID := rule.ID
			if strings.HasPrefix(ruleID, "rule:"+providerName+":") {
				ruleID = strings.TrimPrefix(ruleID, "rule:"+providerName+":")
			}
			providerRules[providerName][ruleID] = true

			if err := generateRulePage(rule, providerDocsDir, providerName); err != nil {
				return nil, fmt.Errorf("failed to generate rule page for %s: %w", rule.ID, err)
			}
		}

		if err := generateRulesIndexPage(rules, docsDir, providerName); err != nil {
			return nil, fmt.Errorf("failed to generate rules index for %s: %w", providerName, err)
		}

		fmt.Printf("✓ Generated %d rule docs for %s\n", len(rules), providerName)
	}

	return providerRules, nil
}

func generatePacksDocs(policiesDir, docsDir string, providerRules map[string]map[string]bool) error {
	// Read provider directories from policies root
	providers, err := os.ReadDir(policiesDir)
	if err != nil {
		return fmt.Errorf("failed to read policies directory: %w", err)
	}

	for _, provider := range providers {
		if !provider.IsDir() {
			continue
		}

		providerName := provider.Name()
		// Skip non-provider directories
		if providerName == "testdata" || providerName == "embed.go" {
			continue
		}

		// Check for provider-first structure: {provider}/packs/
		providerPacksDir := filepath.Join(policiesDir, providerName, "packs")
		if _, err := os.Stat(providerPacksDir); os.IsNotExist(err) {
			continue // Skip if packs directory doesn't exist
		}

		providerDocsDir := filepath.Join(docsDir, "policies", providerName, "packs")

		if err := os.MkdirAll(providerDocsDir, 0755); err != nil {
			return fmt.Errorf("failed to create docs directory: %w", err)
		}

		packs, err := loadPacks(providerPacksDir)
		if err != nil {
			return fmt.Errorf("failed to load packs for %s: %w", providerName, err)
		}

		for _, pack := range packs {
			// Validate that all rules in the pack exist
			var validRules []string
			for _, ruleID := range pack.Rules {
				// Strip prefix if present for validation
				strippedID := ruleID
				if strings.HasPrefix(ruleID, "rule:"+providerName+":") {
					strippedID = strings.TrimPrefix(ruleID, "rule:"+providerName+":")
				}

				if !providerRules[providerName][strippedID] {
					fmt.Printf("⚠️  Rule %s in pack %s (provider %s) does not exist. Commenting it out...\n", ruleID, pack.ID, providerName)
					if err := commentOutRuleInPack(pack.Path, ruleID); err != nil {
						fmt.Printf("❌ Failed to comment out rule %s in %s: %v\n", ruleID, pack.Path, err)
					}
					continue
				}
				validRules = append(validRules, ruleID)
			}
			pack.Rules = validRules

			if err := generatePackPage(pack, providerDocsDir, providerName); err != nil {
				return fmt.Errorf("failed to generate pack page for %s: %w", pack.ID, err)
			}
		}

		if err := generatePacksIndexPage(packs, docsDir, providerName); err != nil {
			return fmt.Errorf("failed to generate packs index for %s: %w", providerName, err)
		}

		fmt.Printf("✓ Generated %d pack docs for %s\n", len(packs), providerName)
	}

	return nil
}

func loadRules(rulesDir, providerDir string) ([]RuleMeta, error) {
	// Load rules directory
	result, err := loader.NewFileLoader().AsBundle(rulesDir)
	if err != nil {
		return nil, err
	}

	// Also load helper library from {provider}/lib/
	helperDir := filepath.Join(providerDir, "lib")
	helperResult, err := loader.NewFileLoader().AsBundle(helperDir)
	if err == nil {
		// Merge helper modules if available
		for _, moduleFile := range helperResult.Modules {
			result.Modules = append(result.Modules, moduleFile)
		}
	}

	modules := make(map[string]*ast.Module)
	for _, moduleFile := range result.Modules {
		module, err := ast.ParseModule(moduleFile.Path, string(moduleFile.Raw))
		if err != nil {
			continue
		}
		modules[moduleFile.Path] = module
	}

	compiler := ast.NewCompiler()
	compiler.Compile(modules)
	if compiler.Failed() {
		// Ignore compilation errors, just skip problematic files
		// return nil, compiler.Errors
	}

	var rules []RuleMeta
	for _, module := range modules {
		// Only extract from rule modules
		if !strings.Contains(module.Package.Path.String(), ".rules.") {
			continue
		}
		rule, err := extractRuleMeta(module, compiler)
		if err != nil {
			continue
		}
		rules = append(rules, rule)
	}

	sort.Slice(rules, func(i, j int) bool {
		return rules[i].ID < rules[j].ID
	})

	return rules, nil
}

func loadPacks(dir string) ([]PackMeta, error) {
	result, err := loader.NewFileLoader().AsBundle(dir)
	if err != nil {
		return nil, err
	}

	modules := make(map[string]*ast.Module)
	for _, moduleFile := range result.Modules {
		module, err := ast.ParseModule(moduleFile.Path, string(moduleFile.Raw))
		if err != nil {
			continue
		}
		modules[moduleFile.Path] = module
	}

	compiler := ast.NewCompiler()
	compiler.Compile(modules)
	if compiler.Failed() {
		// Ignore compilation errors
	}

	var packs []PackMeta
	for path, module := range modules {
		pack, err := extractPackMeta(module, compiler)
		if err != nil {
			continue
		}
		pack.Path = path
		packs = append(packs, pack)
	}

	sort.Slice(packs, func(i, j int) bool {
		return packs[i].ID < packs[j].ID
	})

	return packs, nil
}

func extractRuleMeta(module *ast.Module, compiler *ast.Compiler) (RuleMeta, error) {
	var meta RuleMeta

	// Find the rule_meta rule in the module
	for _, rule := range module.Rules {
		if rule.Head.Name.String() == "rule_meta" {
			// Evaluate the rule to get its value
			term := rule.Head.Value
			if term == nil {
				continue
			}

			// Parse the object
			obj, ok := term.Value.(ast.Object)
			if !ok {
				continue
			}

			// Extract fields
			meta.ID = extractString(obj, "id")
			meta.Name = extractI18nMap(obj, "name")
			meta.Severity = extractString(obj, "severity")
			meta.Description = extractI18nMap(obj, "description")
			meta.Reason = extractI18nMap(obj, "reason")
			meta.Recommendation = extractI18nMap(obj, "recommendation")
			meta.ResourceTypes = extractStringArray(obj, "resource_types")

			if meta.ID != "" {
				return meta, nil
			}
		}
	}

	return meta, fmt.Errorf("rule_meta not found.")
}

func extractPackMeta(module *ast.Module, compiler *ast.Compiler) (PackMeta, error) {
	var meta PackMeta

	for _, rule := range module.Rules {
		if rule.Head.Name.String() == "pack_meta" {
			term := rule.Head.Value
			if term == nil {
				continue
			}

			obj, ok := term.Value.(ast.Object)
			if !ok {
				continue
			}

			meta.ID = extractString(obj, "id")
			meta.Name = extractI18nMap(obj, "name")
			meta.Description = extractI18nMap(obj, "description")
			meta.Rules = extractStringArray(obj, "rules")

			if meta.ID != "" {
				return meta, nil
			}
		}
	}

	return meta, fmt.Errorf("pack_meta not found.")
}

func extractString(obj ast.Object, key string) string {
	keyTerm := ast.StringTerm(key)
	value := obj.Get(keyTerm)
	if value == nil {
		return ""
	}

	if str, ok := value.Value.(ast.String); ok {
		return string(str)
	}

	return ""
}

func extractI18nMap(obj ast.Object, key string) map[string]string {
	result := make(map[string]string)
	keyTerm := ast.StringTerm(key)
	value := obj.Get(keyTerm)
	if value == nil {
		return result
	}

	// Check if it's a string (non-i18n)
	if str, ok := value.Value.(ast.String); ok {
		s := string(str)
		// For non-i18n strings, set for all supported languages
		for _, lang := range getSupportedLanguages() {
			result[lang] = s
		}
		return result
	}

	// Check if it's an object (i18n map)
	if mapObj, ok := value.Value.(ast.Object); ok {
		// Extract all supported languages
		for _, lang := range getSupportedLanguages() {
			langValue := mapObj.Get(ast.StringTerm(lang))
			if langValue != nil {
				if str, ok := langValue.Value.(ast.String); ok {
					result[lang] = string(str)
				}
			}
		}
	}

	return result
}

func extractStringArray(obj ast.Object, key string) []string {
	var result []string
	keyTerm := ast.StringTerm(key)
	value := obj.Get(keyTerm)
	if value == nil {
		return result
	}

	// Use type switch to handle Array properly
	switch v := value.Value.(type) {
	case *ast.Array:
		v.Foreach(func(term *ast.Term) {
			if str, ok := term.Value.(ast.String); ok {
				result = append(result, string(str))
			}
		})
	}

	return result
}

func generateRulePage(rule RuleMeta, outputDir, provider string) error {
	// Strip provider prefix from ID for filename if present (e.g., rule:aliyun:rule-id -> rule-id)
	ruleFilename := rule.ID
	if strings.HasPrefix(rule.ID, "rule:"+provider+":") {
		ruleFilename = strings.TrimPrefix(rule.ID, "rule:"+provider+":")
	}

	// Generate documentation for all supported languages
	for _, lang := range getSupportedLanguages() {
		if err := generateRulePageForLang(rule, outputDir, provider, ruleFilename, lang); err != nil {
			return err
		}
	}

	return nil
}

func generateRulePageForLang(rule RuleMeta, outputDir, provider, ruleFilename, lang string) error {
	templates := docTemplatesMap[lang]
	langDir := getI18nDir(outputDir, lang)
	if err := os.MkdirAll(langDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(langDir, ruleFilename+".md")
	name := getI18nString(rule.Name, lang)
	desc := getI18nString(rule.Description, lang)
	reason := getI18nString(rule.Reason, lang)
	rec := getI18nString(rule.Recommendation, lang)

	content := fmt.Sprintf(`---
title: %s
sidebar_label: %s
---

# %s

**ID**: `+"`rule:%s:%s`"+`  
**%s**: `+"`%s`"+`

## %s

%s

## %s

%s

## %s

%s

## %s

%s

`,
		name,
		name,
		name,
		provider, ruleFilename,
		templates.Severity, rule.Severity,
		templates.Description,
		desc,
		templates.ReasonForViolation,
		reason,
		templates.Recommendation,
		rec,
		templates.ResourceTypes,
		formatResourceTypesI18n(rule.ResourceTypes, lang),
	)

	// Add auto-generated footer for non-English languages
	if lang != "en" && templates.AutoGenerated != "" {
		content += fmt.Sprintf("\n---\n\n%s\n", templates.AutoGenerated)
	}

	return os.WriteFile(filename, []byte(content), 0644)
}

func generatePackPage(pack PackMeta, outputDir, provider string) error {
	// Generate documentation for all supported languages
	for _, lang := range getSupportedLanguages() {
		if err := generatePackPageForLang(pack, outputDir, provider, lang); err != nil {
			return err
		}
	}

	return nil
}

func generatePackPageForLang(pack PackMeta, outputDir, provider, lang string) error {
	templates := docTemplatesMap[lang]
	langDir := getI18nDir(outputDir, lang)
	if err := os.MkdirAll(langDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(langDir, pack.ID+".md")
	name := getI18nString(pack.Name, lang)
	desc := getI18nString(pack.Description, lang)

	content := fmt.Sprintf(`---
title: %s
sidebar_label: %s
---

# %s

**ID**: `+"`pack:%s:%s`"+`

## %s

%s

## %s

%s

`,
		name,
		name,
		name,
		provider, pack.ID,
		templates.Description,
		desc,
		templates.IncludedRules,
		formatRulesListI18n(pack.Rules, provider),
	)

	// Add auto-generated footer for non-English languages
	if lang != "en" && templates.AutoGenerated != "" {
		content += fmt.Sprintf("\n---\n\n%s\n", templates.AutoGenerated)
	}

	return os.WriteFile(filename, []byte(content), 0644)
}

func generateRulesIndexPage(rules []RuleMeta, docsDir, provider string) error {
	// Generate documentation for all supported languages
	for _, lang := range getSupportedLanguages() {
		if err := generateRulesIndexPageForLang(rules, docsDir, provider, lang); err != nil {
			return err
		}
	}

	return nil
}

func generateRulesIndexPageForLang(rules []RuleMeta, docsDir, provider, lang string) error {
	templates := docTemplatesMap[lang]

	// Calculate directory path
	var langDir string
	if lang == "en" {
		langDir = filepath.Join(docsDir, "policies", provider)
	} else {
		langDir = filepath.Join(docsDir, "../i18n", lang, "docusaurus-plugin-content-docs/current/policies", provider)
	}

	if err := os.MkdirAll(langDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(langDir, "rules.md")

	// Group rules by severity
	bySeverity := map[string][]RuleMeta{
		"high":   {},
		"medium": {},
		"low":    {},
	}
	for _, rule := range rules {
		bySeverity[rule.Severity] = append(bySeverity[rule.Severity], rule)
	}

	// Build content
	providerTitle := strings.Title(provider)
	content := fmt.Sprintf(`---
title: %s %s
sidebar_label: %s
---

# %s %s

%s **%d**

## %s

`,
		providerTitle, templates.Rules,
		templates.Rules,
		providerTitle, templates.Rules,
		templates.TotalRules, len(rules),
		templates.RulesBySeverity,
	)

	for _, severity := range []string{"high", "medium", "low"} {
		severityRules := bySeverity[severity]
		if len(severityRules) == 0 {
			continue
		}

		severityLabel := getSeverityLabel(severity, lang)
		content += fmt.Sprintf("### %s %s (%d %s)\n\n", severityLabel, templates.Severity, len(severityRules), templates.Rules)
		content += fmt.Sprintf("| %s | %s | %s |\n", templates.RuleID, templates.Name, templates.DescriptionCol)
		content += "|---------|------|-------------|\n"

		for _, rule := range severityRules {
			name := getI18nString(rule.Name, lang)
			desc := getI18nString(rule.Description, lang)

			ruleFilename := rule.ID
			if strings.HasPrefix(rule.ID, "rule:"+provider+":") {
				ruleFilename = strings.TrimPrefix(rule.ID, "rule:"+provider+":")
			}

			content += fmt.Sprintf("| [%s](./rules/%s) | %s | %s |\n",
				ruleFilename, ruleFilename, name, desc)
		}
		content += "\n"
	}

	// Add auto-generated footer for non-English languages
	if lang != "en" && templates.AutoGenerated != "" {
		content += fmt.Sprintf("\n---\n\n%s\n", templates.AutoGenerated)
	}

	return os.WriteFile(filename, []byte(content), 0644)
}

func generatePacksIndexPage(packs []PackMeta, docsDir, provider string) error {
	// Generate documentation for all supported languages
	for _, lang := range getSupportedLanguages() {
		if err := generatePacksIndexPageForLang(packs, docsDir, provider, lang); err != nil {
			return err
		}
	}

	return nil
}

func generatePacksIndexPageForLang(packs []PackMeta, docsDir, provider, lang string) error {
	templates := docTemplatesMap[lang]

	// Calculate directory path
	var langDir string
	if lang == "en" {
		langDir = filepath.Join(docsDir, "policies", provider)
	} else {
		langDir = filepath.Join(docsDir, "../i18n", lang, "docusaurus-plugin-content-docs/current/policies", provider)
	}

	if err := os.MkdirAll(langDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(langDir, "packs.md")

	providerTitle := strings.Title(provider)
	content := fmt.Sprintf(`---
title: %s %s
sidebar_label: %s
---

# %s %s

%s **%d**

## %s

| %s | %s | %s | %s |
|---------|------|-------|-------------|
`,
		providerTitle, templates.Packs,
		templates.Packs,
		providerTitle, templates.Packs,
		templates.TotalPacks, len(packs),
		templates.AvailablePacks,
		templates.PackID, templates.Name, templates.RulesCount, templates.DescriptionCol,
	)

	for _, pack := range packs {
		name := getI18nString(pack.Name, lang)
		desc := getI18nString(pack.Description, lang)
		content += fmt.Sprintf("| [%s](./packs/%s) | %s | %d | %s |\n",
			pack.ID, pack.ID, name, len(pack.Rules), desc)
	}

	// Add auto-generated footer for non-English languages
	if lang != "en" && templates.AutoGenerated != "" {
		content += fmt.Sprintf("\n---\n\n%s\n", templates.AutoGenerated)
	}

	return os.WriteFile(filename, []byte(content), 0644)
}

func getI18nString(m map[string]string, lang string) string {
	if v, ok := m[lang]; ok {
		return v
	}
	// Fallback to English if available
	if v, ok := m["en"]; ok {
		return v
	}
	// Fallback to any available value
	for _, v := range m {
		return v
	}
	return ""
}

// getI18nDir returns the i18n directory path for a given language
func getI18nDir(outputDir, lang string) string {
	if lang == "en" {
		return outputDir
	}
	return strings.Replace(outputDir, "/docs/docs/", fmt.Sprintf("/docs/i18n/%s/docusaurus-plugin-content-docs/current/", lang), 1)
}

// formatResourceTypesI18n formats resource types with language-specific text
func formatResourceTypesI18n(types []string, lang string) string {
	if len(types) == 0 {
		if lang == "en" {
			return "_No specific resource types_"
		}
		// Use English fallback for other languages
		return "_No specific resource types_"
	}
	var result strings.Builder
	for _, t := range types {
		result.WriteString(fmt.Sprintf("- `%s`\n", t))
	}
	return result.String()
}

// formatRulesListI18n formats rules list (same for all languages, just the link format)
func formatRulesListI18n(rules []string, provider string) string {
	var result strings.Builder
	for _, ruleID := range rules {
		ruleFilename := ruleID
		if strings.HasPrefix(ruleID, "rule:"+provider+":") {
			ruleFilename = strings.TrimPrefix(ruleID, "rule:"+provider+":")
		}
		result.WriteString(fmt.Sprintf("- [`rule:%s:%s`](../rules/%s)\n", provider, ruleFilename, ruleFilename))
	}
	return result.String()
}

// getSeverityLabel returns the severity label in the specified language
func getSeverityLabel(severity, lang string) string {
	templates := docTemplatesMap[lang]
	switch severity {
	case "high":
		return templates.SeverityHigh
	case "medium":
		return templates.SeverityMedium
	case "low":
		return templates.SeverityLow
	default:
		return severity
	}
}

func formatResourceTypes(types []string) string {
	if len(types) == 0 {
		return "_No specific resource types_"
	}
	var result strings.Builder
	for _, t := range types {
		result.WriteString(fmt.Sprintf("- `%s`\n", t))
	}
	return result.String()
}

func formatRulesList(rules []string, provider string) string {
	var result strings.Builder
	for _, ruleID := range rules {
		ruleFilename := ruleID
		if strings.HasPrefix(ruleID, "rule:"+provider+":") {
			ruleFilename = strings.TrimPrefix(ruleID, "rule:"+provider+":")
		}
		result.WriteString(fmt.Sprintf("- [`rule:%s:%s`](../rules/%s)\n", provider, ruleFilename, ruleFilename))
	}
	return result.String()
}

func formatRulesListZh(rules []string, provider string) string {
	var result strings.Builder
	for _, ruleID := range rules {
		ruleFilename := ruleID
		if strings.HasPrefix(ruleID, "rule:"+provider+":") {
			ruleFilename = strings.TrimPrefix(ruleID, "rule:"+provider+":")
		}
		result.WriteString(fmt.Sprintf("- [`rule:%s:%s`](../rules/%s)\n", provider, ruleFilename, ruleFilename))
	}
	return result.String()
}

func truncateString(s string, maxLen int) string {
	runes := []rune(s)
	if len(runes) <= maxLen {
		return s
	}
	return string(runes[:maxLen]) + "..."
}

func commentOutRuleInPack(path, ruleID string) error {
	content, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	// Regex to find the rule ID in a string within an array, possibly followed by a comma
	// Matches: "rule-id" or "rule-id",
	re := regexp.MustCompile(`(?m)^(\s*)("` + ruleID + `",?)(\s*)$`)

	newContent := re.ReplaceAllString(string(content), `$1# $2$3`)

	if string(content) == newContent {
		// Try a less strict version if the above fails (e.g., if it's not the only thing on the line)
		re2 := regexp.MustCompile(`"` + ruleID + `"`)
		newContent = re2.ReplaceAllString(string(content), `# "`+ruleID+`"`)
		if string(content) == newContent {
			return fmt.Errorf("rule ID %s not found in %s.", ruleID, path)
		}
	}

	return os.WriteFile(path, []byte(newContent), 0644)
}
