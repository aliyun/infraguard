package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/aliyun/infraguard/pkg/models"
	"github.com/aliyun/infraguard/pkg/policy"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	policyDir := "policies"
	outputFile := "pkg/policy/index_gen.go"

	index := &models.PolicyIndex{
		Rules:      make(map[string]*models.Rule),
		Packs:      make(map[string]*models.Pack),
		RuleList:   make([]*models.Rule, 0),
		PackList:   make([]*models.Pack, 0),
		LibModules: make(map[string]string),
	}

	// Manual walk to simulate Load() but with more control for generation
	entries, err := os.ReadDir(policyDir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		provider := entry.Name()
		providerDir := filepath.Join(policyDir, provider)

		// Lib modules
		libDir := filepath.Join(providerDir, "lib")
		if info, err := os.Stat(libDir); err == nil && info.IsDir() {
			filepath.WalkDir(libDir, func(path string, d os.DirEntry, err error) error {
				if !d.IsDir() && strings.HasSuffix(path, ".rego") {
					content, _ := os.ReadFile(path)
					relPath := strings.TrimPrefix(path, policyDir+string(filepath.Separator))
					index.LibModules[relPath] = string(content)
				}
				return nil
			})
		}

		// Rules
		rulesDir := filepath.Join(providerDir, "rules")
		if info, err := os.Stat(rulesDir); err == nil && info.IsDir() {
			rules, err := policy.DiscoverRules(rulesDir)
			if err != nil {
				return err
			}
			for _, rule := range rules {
				content, _ := os.ReadFile(rule.FilePath)
				rule.Content = string(content)
				rule.FilePath = strings.TrimPrefix(rule.FilePath, policyDir+string(filepath.Separator))
				index.Rules[rule.ID] = rule
				index.RuleList = append(index.RuleList, rule)
			}
		}

		// Packs
		packsDir := filepath.Join(providerDir, "packs")
		if info, err := os.Stat(packsDir); err == nil && info.IsDir() {
			packs, err := policy.DiscoverPacks(packsDir)
			if err != nil {
				return err
			}
			for _, pack := range packs {
				content, _ := os.ReadFile(pack.FilePath)
				pack.Content = string(content)
				pack.FilePath = strings.TrimPrefix(pack.FilePath, policyDir+string(filepath.Separator))
				index.Packs[pack.ID] = pack
				index.PackList = append(index.PackList, pack)
			}
		}
	}

	// Sort lists for deterministic output
	sort.Slice(index.RuleList, func(i, j int) bool {
		return index.RuleList[i].ID < index.RuleList[j].ID
	})
	sort.Slice(index.PackList, func(i, j int) bool {
		return index.PackList[i].ID < index.PackList[j].ID
	})

	// Sort LibModules keys for deterministic output
	var libKeys []string
	for k := range index.LibModules {
		libKeys = append(libKeys, k)
	}
	sort.Strings(libKeys)

	// Generate code
	f, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by policy-gen. DO NOT EDIT.")
	fmt.Fprintln(f, "package policy")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import (")
	fmt.Fprintln(f, "\t\"github.com/aliyun/infraguard/pkg/models\"")
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "func init() {")
	fmt.Fprintln(f, "\tEmbeddedIndex = &models.PolicyIndex{")
	fmt.Fprintln(f, "\t\tRules:      make(map[string]*models.Rule),")
	fmt.Fprintln(f, "\t\tPacks:      make(map[string]*models.Pack),")
	fmt.Fprintln(f, "\t\tLibModules: make(map[string]string),")
	fmt.Fprintln(f, "\t}")
	fmt.Fprintln(f)

	for _, k := range libKeys {
		fmt.Fprintf(f, "\tEmbeddedIndex.LibModules[%#v] = %#v\n", k, index.LibModules[k])
	}
	fmt.Fprintln(f)

	for _, rule := range index.RuleList {
		fmt.Fprintf(f, "\taddRule(%#v)\n", rule)
	}
	fmt.Fprintln(f)

	for _, pack := range index.PackList {
		fmt.Fprintf(f, "\taddPack(%#v)\n", pack)
	}

	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "func addRule(r *models.Rule) {")
	fmt.Fprintln(f, "\tEmbeddedIndex.Rules[r.ID] = r")
	fmt.Fprintln(f, "\tEmbeddedIndex.RuleList = append(EmbeddedIndex.RuleList, r)")
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "func addPack(p *models.Pack) {")
	fmt.Fprintln(f, "\tEmbeddedIndex.Packs[p.ID] = p")
	fmt.Fprintln(f, "\tEmbeddedIndex.PackList = append(EmbeddedIndex.PackList, p)")
	fmt.Fprintln(f, "}")

	return nil
}
