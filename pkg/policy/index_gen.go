// Code generated by policy-gen. DO NOT EDIT.
package policy

import (
	"github.com/aliyun/infraguard/pkg/models"
)

func init() {
	EmbeddedIndex = &models.PolicyIndex{
		Rules:      make(map[string]*models.Rule),
		Packs:      make(map[string]*models.Pack),
		LibModules: make(map[string]string),
	}

	EmbeddedIndex.LibModules["aliyun/lib/helpers.rego"] = "# Package for InfraGuard helper functions\n# These functions are built-in to InfraGuard and available in all policy files\n# Usage: import data.infraguard.helpers\npackage infraguard.helpers\n\nimport rego.v1\n\n# ============================================================================\n# Value Checking Helpers\n# ============================================================================\n\n# Check if a value is true (handles string \"true\" as well)\nis_true(v) if {\n\tv == true\n}\n\nis_true(v) if {\n\tv == \"true\"\n}\n\n# Check if a value is false (handles string \"false\" as well)\nis_false(v) if {\n\tv == false\n}\n\nis_false(v) if {\n\tv == \"false\"\n}\n\n# Check if a value is in a list\nincludes(list, elem) if {\n\tlist[_] == elem\n}\n\n# ============================================================================\n# Network Helpers\n# ============================================================================\n\n# Check if CIDR is public IPv4 (0.0.0.0/0)\nis_public_cidr(cidr) if {\n\tcidr == \"0.0.0.0/0\"\n}\n\n# Check if CIDR is public IPv6 (::/0)\nis_public_cidr(cidr) if {\n\tcidr == \"::/0\"\n}\n\n# Private IPv4 CIDR ranges (RFC 1918 and others)\nprivate_cidrs := [\n\t\"10.0.0.0/8\", # Class A private\n\t\"172.16.0.0/12\", # Class B private\n\t\"192.168.0.0/16\", # Class C private\n\t\"127.0.0.0/8\", # Loopback\n\t\"169.254.0.0/16\", # Link-local\n\t\"100.64.0.0/10\", # Carrier-grade NAT\n]\n\n# Check if a CIDR/IP is within private ranges (not public internet)\n# Returns true if the CIDR is private (not routable on public internet)\nis_private_cidr(cidr) if {\n\tsome private_range in private_cidrs\n\tnet.cidr_contains(private_range, cidr)\n}\n\n# Check if a CIDR/IP is a public internet address\n# Returns true if the CIDR contains public internet IPs\nis_internet_cidr(cidr) if {\n\t# First check if it's a valid CIDR format (has /)\n\tcontains(cidr, \"/\")\n\n\t# If it's 0.0.0.0/0 or ::/0, it includes public internet\n\tis_public_cidr(cidr)\n}\n\nis_internet_cidr(cidr) if {\n\t# Check if it contains public internet IPs (not in any private range)\n\tcontains(cidr, \"/\")\n\tnot is_private_cidr(cidr)\n\tnot is_public_cidr(cidr)\n}\n\nis_internet_cidr(cidr) if {\n\t# Handle single IP address (no CIDR notation)\n\tnot contains(cidr, \"/\")\n\n\t# Add /32 suffix and check\n\tcidr_with_mask := concat(\"/\", [cidr, \"32\"])\n\tnot is_private_cidr(cidr_with_mask)\n}\n\n# ============================================================================\n# Port Helpers\n# ============================================================================\n\n# Parse port range string (e.g., \"22/22\", \"1/65535\", \"-1/-1\") into [start, end]\nparse_port_range(port_range) := [start, end] if {\n\tparts := split(port_range, \"/\")\n\tcount(parts) == 2\n\tstart := to_number(parts[0])\n\tend := to_number(parts[1])\n}\n\n# Check if a specific port is within a port range\nport_in_range(port, port_range) if {\n\t[start, end] := parse_port_range(port_range)\n\tstart != -1\n\tend != -1\n\tport >= start\n\tport <= end\n}\n\n# Check if port range is all ports (-1/-1)\nis_all_ports(port_range) if {\n\tport_range == \"-1/-1\"\n}\n\n# ============================================================================\n# Resource Helpers\n# ============================================================================\n\n# Get all resources of a specific type as a map (name -> resource)\nresources_by_type(resource_type) := resources if {\n\tresources := {name: resource |\n\t\tsome name, resource in input.Resources\n\t\tresource.Type == resource_type\n\t}\n}\n\n# Get all resources of multiple types as a map (name -> resource)\nresources_by_types(resource_types) := resources if {\n\tresources := {name: resource |\n\t\tsome name, resource in input.Resources\n\t\tresource.Type in resource_types\n\t}\n}\n\n# Get all resource names of a specific type\nresource_names_by_type(resource_type) := [name |\n\tsome name, res in input.Resources\n\tres.Type == resource_type\n]\n\n# Count resources of a specific type\ncount_resources_by_type(resource_type) := count(resources_by_type(resource_type))\n\n# Check if a resource type exists in the template\nresource_exists(resource_type) if {\n\tcount_resources_by_type(resource_type) > 0\n}\n\n# Check if a resource type does NOT exist in the template\nresource_not_exists(resource_type) if {\n\tcount_resources_by_type(resource_type) == 0\n}\n\n# ============================================================================\n# Property Helpers\n# ============================================================================\n\n# Check if property exists and is not null\nhas_property(resource, prop) if {\n\tresource.Properties[prop] != null\n}\n\n# Get property with default value\nget_property(resource, prop, default_value) := value if {\n\thas_property(resource, prop)\n\tvalue := resource.Properties[prop]\n} else := default_value\n\n# ============================================================================\n# Reference Helpers\n# ============================================================================\n\n# Resolve a value (handles Ref)\n# If v is {\"Ref\": \"Name\"}, returns \"Name\"\n# Otherwise returns v\nresolve_ref(v) := name if {\n\tis_object(v)\n\tname := v.Ref\n} else := v\n\n# Check if a value refers to a specific resource (by logical ID)\n# target_id is the Logical ID of the resource\nis_referencing(val, target_id) if {\n\tresolve_ref(val) == target_id\n}\n\n# Resolve Fn::GetAtt reference\n# If v is {\"Fn::GetAtt\": [\"ResourceName\", \"PropertyName\"]}, returns \"ResourceName\"\n# Otherwise returns v\nresolve_get_att(v) := name if {\n\tis_object(v)\n\tname := v[\"Fn::GetAtt\"][0]\n} else := v\n\n# Check if a value is a Fn::GetAtt reference to a specific resource\n# target_id is the Logical ID of the resource\nis_get_att_referencing(val, target_id) if {\n\tresolve_get_att(val) == target_id\n}\n\n# Check if a value matches a resource's identity (Logical ID or its name property)\n# resource_id is the Logical ID of the resource\n# name_prop is the property name that contains the actual resource name (e.g., \"UserName\")\nmatches_resource_id(val, resource_id, name_prop) if {\n\tis_referencing(val, resource_id)\n}\n\nmatches_resource_id(val, resource_id, name_prop) if {\n\tres := input.Resources[resource_id]\n\tactual_name := get_property(res, name_prop, resource_id)\n\tval == actual_name\n}\n\n# Check if a resource is referenced by another resource's property\n# target_id: Logical ID of the resource to check if it's referenced\n# ref_resource_type: Type of resource that might reference it (e.g., \"ALIYUN::ECS::DiskAttachment\")\n# property_path: Property path to check, supports paths like [\"DiskId\"]\nis_referenced_by_property(target_id, ref_resource_type, property_path) if {\n\tsome name, ref_resource in resources_by_type(ref_resource_type)\n\tcount(property_path) == 1\n\tprop := property_path[0]\n\thas_property(ref_resource, prop)\n\tprop_value := ref_resource.Properties[prop]\n\tis_referencing(prop_value, target_id)\n}\n\nis_referenced_by_property(target_id, ref_resource_type, property_path) if {\n\tsome name, ref_resource in resources_by_type(ref_resource_type)\n\tcount(property_path) == 1\n\tprop := property_path[0]\n\thas_property(ref_resource, prop)\n\tprop_value := ref_resource.Properties[prop]\n\tis_get_att_referencing(prop_value, target_id)\n}\n\n# ============================================================================\n# Tag Helpers\n# ============================================================================\n\n# Get tags from resource, handling different tag property names\n# Different resources may use different property names for tags:\n# - Most resources: \"Tags\" (array of {Key, Value})\n# - Some resources: \"Tag\" (single object or array)\n# - OSS Bucket: \"Tags\" (array of {Key, Value})\nget_resource_tags(resource) := tags if {\n\t# Standard Tags property (array of {Key, Value})\n\thas_property(resource, \"Tags\")\n\ttags := resource.Properties.Tags\n\tis_array(tags)\n\tcount(tags) > 0\n}\n\nget_resource_tags(resource) := tags if {\n\t# Alternative Tag property (array of {Key, Value})\n\thas_property(resource, \"Tag\")\n\ttags := resource.Properties.Tag\n\tis_array(tags)\n\tcount(tags) > 0\n}\n\n# Check if resource has any tags\nhas_tags(resource) if {\n\tget_resource_tags(resource) != null\n}\n\n# Check if resource has a specific tag key\nhas_tag_key(resource, tag_key) if {\n\ttags := get_resource_tags(resource)\n\tsome tag in tags\n\ttag.Key == tag_key\n}\n\n# Get tag value by key\nget_tag_value(resource, tag_key) := tag.Value if {\n\ttags := get_resource_tags(resource)\n\tsome tag in tags\n\ttag.Key == tag_key\n}\n\n# Check if resource has a specific tag key-value pair\nhas_tag_key_value(resource, tag_key, tag_value) if {\n\ttags := get_resource_tags(resource)\n\tsome tag in tags\n\ttag.Key == tag_key\n\ttag.Value == tag_value\n}\n\n# Check if resource has a specific tag key-value pair (supports wildcards)\n# tag_value_pattern can contain * and ? wildcards\n# * matches any sequence of characters\n# ? matches any single character\nmatches_tag_value(resource, tag_key, tag_value_pattern) if {\n\tactual_value := get_tag_value(resource, tag_key)\n\n\t# Use regex matching for wildcard support\n\t# Convert * to .* and ? to . for regex\n\tregex_pattern := replace_wildcards(tag_value_pattern)\n\tregex.match(regex_pattern, actual_value)\n}\n\n# Convert wildcard pattern to regex pattern\n# * -> .*\n# ? -> .\nreplace_wildcards(pattern) := regex if {\n\t# Replace * with .* and ? with .\n\tregex := replace(replace(pattern, \"*\", \".*\"), \"?\", \".\")\n}\n\n# Check if resource has all specified tags\n# required_tags is an array of tag objects with Key and Value\nhas_all_tags(resource, required_tags) if {\n\t# Check that all required tags exist and match\n\tcount(required_tags) == count([tag |\n\t\tsome tag in required_tags\n\t\thas_tag_key_value(resource, tag.Key, tag.Value)\n\t])\n}\n\n# Check if resource has at least one of the specified tags\n# tag_patterns is an array of tag objects with Key and Value (supports wildcards in Value)\nhas_any_tag(resource, tag_patterns) if {\n\tsome tag in tag_patterns\n\tmatches_tag_value(resource, tag.Key, tag.Value)\n}\n"

	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-encryption-enabled", Name: models.I18nString{"en": "ACK Cluster Secret Encryption Enabled", "zh": "ACK 集群配置 Secret 的落盘加密"}, Severity: "medium", Description: models.I18nString{"en": "ACK Pro clusters should have Secret encryption at rest enabled using KMS.", "zh": "ACK 集群配置 Secret 的落盘加密，视为合规。非专业托管版集群视为不适用。"}, Reason: models.I18nString{"en": "The ACK Pro cluster does not have Secret encryption at rest enabled.", "zh": "ACK 专业版集群未开启 Secret 落盘加密。"}, Recommendation: models.I18nString{"en": "Enable Secret encryption by specifying EncryptionProviderKey.", "zh": "通过指定 EncryptionProviderKey 开启 Secret 加密。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster"}, FilePath: "aliyun/rules/ack-cluster-encryption-enabled.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_encryption_enabled", Content: "package infraguard.rules.aliyun.ack_cluster_encryption_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ack-cluster-encryption-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Secret Encryption Enabled\",\n\t\t\"zh\": \"ACK 集群配置 Secret 的落盘加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ACK Pro clusters should have Secret encryption at rest enabled using KMS.\",\n\t\t\"zh\": \"ACK 集群配置 Secret 的落盘加密，视为合规。非专业托管版集群视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ACK Pro cluster does not have Secret encryption at rest enabled.\",\n\t\t\"zh\": \"ACK 专业版集群未开启 Secret 落盘加密。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable Secret encryption by specifying EncryptionProviderKey.\",\n\t\t\"zh\": \"通过指定 EncryptionProviderKey 开启 Secret 加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\"],\n}\n\n# Check if cluster is ACK Pro\nis_ack_pro(resource) if {\n\thelpers.get_property(resource, \"ClusterSpec\", \"\") == \"ack.pro.small\"\n}\n\n# Check if encryption is enabled\nis_encryption_enabled(resource) if {\n\thelpers.has_property(resource, \"EncryptionProviderKey\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_ack_pro(resource)\n\tnot is_encryption_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EncryptionProviderKey\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-inspect-kubelet-version-outdate-check", Name: models.I18nString{"en": "ACK Kubelet Version Check", "zh": "ACK 巡检：Kubelet 版本过时检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures the Kubelet version in the ACK cluster is up to date.", "zh": "确保 ACK 集群中的 Kubelet 版本是最新的。"}, Reason: models.I18nString{"en": "Outdated Kubelet versions may contain security vulnerabilities or compatibility issues.", "zh": "过时的 Kubelet 版本可能包含安全漏洞或兼容性问题。"}, Recommendation: models.I18nString{"en": "Upgrade the Kubelet version of the worker nodes.", "zh": "升级工作节点的 Kubelet 版本。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster"}, FilePath: "aliyun/rules/ack-cluster-inspect-kubelet-version-outdate-check.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_inspect_kubelet_version_outdate_check", Content: "package infraguard.rules.aliyun.ack_cluster_inspect_kubelet_version_outdate_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ack-cluster-inspect-kubelet-version-outdate-check\",\n\t\"name\": {\n\t\t\"en\": \"ACK Kubelet Version Check\",\n\t\t\"zh\": \"ACK 巡检：Kubelet 版本过时检测\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures the Kubelet version in the ACK cluster is up to date.\",\n\t\t\"zh\": \"确保 ACK 集群中的 Kubelet 版本是最新的。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Outdated Kubelet versions may contain security vulnerabilities or compatibility issues.\",\n\t\t\"zh\": \"过时的 Kubelet 版本可能包含安全漏洞或兼容性问题。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the Kubelet version of the worker nodes.\",\n\t\t\"zh\": \"升级工作节点的 Kubelet 版本。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\"],\n}\n\n# Real check requires runtime data. In IaC, we check if a standard version is used.\nis_compliant(resource) if {\n\tv := helpers.get_property(resource, \"KubernetesVersion\", \"\")\n\tnot helpers.includes([\"1.16\", \"1.18\"], v) # Example: flag very old versions\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CS::ManagedKubernetesCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"KubernetesVersion\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-log-plugin-installed", Name: models.I18nString{"en": "ACK Cluster Log Plugin Installed", "zh": "ACK 集群安装日志插件"}, Severity: "medium", Description: models.I18nString{"en": "Ensures the log-service addon is installed in the ACK cluster.", "zh": "确保 ACK 集群中安装了 log-service 组件。"}, Reason: models.I18nString{"en": "Log collection is essential for monitoring and troubleshooting containerized applications.", "zh": "日志采集对于监控和排查容器化应用的故障至关重要。"}, Recommendation: models.I18nString{"en": "Install the 'log-service' addon in the ACK cluster settings.", "zh": "在 ACK 集群设置中安装 'log-service' 组件。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster"}, FilePath: "aliyun/rules/ack-cluster-log-plugin-installed.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_log_plugin_installed", Content: "package infraguard.rules.aliyun.ack_cluster_log_plugin_installed\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ack-cluster-log-plugin-installed\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Log Plugin Installed\",\n\t\t\"zh\": \"ACK 集群安装日志插件\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures the log-service addon is installed in the ACK cluster.\",\n\t\t\"zh\": \"确保 ACK 集群中安装了 log-service 组件。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Log collection is essential for monitoring and troubleshooting containerized applications.\",\n\t\t\"zh\": \"日志采集对于监控和排查容器化应用的故障至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Install the 'log-service' addon in the ACK cluster settings.\",\n\t\t\"zh\": \"在 ACK 集群设置中安装 'log-service' 组件。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\"],\n}\n\nis_compliant(resource) if {\n\taddons := helpers.get_property(resource, \"Addons\", [])\n\tsome addon in addons\n\taddon.Name == \"log-service\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CS::ManagedKubernetesCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Addons\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-node-multi-zone", Name: models.I18nString{"en": "ACK Cluster Multi-Zone Deployment", "zh": "使用区域级多可用区 ACK 集群"}, Severity: "high", Description: models.I18nString{"en": "The ACK cluster nodes should be distributed across 3 or more availability zones for high availability.", "zh": "使用区域级 ACK 集群，节点分布在 3 个及以上可用区，视为合规。"}, Reason: models.I18nString{"en": "The ACK cluster nodes are not distributed across 3 or more availability zones.", "zh": "ACK 集群节点未分布在 3 个及以上可用区。"}, Recommendation: models.I18nString{"en": "Configure the cluster to use at least 3 availability zones by specifying multiple VSwitchIds.", "zh": "通过指定多个 VSwitchIds，将集群配置为使用至少 3 个可用区。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster", "ALIYUN::CS::KubernetesCluster"}, FilePath: "aliyun/rules/ack-cluster-node-multi-zone.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_node_multi_zone", Content: "package infraguard.rules.aliyun.ack_cluster_node_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ack-cluster-node-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Multi-Zone Deployment\",\n\t\t\"zh\": \"使用区域级多可用区 ACK 集群\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"The ACK cluster nodes should be distributed across 3 or more availability zones for high availability.\",\n\t\t\"zh\": \"使用区域级 ACK 集群，节点分布在 3 个及以上可用区，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ACK cluster nodes are not distributed across 3 or more availability zones.\",\n\t\t\"zh\": \"ACK 集群节点未分布在 3 个及以上可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the cluster to use at least 3 availability zones by specifying multiple VSwitchIds.\",\n\t\t\"zh\": \"通过指定多个 VSwitchIds，将集群配置为使用至少 3 个可用区。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::KubernetesCluster\"],\n}\n\n# Check if cluster is multi-zone\nis_multi_zone(resource) if {\n\tcount(object.get(resource.Properties, \"VSwitchIds\", [])) >= 3\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-public-endpoint-check", Name: models.I18nString{"en": "ACK Cluster Public Endpoint Check", "zh": "ACK 集群未设置公网连接端点"}, Severity: "high", Description: models.I18nString{"en": "ACK clusters should not have a public endpoint set, or the associated SLB listener should have ACL enabled.", "zh": "ACK 集群未设置公网连接端点，或关联的 SLB 的监听开启 acl 访问控制，视为合规。"}, Reason: models.I18nString{"en": "The ACK cluster has a public endpoint enabled, which may expose the API server to the internet.", "zh": "ACK 集群开启了公网连接端点，可能将 API Server 暴露给互联网。"}, Recommendation: models.I18nString{"en": "Disable the public endpoint for the ACK cluster by setting 'EndpointPublicAccess' to false.", "zh": "通过将'EndpointPublicAccess'设置为 false 来禁用 ACK 集群的公网连接端点。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster", "ALIYUN::CS::ASKCluster"}, FilePath: "aliyun/rules/ack-cluster-public-endpoint-check.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_public_endpoint_check", Content: "package infraguard.rules.aliyun.ack_cluster_public_endpoint_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ack-cluster-public-endpoint-check\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Public Endpoint Check\",\n\t\t\"zh\": \"ACK 集群未设置公网连接端点\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ACK clusters should not have a public endpoint set, or the associated SLB listener should have ACL enabled.\",\n\t\t\"zh\": \"ACK 集群未设置公网连接端点，或关联的 SLB 的监听开启 acl 访问控制，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ACK cluster has a public endpoint enabled, which may expose the API server to the internet.\",\n\t\t\"zh\": \"ACK 集群开启了公网连接端点，可能将 API Server 暴露给互联网。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable the public endpoint for the ACK cluster by setting 'EndpointPublicAccess' to false.\",\n\t\t\"zh\": \"通过将'EndpointPublicAccess'设置为 false 来禁用 ACK 集群的公网连接端点。\",\n\t},\n\t\"resource_types\": [\n\t\t\"ALIYUN::CS::ManagedKubernetesCluster\",\n\t\t\"ALIYUN::CS::ASKCluster\",\n\t],\n}\n\n# Check for ManagedKubernetesCluster\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CS::ManagedKubernetesCluster\")\n\thelpers.get_property(resource, \"EndpointPublicAccess\", false) == true\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EndpointPublicAccess\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check for ASKCluster\n# Default for ASKCluster EndpointPublicAccess is true\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CS::ASKCluster\")\n\tis_ask_public_access_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EndpointPublicAccess\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nis_ask_public_access_enabled(resource) if {\n\t# If explicitly true\n\thelpers.get_property(resource, \"EndpointPublicAccess\", false) == true\n}\n\nis_ask_public_access_enabled(resource) if {\n\t# If missing, default is true\n\tnot helpers.has_property(resource, \"EndpointPublicAccess\")\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-rrsa-enabled", Name: models.I18nString{"en": "ACK Cluster RRSA Enabled", "zh": "ACK 集群开启 RRSA"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the RAM Roles for Service Accounts (RRSA) feature is enabled for the ACK cluster.", "zh": "确保 ACK 集群开启了 RAM 角色注入(RRSA)功能。"}, Reason: models.I18nString{"en": "RRSA allows pods to assume RAM roles, providing a more secure and fine-grained way to manage permissions.", "zh": "RRSA 允许 Pod 扮演 RAM 角色，提供更安全、更细粒度的权限管理方式。"}, Recommendation: models.I18nString{"en": "Enable RRSA for the ACK cluster.", "zh": "为 ACK 集群开启 RRSA 功能。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster", "ALIYUN::CS::AnyCluster"}, FilePath: "aliyun/rules/ack-cluster-rrsa-enabled.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_rrsa_enabled", Content: "package infraguard.rules.aliyun.ack_cluster_rrsa_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ack-cluster-rrsa-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster RRSA Enabled\",\n\t\t\"zh\": \"ACK 集群开启 RRSA\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the RAM Roles for Service Accounts (RRSA) feature is enabled for the ACK cluster.\",\n\t\t\"zh\": \"确保 ACK 集群开启了 RAM 角色注入(RRSA)功能。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"RRSA allows pods to assume RAM roles, providing a more secure and fine-grained way to manage permissions.\",\n\t\t\"zh\": \"RRSA 允许 Pod 扮演 RAM 角色，提供更安全、更细粒度的权限管理方式。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable RRSA for the ACK cluster.\",\n\t\t\"zh\": \"为 ACK 集群开启 RRSA 功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"])\n\trrsa_config := helpers.get_property(resource, \"RrsaConfig\", {})\n\tenabled := rrsa_config.Enabled\n\tnot helpers.is_true(enabled)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RrsaConfig\", \"Enabled\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-spec-check", Name: models.I18nString{"en": "ACK Cluster Spec Check", "zh": "ACK 集群规格核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ACK clusters use approved specifications (e.g., ACK Pro).", "zh": "确保 ACK 集群使用批准的规格（如专业版 ACK Pro）。"}, Reason: models.I18nString{"en": "ACK Pro version clusters provide better reliability and SLA guarantees for production workloads.", "zh": "ACK 专业版集群为生产工作负载提供更好的可靠性和 SLA 保障。"}, Recommendation: models.I18nString{"en": "Upgrade the cluster to 'ack.pro.small' for production environments.", "zh": "对于生产环境，建议将集群规格升级为 'ack.pro.small'。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster"}, FilePath: "aliyun/rules/ack-cluster-spec-check.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_spec_check", Content: "package infraguard.rules.aliyun.ack_cluster_spec_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ack-cluster-spec-check\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Spec Check\",\n\t\t\"zh\": \"ACK 集群规格核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ACK clusters use approved specifications (e.g., ACK Pro).\",\n\t\t\"zh\": \"确保 ACK 集群使用批准的规格（如专业版 ACK Pro）。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"ACK Pro version clusters provide better reliability and SLA guarantees for production workloads.\",\n\t\t\"zh\": \"ACK 专业版集群为生产工作负载提供更好的可靠性和 SLA 保障。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the cluster to 'ack.pro.small' for production environments.\",\n\t\t\"zh\": \"对于生产环境，建议将集群规格升级为 'ack.pro.small'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\"],\n}\n\nis_compliant(resource) if {\n\tspec := helpers.get_property(resource, \"ClusterSpec\", \"\")\n\tspec == \"ack.pro.small\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CS::ManagedKubernetesCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ClusterSpec\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-supported-version", Name: models.I18nString{"en": "ACK Cluster Supported Version", "zh": "ACK 集群版本支持检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the ACK cluster is running a supported version.", "zh": "确保 ACK 集群运行的是受支持的版本。"}, Reason: models.I18nString{"en": "Running an unsupported version may lead to security vulnerabilities and lack of support.", "zh": "运行不受支持的版本可能导致安全漏洞和缺乏技术支持。"}, Recommendation: models.I18nString{"en": "Upgrade the ACK cluster to a supported version.", "zh": "将 ACK 集群升级到受支持的版本。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster", "ALIYUN::CS::AnyCluster"}, FilePath: "aliyun/rules/ack-cluster-supported-version.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_supported_version", Content: "package infraguard.rules.aliyun.ack_cluster_supported_version\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ack-cluster-supported-version\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Supported Version\",\n\t\t\"zh\": \"ACK 集群版本支持检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the ACK cluster is running a supported version.\",\n\t\t\"zh\": \"确保 ACK 集群运行的是受支持的版本。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Running an unsupported version may lead to security vulnerabilities and lack of support.\",\n\t\t\"zh\": \"运行不受支持的版本可能导致安全漏洞和缺乏技术支持。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the ACK cluster to a supported version.\",\n\t\t\"zh\": \"将 ACK 集群升级到受支持的版本。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"])\n\n\t# Conceptual check - any cluster with a version is potentially unsupported\n\thelpers.has_property(resource, \"KubernetesVersion\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"KubernetesVersion\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ack-cluster-upgrade-latest-version", Name: models.I18nString{"en": "ACK Cluster Upgraded to Latest Version", "zh": "ACK 集群已升级至最新版本"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the ACK cluster is running the latest available version.", "zh": "确保 ACK 集群运行的是最新的可用版本。"}, Reason: models.I18nString{"en": "Running the latest version ensures that you have the latest security patches and features.", "zh": "运行最新版本可确保您获得最新的安全补丁和功能。"}, Recommendation: models.I18nString{"en": "Upgrade the ACK cluster to the latest available version.", "zh": "将 ACK 集群升级到最新的可用版本。"}, ResourceTypes: []string{"ALIYUN::CS::ManagedKubernetesCluster", "ALIYUN::CS::AnyCluster"}, FilePath: "aliyun/rules/ack-cluster-upgrade-latest-version.rego", PackageName: "infraguard.rules.aliyun.ack_cluster_upgrade_latest_version", Content: "package infraguard.rules.aliyun.ack_cluster_upgrade_latest_version\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ack-cluster-upgrade-latest-version\",\n\t\"name\": {\n\t\t\"en\": \"ACK Cluster Upgraded to Latest Version\",\n\t\t\"zh\": \"ACK 集群已升级至最新版本\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the ACK cluster is running the latest available version.\",\n\t\t\"zh\": \"确保 ACK 集群运行的是最新的可用版本。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Running the latest version ensures that you have the latest security patches and features.\",\n\t\t\"zh\": \"运行最新版本可确保您获得最新的安全补丁和功能。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the ACK cluster to the latest available version.\",\n\t\t\"zh\": \"将 ACK 集群升级到最新的可用版本。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::CS::ManagedKubernetesCluster\", \"ALIYUN::CS::AnyCluster\"])\n\n\t# Conceptual check for version\n\thelpers.has_property(resource, \"ClusterVersion\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ClusterVersion\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:acs-cluster-node-multi-zone", Name: models.I18nString{"en": "ACS Cluster Node Multi-Zone Deployment", "zh": "使用区域级多可用区 ACS 集群"}, Severity: "high", Description: models.I18nString{"en": "The ACS cluster nodes should be distributed across 3 or more availability zones for high availability.", "zh": "使用区域级 ACS 集群，节点分布在 3 个及以上可用区，视为合规。"}, Reason: models.I18nString{"en": "The ACS cluster nodes are not distributed across 3 or more availability zones.", "zh": "ACS 集群节点未分布在 3 个及以上可用区。"}, Recommendation: models.I18nString{"en": "Configure the cluster to use at least 3 availability zones by specifying multiple ZoneIds or VSwitchIds.", "zh": "通过指定多个 ZoneIds 或 VSwitchIds，将集群配置为使用至少 3 个可用区。"}, ResourceTypes: []string{"ALIYUN::ACS::Cluster"}, FilePath: "aliyun/rules/acs-cluster-node-multi-zone.rego", PackageName: "infraguard.rules.aliyun.acs_cluster_node_multi_zone", Content: "package infraguard.rules.aliyun.acs_cluster_node_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"acs-cluster-node-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ACS Cluster Node Multi-Zone Deployment\",\n\t\t\"zh\": \"使用区域级多可用区 ACS 集群\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"The ACS cluster nodes should be distributed across 3 or more availability zones for high availability.\",\n\t\t\"zh\": \"使用区域级 ACS 集群，节点分布在 3 个及以上可用区，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ACS cluster nodes are not distributed across 3 or more availability zones.\",\n\t\t\"zh\": \"ACS 集群节点未分布在 3 个及以上可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the cluster to use at least 3 availability zones by specifying multiple ZoneIds or VSwitchIds.\",\n\t\t\"zh\": \"通过指定多个 ZoneIds 或 VSwitchIds，将集群配置为使用至少 3 个可用区。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ACS::Cluster\"],\n}\n\n# Check if cluster is multi-zone\nis_multi_zone(resource) if {\n\tcount(object.get(resource.Properties, \"ZoneIds\", [])) >= 3\n}\n\nis_multi_zone(resource) if {\n\t# If ZoneIds is not provided, check VSwitchIds as a proxy if ZoneIds is missing\n\tnot object.get(resource.Properties, \"ZoneIds\", [])\n\tcount(object.get(resource.Properties, \"VSwitchIds\", [])) >= 3\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:actiontrail-enabled", Name: models.I18nString{"en": "ActionTrail Enabled", "zh": "确保操作审计已开启"}, Severity: "high", Description: models.I18nString{"en": "Ensures ActionTrail is enabled to record account activities.", "zh": "确保开启了操作审计（ActionTrail）以记录账号活动。"}, Reason: models.I18nString{"en": "ActionTrail provides a record of API calls, which is essential for security auditing and forensic analysis.", "zh": "操作审计记录了 API 调用情况，这对于安全审计和取证分析至关重要。"}, Recommendation: models.I18nString{"en": "Create and enable at least one trail in ActionTrail.", "zh": "在操作审计中创建并启用至少一个跟踪（Trail）。"}, ResourceTypes: []string{"ALIYUN::ACTIONTRAIL::Trail"}, FilePath: "aliyun/rules/actiontrail-enabled.rego", PackageName: "infraguard.rules.aliyun.actiontrail_enabled", Content: "package infraguard.rules.aliyun.actiontrail_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"actiontrail-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ActionTrail Enabled\",\n\t\t\"zh\": \"确保操作审计已开启\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ActionTrail is enabled to record account activities.\",\n\t\t\"zh\": \"确保开启了操作审计（ActionTrail）以记录账号活动。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"ActionTrail provides a record of API calls, which is essential for security auditing and forensic analysis.\",\n\t\t\"zh\": \"操作审计记录了 API 调用情况，这对于安全审计和取证分析至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Create and enable at least one trail in ActionTrail.\",\n\t\t\"zh\": \"在操作审计中创建并启用至少一个跟踪（Trail）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ACTIONTRAIL::Trail\"],\n}\n\nis_compliant(resource) := true\n\n# If the resource exists in template, we check if logging is enabled\n# Note: Often requires ALIYUN::ACTIONTRAIL::TrailLogging\n# Basic check for existence of Trail resource\n\ndeny contains result if {\n\t# If no Trail resource exists at all in the template\n\thelpers.count_resources_by_type(\"ALIYUN::ACTIONTRAIL::Trail\") == 0\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"Global\",\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:actiontrail-trail-intact-enabled", Name: models.I18nString{"en": "ActionTrail Trail Intact Enabled", "zh": "开启操作审计全量日志跟踪"}, Severity: "high", Description: models.I18nString{"en": "ActionTrail trail should be enabled and track all event types (Read and Write).", "zh": "操作审计中存在开启状态的跟踪，且跟踪全部地域和全部事件类型。"}, Reason: models.I18nString{"en": "The ActionTrail trail is not enabled or does not track all event types.", "zh": "操作审计跟踪未开启或未跟踪所有事件类型。"}, Recommendation: models.I18nString{"en": "Enable the trail using ALIYUN::ACTIONTRAIL::TrailLogging and set EventRW to All in ALIYUN::ACTIONTRAIL::Trail.", "zh": "使用 ALIYUN::ACTIONTRAIL::TrailLogging 启用跟踪，并在 ALIYUN::ACTIONTRAIL::Trail 中将 EventRW 设置为 All。"}, ResourceTypes: []string{"ALIYUN::ACTIONTRAIL::Trail"}, FilePath: "aliyun/rules/actiontrail-trail-intact-enabled.rego", PackageName: "infraguard.rules.aliyun.actiontrail_trail_intact_enabled", Content: "package infraguard.rules.aliyun.actiontrail_trail_intact_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"actiontrail-trail-intact-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ActionTrail Trail Intact Enabled\",\n\t\t\"zh\": \"开启操作审计全量日志跟踪\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ActionTrail trail should be enabled and track all event types (Read and Write).\",\n\t\t\"zh\": \"操作审计中存在开启状态的跟踪，且跟踪全部地域和全部事件类型。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ActionTrail trail is not enabled or does not track all event types.\",\n\t\t\"zh\": \"操作审计跟踪未开启或未跟踪所有事件类型。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable the trail using ALIYUN::ACTIONTRAIL::TrailLogging and set EventRW to All in ALIYUN::ACTIONTRAIL::Trail.\",\n\t\t\"zh\": \"使用 ALIYUN::ACTIONTRAIL::TrailLogging 启用跟踪，并在 ALIYUN::ACTIONTRAIL::Trail 中将 EventRW 设置为 All。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ACTIONTRAIL::Trail\"],\n}\n\n# Get all enabled trail names from TrailLogging resources\nenabled_trails := {name |\n\tsome logging in helpers.resources_by_type(\"ALIYUN::ACTIONTRAIL::TrailLogging\")\n\thelpers.get_property(logging, \"Enable\", false) == true\n\tname := helpers.get_property(logging, \"Name\", \"\")\n\tname != \"\"\n}\n\n# Check if a trail is enabled (referenced by an enabled TrailLogging)\nis_trail_enabled(trail_name) if {\n\ttrail_name in enabled_trails\n}\n\n# Check if trail tracks all events\nis_track_all_events(resource) if {\n\thelpers.get_property(resource, \"EventRW\", \"Write\") == \"All\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\n\t# Get the trail name (either property Name or resource name if not set?)\n\t# Trail Name property is required.\n\ttrail_name := helpers.get_property(resource, \"Name\", \"\")\n\n\t# Check conditions\n\tviolation := check_violation(trail_name, resource)\n\tviolation != null\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EventRW\"], # Approximate path\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": violation,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ncheck_violation(trail_name, resource) := reason if {\n\tnot is_track_all_events(resource)\n\treason := rule_meta.reason.zh # \"Not tracking all events\"\n}\n\ncheck_violation(trail_name, resource) := reason if {\n\tis_track_all_events(resource)\n\tnot is_trail_enabled(trail_name)\n\treason := \"操作审计跟踪未开启 (缺少启用的 TrailLogging)\"\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:adb-cluster-multi-zone", Name: models.I18nString{"en": "ADB Cluster Multi-Zone Deployment", "zh": "ADB 集群部署模式为多可用区"}, Severity: "medium", Description: models.I18nString{"en": "The ADB cluster should be deployed in multi-zone mode.", "zh": "ADB 集群为多可用区部署模式，视为合规。"}, Reason: models.I18nString{"en": "The ADB cluster is not configured with a secondary zone, indicating it is single-zone.", "zh": "ADB 集群未配置备可用区，表明其为单可用区部署。"}, Recommendation: models.I18nString{"en": "Configure the SecondaryZoneId to enable multi-zone deployment.", "zh": "配置 SecondaryZoneId 以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::ADBLake::DBCluster"}, FilePath: "aliyun/rules/adb-cluster-multi-zone.rego", PackageName: "infraguard.rules.aliyun.adb_cluster_multi_zone", Content: "package infraguard.rules.aliyun.adb_cluster_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"adb-cluster-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ADB Cluster Multi-Zone Deployment\",\n\t\t\"zh\": \"ADB 集群部署模式为多可用区\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"The ADB cluster should be deployed in multi-zone mode.\",\n\t\t\"zh\": \"ADB 集群为多可用区部署模式，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ADB cluster is not configured with a secondary zone, indicating it is single-zone.\",\n\t\t\"zh\": \"ADB 集群未配置备可用区，表明其为单可用区部署。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the SecondaryZoneId to enable multi-zone deployment.\",\n\t\t\"zh\": \"配置 SecondaryZoneId 以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ADBLake::DBCluster\"],\n}\n\n# Check if ADB is multi-zone\nis_multi_zone(resource) if {\n\t# Check if SecondaryZoneId is present\n\tobject.get(resource.Properties, \"SecondaryZoneId\", \"\") != \"\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecondaryZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-acl-public-access-check", Name: models.I18nString{"en": "ALB ACL Does Not Allow Public Access", "zh": "ALB 访问控制列表不允许配置所有地址段"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ALB access control lists do not contain 0.0.0.0/0 (allowing all IPs).", "zh": "确保 ALB 访问控制列表不包含 0.0.0.0/0（允许所有 IP）。"}, Reason: models.I18nString{"en": "Setting the ACL to 0.0.0.0/0 allows any IP to access the load balancer, significantly increasing security risks.", "zh": "将 ACL 设置为 0.0.0.0/0 允许任何 IP 访问负载均衡器，大大增加了安全风险。"}, Recommendation: models.I18nString{"en": "Restrict the ACL to specific IP ranges instead of allowing all IPs.", "zh": "将 ACL 限制为特定的 IP 范围，而不是允许所有 IP。"}, ResourceTypes: []string{"ALIYUN::ALB::Acl"}, FilePath: "aliyun/rules/alb-acl-public-access-check.rego", PackageName: "infraguard.rules.aliyun.alb_acl_public_access_check", Content: "package infraguard.rules.aliyun.alb_acl_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"alb-acl-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"ALB ACL Does Not Allow Public Access\",\n\t\t\"zh\": \"ALB 访问控制列表不允许配置所有地址段\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ALB access control lists do not contain 0.0.0.0/0 (allowing all IPs).\",\n\t\t\"zh\": \"确保 ALB 访问控制列表不包含 0.0.0.0/0（允许所有 IP）。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Setting the ACL to 0.0.0.0/0 allows any IP to access the load balancer, significantly increasing security risks.\",\n\t\t\"zh\": \"将 ACL 设置为 0.0.0.0/0 允许任何 IP 访问负载均衡器，大大增加了安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict the ACL to specific IP ranges instead of allowing all IPs.\",\n\t\t\"zh\": \"将 ACL 限制为特定的 IP 范围，而不是允许所有 IP。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::Acl\"],\n}\n\n# Check if ACL contains 0.0.0.0/0\ncontains_public_cidr(acl_resource) if {\n\tacl_entries := helpers.get_property(acl_resource, \"AclEntries\", [])\n\tsome entry in acl_entries\n\tcidr := entry.Entry\n\tcidr == \"0.0.0.0/0\"\n}\n\ncontains_public_cidr(acl_resource) if {\n\tacl_entries := helpers.get_property(acl_resource, \"AclEntries\", [])\n\tsome entry in acl_entries\n\tcidr := entry.Entry\n\tcidr == \"0.0.0.0\"\n}\n\nis_compliant(resource) if {\n\tnot contains_public_cidr(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::Acl\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AclEntries\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-address-type-check", Name: models.I18nString{"en": "ALB Address Type Check", "zh": "ALB 网络类型核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ALB instances use the preferred address type (e.g., Intranet).", "zh": "确保 ALB 实例使用首选的网络类型（如私网）。"}, Reason: models.I18nString{"en": "Internal-only services should be placed on an Intranet ALB to reduce exposure.", "zh": "仅限内部使用的服务应放置在私网 ALB 上以减少暴露。"}, Recommendation: models.I18nString{"en": "Set AddressType to 'Intranet' for internal services.", "zh": "为内部服务将 AddressType 设置为 'Intranet'。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/alb-address-type-check.rego", PackageName: "infraguard.rules.aliyun.alb_address_type_check", Content: "package infraguard.rules.aliyun.alb_address_type_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"alb-address-type-check\",\n\t\"name\": {\n\t\t\"en\": \"ALB Address Type Check\",\n\t\t\"zh\": \"ALB 网络类型核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ALB instances use the preferred address type (e.g., Intranet).\",\n\t\t\"zh\": \"确保 ALB 实例使用首选的网络类型（如私网）。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Internal-only services should be placed on an Intranet ALB to reduce exposure.\",\n\t\t\"zh\": \"仅限内部使用的服务应放置在私网 ALB 上以减少暴露。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set AddressType to 'Intranet' for internal services.\",\n\t\t\"zh\": \"为内部服务将 AddressType 设置为 'Intranet'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\t# Example: check if it's Intranet\n\thelpers.get_property(resource, \"AddressType\", \"\") == \"Intranet\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AddressType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-all-listener-health-check-enabled", Name: models.I18nString{"en": "ALB All Listeners Health Check Enabled", "zh": "ALB 所有监听开启健康检查"}, Severity: "high", Description: models.I18nString{"en": "Ensures all ALB listeners have health checks enabled.", "zh": "确保所有 ALB 监听均开启了健康检查。"}, Reason: models.I18nString{"en": "Health checks are vital for detecting and bypassing unhealthy backend servers.", "zh": "健康检查对于发现和避开不健康的后端服务器至关重要。"}, Recommendation: models.I18nString{"en": "Enable health checks for all ALB listeners.", "zh": "为所有 ALB 监听开启健康检查。"}, ResourceTypes: []string{"ALIYUN::ALB::Listener"}, FilePath: "aliyun/rules/alb-all-listener-health-check-enabled.rego", PackageName: "infraguard.rules.aliyun.alb_all_listener_health_check_enabled", Content: "package infraguard.rules.aliyun.alb_all_listener_health_check_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"alb-all-listener-health-check-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ALB All Listeners Health Check Enabled\",\n\t\t\"zh\": \"ALB 所有监听开启健康检查\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures all ALB listeners have health checks enabled.\",\n\t\t\"zh\": \"确保所有 ALB 监听均开启了健康检查。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Health checks are vital for detecting and bypassing unhealthy backend servers.\",\n\t\t\"zh\": \"健康检查对于发现和避开不健康的后端服务器至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable health checks for all ALB listeners.\",\n\t\t\"zh\": \"为所有 ALB 监听开启健康检查。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::Listener\"],\n}\n\n# Resolve ServerGroupId from Ref or string\nresolve_server_group_id(val) := id if {\n\tis_object(val)\n\tid := val.Ref\n} else := val if {\n\tis_string(val)\n}\n\n# Check if listener's server groups have health check enabled\nis_compliant(resource) if {\n\tdefault_actions := helpers.get_property(resource, \"DefaultActions\", [])\n\tsome action in default_actions\n\taction.Type == \"ForwardGroup\"\n\tforward_group_config := action.ForwardGroupConfig\n\tsome tuple in forward_group_config.ServerGroupTuples\n\tserver_group_id_val := tuple.ServerGroupId\n\tserver_group_id := resolve_server_group_id(server_group_id_val)\n\n\t# Find the server group resource\n\tsome name, server_group in input.Resources\n\tname == server_group_id\n\tserver_group.Type == \"ALIYUN::ALB::ServerGroup\"\n\n\t# Check health check config\n\thc := helpers.get_property(server_group, \"HealthCheckConfig\", {})\n\thelpers.is_true(object.get(hc, \"HealthCheckEnabled\", true))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HealthCheckConfig\", \"HealthCheckEnabled\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-all-listenter-has-server", Name: models.I18nString{"en": "ALB Listener Has Backend Server", "zh": "ALB 监听绑定后端服务器"}, Severity: "medium", Description: models.I18nString{"en": "Ensures all ALB listeners are associated with a non-empty server group.", "zh": "确保所有 ALB 监听均关联了非空的服务器组。"}, Reason: models.I18nString{"en": "A listener without backend servers cannot handle any traffic, leading to service unavailability.", "zh": "未绑定后端服务器的监听无法处理任何流量，会导致服务不可用。"}, Recommendation: models.I18nString{"en": "Associate the listener with a server group that contains healthy backend servers.", "zh": "将监听关联到包含健康后端服务器的服务器组。"}, ResourceTypes: []string{"ALIYUN::ALB::Listener"}, FilePath: "aliyun/rules/alb-all-listenter-has-server.rego", PackageName: "infraguard.rules.aliyun.alb_all_listenter_has_server", Content: "package infraguard.rules.aliyun.alb_all_listenter_has_server\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"alb-all-listenter-has-server\",\n\t\"name\": {\n\t\t\"en\": \"ALB Listener Has Backend Server\",\n\t\t\"zh\": \"ALB 监听绑定后端服务器\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures all ALB listeners are associated with a non-empty server group.\",\n\t\t\"zh\": \"确保所有 ALB 监听均关联了非空的服务器组。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"A listener without backend servers cannot handle any traffic, leading to service unavailability.\",\n\t\t\"zh\": \"未绑定后端服务器的监听无法处理任何流量，会导致服务不可用。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Associate the listener with a server group that contains healthy backend servers.\",\n\t\t\"zh\": \"将监听关联到包含健康后端服务器的服务器组。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::Listener\"],\n}\n\nis_compliant(resource) if {\n\t# Check if DefaultActions contains ForwardGroup with ServerGroupTuples\n\tdefault_actions := helpers.get_property(resource, \"DefaultActions\", [])\n\tsome action in default_actions\n\taction.Type == \"ForwardGroup\"\n\tforward_group_config := action.ForwardGroupConfig\n\tserver_group_tuples := forward_group_config.ServerGroupTuples\n\tcount(server_group_tuples) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DefaultActions\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-delete-protection-enabled", Name: models.I18nString{"en": "ALB Instance Deletion Protection Enabled", "zh": "ALB 实例开启释放保护"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ALB instances have deletion protection enabled.", "zh": "确保 ALB 实例开启了释放保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the ALB instance may be released accidentally, causing service interruption.", "zh": "如果未开启释放保护，ALB 实例可能会被意外释放，导致业务中断。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the ALB instance.", "zh": "为 ALB 实例开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/alb-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.alb_delete_protection_enabled", Content: "package infraguard.rules.aliyun.alb_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"alb-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ALB Instance Deletion Protection Enabled\",\n\t\t\"zh\": \"ALB 实例开启释放保护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ALB instances have deletion protection enabled.\",\n\t\t\"zh\": \"确保 ALB 实例开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the ALB instance may be released accidentally, causing service interruption.\",\n\t\t\"zh\": \"如果未开启释放保护，ALB 实例可能会被意外释放，导致业务中断。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the ALB instance.\",\n\t\t\"zh\": \"为 ALB 实例开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtectionEnabled\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtectionEnabled\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-instance-bind-security-group-or-enabled-acl", Name: models.I18nString{"en": "ALB Instance Bind Security Group or Enable ACL", "zh": "ALB 实例关联安全组或者为所有监听设置访问控制"}, Severity: "medium", Description: models.I18nString{"en": "ALB instance should have security groups associated or ACL configured for all running listeners.", "zh": "ALB 实例关联了安全组或者为所有运行中的监听都设置了访问控制，视为合规。不存在运行中监听的实例不适用本规则，视为不适用。"}, Reason: models.I18nString{"en": "ALB instance does not have security groups associated, which may expose the load balancer to security risks.", "zh": "ALB 实例未关联安全组，可能导致负载均衡器面临安全风险。"}, Recommendation: models.I18nString{"en": "Associate security groups with the ALB instance by configuring SecurityGroupIds property, or set up ACL for all listeners.", "zh": "通过配置 SecurityGroupIds 属性为 ALB 实例关联安全组，或为所有监听器设置访问控制列表(ACL)。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/alb-instance-bind-security-group-or-enabled-acl.rego", PackageName: "infraguard.rules.aliyun.alb_instance_bind_security_group_or_enabled_acl", Content: "package infraguard.rules.aliyun.alb_instance_bind_security_group_or_enabled_acl\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"alb-instance-bind-security-group-or-enabled-acl\",\n\t\"name\": {\n\t\t\"en\": \"ALB Instance Bind Security Group or Enable ACL\",\n\t\t\"zh\": \"ALB 实例关联安全组或者为所有监听设置访问控制\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ALB instance should have security groups associated or ACL configured for all running listeners.\",\n\t\t\"zh\": \"ALB 实例关联了安全组或者为所有运行中的监听都设置了访问控制，视为合规。不存在运行中监听的实例不适用本规则，视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"ALB instance does not have security groups associated, which may expose the load balancer to security risks.\",\n\t\t\"zh\": \"ALB 实例未关联安全组，可能导致负载均衡器面临安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Associate security groups with the ALB instance by configuring SecurityGroupIds property, or set up ACL for all listeners.\",\n\t\t\"zh\": \"通过配置 SecurityGroupIds 属性为 ALB 实例关联安全组，或为所有监听器设置访问控制列表(ACL)。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\n# Check if security groups are configured\nhas_security_groups(resource) if {\n\tcount(resource.Properties.SecurityGroupIds) > 0\n}\n\n# Generate deny for non-compliant resources\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::LoadBalancer\")\n\tnot has_security_groups(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-instance-multi-zone", Name: models.I18nString{"en": "ALB Instance Multi-Zone Deployment", "zh": "使用多可用区的 ALB 实例"}, Severity: "high", Description: models.I18nString{"en": "ALB instances should be deployed across multiple availability zones for high availability. If only one zone is selected, a zone failure will affect the ALB instance and business stability.", "zh": "ALB 实例为多可用区实例，视为合规。如果只选择了一个可用区，当这个可用区出现故障时，会影响 ALB 实例，进而影响业务稳定性。"}, Reason: models.I18nString{"en": "The ALB instance is deployed in only one availability zone, which creates a single point of failure.", "zh": "ALB 实例仅部署在一个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure the ALB instance to use at least two availability zones by adding multiple zone mappings in the ZoneMappings property.", "zh": "通过在 ZoneMappings 属性中添加多个可用区映射，将 ALB 实例配置为使用至少两个可用区。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/alb-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.alb_instance_multi_zone", Content: "package infraguard.rules.aliyun.alb_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"alb-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ALB Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 ALB 实例\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ALB instances should be deployed across multiple availability zones for high availability. If only one zone is selected, a zone failure will affect the ALB instance and business stability.\",\n\t\t\"zh\": \"ALB 实例为多可用区实例，视为合规。如果只选择了一个可用区，当这个可用区出现故障时，会影响 ALB 实例，进而影响业务稳定性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ALB instance is deployed in only one availability zone, which creates a single point of failure.\",\n\t\t\"zh\": \"ALB 实例仅部署在一个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the ALB instance to use at least two availability zones by adding multiple zone mappings in the ZoneMappings property.\",\n\t\t\"zh\": \"通过在 ZoneMappings 属性中添加多个可用区映射，将 ALB 实例配置为使用至少两个可用区。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\n# Check if ALB is multi-zone\nis_multi_zone(resource) if {\n\tcount(object.get(resource.Properties, \"ZoneMappings\", [])) >= 2\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::LoadBalancer\")\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneMappings\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-instance-waf-enabled", Name: models.I18nString{"en": "ALB Instance Has WAF Protection", "zh": "ALB 实例开启 WEB 应用防火墙防护"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ALB instances have WAF3 (Web Application Firewall) protection enabled.", "zh": "确保 ALB 实例已启用 WAF3（Web 应用防火墙）防护。"}, Reason: models.I18nString{"en": "WAF protection helps protect against common web vulnerabilities and attacks.", "zh": "WAF 防护有助于防范常见的 Web 漏洞和攻击。"}, Recommendation: models.I18nString{"en": "Enable WAF3 protection for the ALB instance.", "zh": "为 ALB 实例启用 WAF3 防护。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/alb-instance-waf-enabled.rego", PackageName: "infraguard.rules.aliyun.alb_instance_waf_enabled", Content: "package infraguard.rules.aliyun.alb_instance_waf_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"alb-instance-waf-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ALB Instance Has WAF Protection\",\n\t\t\"zh\": \"ALB 实例开启 WEB 应用防火墙防护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ALB instances have WAF3 (Web Application Firewall) protection enabled.\",\n\t\t\"zh\": \"确保 ALB 实例已启用 WAF3（Web 应用防火墙）防护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"WAF protection helps protect against common web vulnerabilities and attacks.\",\n\t\t\"zh\": \"WAF 防护有助于防范常见的 Web 漏洞和攻击。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable WAF3 protection for the ALB instance.\",\n\t\t\"zh\": \"为 ALB 实例启用 WAF3 防护。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\n# Check if WAF protection is enabled via LoadBalancerEdition\nis_compliant(resource) if {\n\tedition := helpers.get_property(resource, \"LoadBalancerEdition\", \"\")\n\tedition == \"StandardWithWaf\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"WafEnabled\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-server-group-multi-server", Name: models.I18nString{"en": "ALB Server Group Has Multiple Servers", "zh": "ALB 服务器组包含至少两台服务器"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ALB server groups contain at least two backend servers for high availability.", "zh": "确保 ALB 服务器组包含至少两台后端服务器以实现高可用性。"}, Reason: models.I18nString{"en": "Server groups with only one server create a single point of failure.", "zh": "只有一台服务器的服务器组存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Add at least two backend servers to the server group using ALIYUN::ALB::BackendServerAttachment resources.", "zh": "使用 ALIYUN::ALB::BackendServerAttachment 资源，向服务器组添加至少两台后端服务器。"}, ResourceTypes: []string{"ALIYUN::ALB::ServerGroup"}, FilePath: "aliyun/rules/alb-server-group-multi-server.rego", PackageName: "infraguard.rules.aliyun.alb_server_group_multi_server", Content: "package infraguard.rules.aliyun.alb_server_group_multi_server\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"alb-server-group-multi-server\",\n\t\"name\": {\n\t\t\"en\": \"ALB Server Group Has Multiple Servers\",\n\t\t\"zh\": \"ALB 服务器组包含至少两台服务器\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ALB server groups contain at least two backend servers for high availability.\",\n\t\t\"zh\": \"确保 ALB 服务器组包含至少两台后端服务器以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Server groups with only one server create a single point of failure.\",\n\t\t\"zh\": \"只有一台服务器的服务器组存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add at least two backend servers to the server group using ALIYUN::ALB::BackendServerAttachment resources.\",\n\t\t\"zh\": \"使用 ALIYUN::ALB::BackendServerAttachment 资源，向服务器组添加至少两台后端服务器。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::ServerGroup\"],\n}\n\n# Check if server group type is Instance (not IP or Function Compute)\nis_applicable_type(resource) if {\n\tserver_group_type := helpers.get_property(resource, \"ServerGroupType\", \"Instance\")\n\tserver_group_type == \"Instance\"\n}\n\n# Get server group ID from reference or direct value\nget_server_group_id(value) := value if {\n\tis_string(value)\n}\n\nget_server_group_id(value) := ref_val if {\n\tis_object(value)\n\tref_val := value.Ref\n}\n\n# Check if attachment belongs to this server group\nattachment_belongs_to_group(attachment, server_group_id) if {\n\tgroup_id := get_server_group_id(attachment.Properties.ServerGroupId)\n\tgroup_id == server_group_id\n}\n\n# Count servers attached to a server group\nget_server_count(server_group_id) := server_count if {\n\tattachments := [attachment |\n\t\tsome _, attachment in helpers.resources_by_type(\"ALIYUN::ALB::BackendServerAttachment\")\n\t\tattachment_belongs_to_group(attachment, server_group_id)\n\t]\n\n\tservers := [server |\n\t\tsome attachment in attachments\n\t\tsome server in attachment.Properties.Servers\n\t]\n\n\tserver_count := count(servers)\n}\n\n# Check if server group has at least 2 servers\nhas_min_servers(server_group_id) if {\n\tserver_count := get_server_count(server_group_id)\n\tserver_count >= 2\n}\n\nis_compliant(name, resource) if {\n\tis_applicable_type(resource)\n\thas_min_servers(name)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::ServerGroup\")\n\n\t# Only check Instance type server groups\n\tis_applicable_type(resource)\n\n\tnot is_compliant(name, resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alb-server-group-multi-zone", Name: models.I18nString{"en": "ALB Server Group Multi-Zone Distribution", "zh": "ALB 负载均衡服务器组添加多个可用区资源"}, Severity: "medium", Description: models.I18nString{"en": "ALB server groups should have backend servers distributed across multiple availability zones for high availability. This rule does not apply to server groups with no attached servers, or to IP/Function Compute type server groups.", "zh": "ALB 负载均衡的服务器组挂载资源分布在多个可用区，视为合规。ALB 服务器组无挂载任何资源时不适用本规则，视为不适用。IP 或者函数计算类型的服务器组视为不适用。"}, Reason: models.I18nString{"en": "The ALB server group has backend servers in only one availability zone, creating a single point of failure.", "zh": "ALB 服务器组的后端服务器仅分布在一个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Add backend servers from at least two different availability zones to the server group using ALIYUN::ALB::BackendServerAttachment resources.", "zh": "使用 ALIYUN::ALB::BackendServerAttachment 资源，向服务器组添加来自至少两个不同可用区的后端服务器。"}, ResourceTypes: []string{"ALIYUN::ALB::ServerGroup"}, FilePath: "aliyun/rules/alb-server-group-multi-zone.rego", PackageName: "infraguard.rules.aliyun.alb_server_group_multi_zone", Content: "package infraguard.rules.aliyun.alb_server_group_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"alb-server-group-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ALB Server Group Multi-Zone Distribution\",\n\t\t\"zh\": \"ALB 负载均衡服务器组添加多个可用区资源\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ALB server groups should have backend servers distributed across multiple availability zones for high availability. This rule does not apply to server groups with no attached servers, or to IP/Function Compute type server groups.\",\n\t\t\"zh\": \"ALB 负载均衡的服务器组挂载资源分布在多个可用区，视为合规。ALB 服务器组无挂载任何资源时不适用本规则，视为不适用。IP 或者函数计算类型的服务器组视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ALB server group has backend servers in only one availability zone, creating a single point of failure.\",\n\t\t\"zh\": \"ALB 服务器组的后端服务器仅分布在一个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add backend servers from at least two different availability zones to the server group using ALIYUN::ALB::BackendServerAttachment resources.\",\n\t\t\"zh\": \"使用 ALIYUN::ALB::BackendServerAttachment 资源，向服务器组添加来自至少两个不同可用区的后端服务器。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::ServerGroup\"],\n}\n\n# Check if server group type is applicable (not IP or Fc)\nis_applicable_type(resource) if {\n\tserver_group_type := helpers.get_property(resource, \"ServerGroupType\", \"Instance\")\n\tserver_group_type == \"Instance\"\n}\n\n# Get server group ID from reference or direct value\nget_server_group_id(value) := value if {\n\tis_string(value)\n}\n\nget_server_group_id(value) := value.Ref if {\n\tis_object(value)\n\tvalue.Ref\n}\n\n# Get server ID from reference or direct value\nget_server_id(value) := value if {\n\tis_string(value)\n}\n\nget_server_id(value) := value.Ref if {\n\tis_object(value)\n\tvalue.Ref\n}\n\n# Check if attachment belongs to this server group\nattachment_belongs_to_group(attachment, server_group_id) if {\n\tgroup_id := get_server_group_id(attachment.Properties.ServerGroupId)\n\tgroup_id == server_group_id\n}\n\n# Get all zones from backend servers for a server group\nzones_for_server_group(server_group_id) := zones if {\n\t# Find all attachments for this server group\n\tattachments := [attachment |\n\t\tsome _, attachment in helpers.resources_by_type(\"ALIYUN::ALB::BackendServerAttachment\")\n\t\tattachment_belongs_to_group(attachment, server_group_id)\n\t]\n\n\t# Get all zones from servers in these attachments\n\tzones := {zone |\n\t\tsome attachment in attachments\n\t\tsome server in attachment.Properties.Servers\n\t\tserver_id := get_server_id(server.ServerId)\n\n\t\t# Look up the server resource\n\t\tsome name, resource in input.Resources\n\t\tname == server_id\n\t\tresource.Type in {\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"}\n\t\tzone := resource.Properties.ZoneId\n\t}\n}\n\n# Check if server group has attachments\nhas_attachments(server_group_id) if {\n\tsome _, attachment in helpers.resources_by_type(\"ALIYUN::ALB::BackendServerAttachment\")\n\tattachment_belongs_to_group(attachment, server_group_id)\n}\n\n# Check if servers are distributed across multiple zones\nis_multi_zone_distributed(server_group_id) if {\n\tzones := zones_for_server_group(server_group_id)\n\tcount(zones) >= 2\n}\n\n# Deny rule: ALB server groups must have servers in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ALB::ServerGroup\")\n\n\t# Only check Instance type server groups\n\tis_applicable_type(resource)\n\n\t# Only check if there are attachments\n\thas_attachments(name)\n\n\t# Check if not multi-zone\n\tnot is_multi_zone_distributed(name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alidns-domain-regex-match", Name: models.I18nString{"en": "Alibaba Cloud DNS Domain Names Match Naming Convention", "zh": "阿里云解析域名符合命名规范"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that Alibaba Cloud DNS domain names match the specified naming convention regex.", "zh": "域名符合参数指定的命名规范正则，视为合规。"}, Reason: models.I18nString{"en": "Domain name does not match the specified naming convention regex.", "zh": "域名不符合参数指定的命名规范正则。"}, Recommendation: models.I18nString{"en": "Rename the domain to match the specified naming convention.", "zh": "请修改域名以符合指定的命名规范。"}, ResourceTypes: []string{"ALIYUN::DNS::Domain"}, FilePath: "aliyun/rules/alidns-domain-regex-match.rego", PackageName: "infraguard.rules.aliyun.alidns_domain_regex_match", Content: "package infraguard.rules.aliyun.alidns_domain_regex_match\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"alidns-domain-regex-match\",\n\t\"name\": {\n\t\t\"en\": \"Alibaba Cloud DNS Domain Names Match Naming Convention\",\n\t\t\"zh\": \"阿里云解析域名符合命名规范\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Alibaba Cloud DNS domain names match the specified naming convention regex.\",\n\t\t\"zh\": \"域名符合参数指定的命名规范正则，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Domain name does not match the specified naming convention regex.\",\n\t\t\"zh\": \"域名不符合参数指定的命名规范正则。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Rename the domain to match the specified naming convention.\",\n\t\t\"zh\": \"请修改域名以符合指定的命名规范。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::DNS::Domain\"],\n}\n\n# Default regex pattern for domain names\ndefault_regex_pattern := \"^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$\"\n\n# Get regex pattern from parameters or use default\nget_regex_pattern := input.rule_parameters.domain_name_regex_pattern if {\n\tinput.rule_parameters.domain_name_regex_pattern != \"\"\n} else := default_regex_pattern\n\n# Check if domain name matches the regex pattern\ndomain_name_matches_regex(domain_name, pattern) if {\n\tregex.match(pattern, domain_name)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::DNS::Domain\")\n\n\tdomain_name := resource.Properties.DomainName\n\tpattern := get_regex_pattern\n\n\tnot domain_name_matches_regex(domain_name, pattern)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DomainName\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:alidns-route-53-mx-check", Name: models.I18nString{"en": "DNS MX Record Has Valid SPF in Associated TXT Record", "zh": "DNS 域名 MX 记录关联的 TXT 记录包含有效的 SPF 值"}, Severity: "high", Description: models.I18nString{"en": "Ensures that MX records have associated TXT records with valid SPF values for email validation.", "zh": "对于每个 MX 记录，检查关联的 TXT 记录是否包含有效的 SPF 值,只要 MX 记录有至少一个具有有效 SPF 值的关联 TXT 记录，则视为合规。"}, Reason: models.I18nString{"en": "MX records without valid SPF configuration may be vulnerable to email spoofing.", "zh": "MX 记录未配置有效的 SPF 值，可能导致邮件伪造风险。"}, Recommendation: models.I18nString{"en": "Configure TXT records with valid SPF values for each MX record.", "zh": "为每个 MX 记录配置包含有效 SPF 值的 TXT 记录。"}, ResourceTypes: []string{"ALIYUN::DNS::DomainRecord"}, FilePath: "aliyun/rules/alidns-route-53-mx-check.rego", PackageName: "infraguard.rules.aliyun.alidns_route_53_mx_check", Content: "package infraguard.rules.aliyun.alidns_route_53_mx_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"alidns-route-53-mx-check\",\n\t\"name\": {\n\t\t\"en\": \"DNS MX Record Has Valid SPF in Associated TXT Record\",\n\t\t\"zh\": \"DNS 域名 MX 记录关联的 TXT 记录包含有效的 SPF 值\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MX records have associated TXT records with valid SPF values for email validation.\",\n\t\t\"zh\": \"对于每个 MX 记录，检查关联的 TXT 记录是否包含有效的 SPF 值,只要 MX 记录有至少一个具有有效 SPF 值的关联 TXT 记录，则视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"MX records without valid SPF configuration may be vulnerable to email spoofing.\",\n\t\t\"zh\": \"MX 记录未配置有效的 SPF 值，可能导致邮件伪造风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure TXT records with valid SPF values for each MX record.\",\n\t\t\"zh\": \"为每个 MX 记录配置包含有效 SPF 值的 TXT 记录。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::DNS::DomainRecord\"],\n}\n\n# Check if a TXT record contains a valid SPF record\nhas_valid_spf(txt_record) if {\n\tvalue := txt_record.Value\n\tstartswith(value, \"v=spf1\")\n}\n\n# Check if an MX record has an associated TXT record with valid SPF\n# Valid SPF means TXT record starts with \"v=spf1\" and contains meaningful mechanisms\nmx_has_valid_spf(mx_props, txt_records) if {\n\tmx_host := mx_props.Value\n\n\tsome txt_record in txt_records\n\ttxt_value := txt_record.Properties.Value\n\thas_valid_spf({\"Value\": txt_value})\n\n\t# TXT record should contain the mx host or include mechanism\n\tcontains(txt_value, mx_host)\n}\n\nmx_has_valid_spf(mx_props, txt_records) if {\n\tsome txt_record in txt_records\n\ttxt_value := txt_record.Properties.Value\n\thas_valid_spf({\"Value\": txt_value})\n\n\t# TXT record should contain the include mechanism\n\tcontains(txt_value, \"include:\")\n}\n\n# Get all MX records for a domain\nget_mx_records(domain_name) := [record |\n\tsome name, record in helpers.resources_by_type(\"ALIYUN::DNS::DomainRecord\")\n\trecord.Properties.Type == \"MX\"\n\trecord.Properties.DomainName == domain_name\n]\n\n# Get all TXT records for a domain\nget_txt_records(domain_name) := [record |\n\tsome name, record in helpers.resources_by_type(\"ALIYUN::DNS::DomainRecord\")\n\trecord.Properties.Type == \"TXT\"\n\trecord.Properties.DomainName == domain_name\n]\n\ndeny contains result if {\n\tsome name, domain_resource in helpers.resources_by_type(\"ALIYUN::DNS::Domain\")\n\tdomain_name := domain_resource.Properties.DomainName\n\n\tmx_records := get_mx_records(domain_name)\n\ttxt_records := get_txt_records(domain_name)\n\n\t# Find MX records that don't have valid SPF TXT records\n\tsome mx_record in mx_records\n\tmx_record.Properties.Type == \"MX\"\n\tnot mx_has_valid_spf(mx_record.Properties, txt_records)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": domain_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-api-auth-jwt", Name: models.I18nString{"en": "API Gateway API Auth JWT", "zh": "API 网关中 API 安全认证设置为 JWT 方式"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway APIs use JWT authentication.", "zh": "确保 API 网关中的 API 安全认证为 JWT 方式。"}, Reason: models.I18nString{"en": "JWT provides secure authentication for API access.", "zh": "JWT 为 API 访问提供安全的认证机制。"}, Recommendation: models.I18nString{"en": "Configure JWT authentication for APIs.", "zh": "为 API 配置 JWT 认证。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Api"}, FilePath: "aliyun/rules/api-gateway-api-auth-jwt.rego", PackageName: "infraguard.rules.aliyun.api_gateway_api_auth_jwt", Content: "package infraguard.rules.aliyun.api_gateway_api_auth_jwt\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-api-auth-jwt\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway API Auth JWT\",\n\t\t\"zh\": \"API 网关中 API 安全认证设置为 JWT 方式\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway APIs use JWT authentication.\",\n\t\t\"zh\": \"确保 API 网关中的 API 安全认证为 JWT 方式。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"JWT provides secure authentication for API access.\",\n\t\t\"zh\": \"JWT 为 API 访问提供安全的认证机制。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure JWT authentication for APIs.\",\n\t\t\"zh\": \"为 API 配置 JWT 认证。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Api\"],\n}\n\ndeny contains result if {\n\tsome api_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Api\")\n\tauth_type := helpers.get_property(resource, \"AuthType\", \"\")\n\n\tnot auth_type == \"APPOPENID\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": api_name,\n\t\t\"violation_path\": [\"Properties\", \"AuthType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome api_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Api\")\n\tauth_type := helpers.get_property(resource, \"AuthType\", \"\")\n\n\tauth_type == \"APPOPENID\"\n\n\topen_id_config := helpers.get_property(resource, \"OpenIdConnectConfig\", {})\n\topen_id_api_type := object.get(open_id_config, \"OpenIdApiType\", \"\")\n\n\tnot open_id_api_type == \"IDTOKEN\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": api_name,\n\t\t\"violation_path\": [\"Properties\", \"OpenIdConnectConfig\", \"OpenIdApiType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-api-auth-required", Name: models.I18nString{"en": "API Gateway API Auth Required", "zh": "API 网关中配置 API 安全认证"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway APIs have authentication configured.", "zh": "确保 API 网关中配置 API 安全认证为阿里云 APP 或使用指定的插件类型。"}, Reason: models.I18nString{"en": "Authentication prevents unauthorized access to APIs.", "zh": "认证可防止未授权访问 API。"}, Recommendation: models.I18nString{"en": "Enable authentication for all APIs.", "zh": "为所有 API 启用认证。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Api"}, FilePath: "aliyun/rules/api-gateway-api-auth-required.rego", PackageName: "infraguard.rules.aliyun.api_gateway_api_auth_required", Content: "package infraguard.rules.aliyun.api_gateway_api_auth_required\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-api-auth-required\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway API Auth Required\",\n\t\t\"zh\": \"API 网关中配置 API 安全认证\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway APIs have authentication configured.\",\n\t\t\"zh\": \"确保 API 网关中配置 API 安全认证为阿里云 APP 或使用指定的插件类型。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Authentication prevents unauthorized access to APIs.\",\n\t\t\"zh\": \"认证可防止未授权访问 API。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable authentication for all APIs.\",\n\t\t\"zh\": \"为所有 API 启用认证。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Api\"],\n}\n\ndeny contains result if {\n\tsome api_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Api\")\n\tauth_type := helpers.get_property(resource, \"AuthType\", \"\")\n\n\tauth_type == \"ANONYMOUS\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": api_name,\n\t\t\"violation_path\": [\"Properties\", \"AuthType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-api-internet-request-https", Name: models.I18nString{"en": "API Gateway Internet Request HTTPS Enabled", "zh": "API 网关公网请求开启 HTTPS"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that API Gateway APIs exposed to the internet use HTTPS protocol.", "zh": "确保暴露给公网的 API 网关 API 使用 HTTPS 协议。"}, Reason: models.I18nString{"en": "HTTPS ensures data confidentiality and integrity during transmission over the internet.", "zh": "HTTPS 可确保在公网传输期间数据的机密性和完整性。"}, Recommendation: models.I18nString{"en": "Configure the API Gateway API to require HTTPS for internet requests.", "zh": "配置 API 网关 API，要求公网请求使用 HTTPS。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Api"}, FilePath: "aliyun/rules/api-gateway-api-internet-request-https.rego", PackageName: "infraguard.rules.aliyun.api_gateway_api_internet_request_https", Content: "package infraguard.rules.aliyun.api_gateway_api_internet_request_https\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"api-gateway-api-internet-request-https\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Internet Request HTTPS Enabled\",\n\t\t\"zh\": \"API 网关公网请求开启 HTTPS\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that API Gateway APIs exposed to the internet use HTTPS protocol.\",\n\t\t\"zh\": \"确保暴露给公网的 API 网关 API 使用 HTTPS 协议。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"HTTPS ensures data confidentiality and integrity during transmission over the internet.\",\n\t\t\"zh\": \"HTTPS 可确保在公网传输期间数据的机密性和完整性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the API Gateway API to require HTTPS for internet requests.\",\n\t\t\"zh\": \"配置 API 网关 API，要求公网请求使用 HTTPS。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Api\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Api\")\n\n\t# Conceptual check for protocol\n\tproto := helpers.get_property(resource, \"RequestConfig\", {\"RequestProtocol\": \"HTTP\"}).RequestProtocol\n\tproto == \"HTTP\"\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RequestConfig\", \"RequestProtocol\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-api-visibility-private", Name: models.I18nString{"en": "API Gateway API Visibility Private", "zh": "API 网关中的 API 设置为私有"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway APIs are set to PRIVATE visibility.", "zh": "确保 API 网关中的 API 设置为私有。"}, Reason: models.I18nString{"en": "Private APIs are only accessible within the VPC, reducing exposure.", "zh": "私有 API 只能在 VPC 内访问，减少暴露面。"}, Recommendation: models.I18nString{"en": "Set API visibility to PRIVATE for internal APIs.", "zh": "将内部 API 的可见性设置为私有。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Api"}, FilePath: "aliyun/rules/api-gateway-api-visibility-private.rego", PackageName: "infraguard.rules.aliyun.api_gateway_api_visibility_private", Content: "package infraguard.rules.aliyun.api_gateway_api_visibility_private\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-api-visibility-private\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway API Visibility Private\",\n\t\t\"zh\": \"API 网关中的 API 设置为私有\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway APIs are set to PRIVATE visibility.\",\n\t\t\"zh\": \"确保 API 网关中的 API 设置为私有。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Private APIs are only accessible within the VPC, reducing exposure.\",\n\t\t\"zh\": \"私有 API 只能在 VPC 内访问，减少暴露面。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set API visibility to PRIVATE for internal APIs.\",\n\t\t\"zh\": \"将内部 API 的可见性设置为私有。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Api\"],\n}\n\ndeny contains result if {\n\tsome api_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Api\")\n\tvisibility := helpers.get_property(resource, \"Visibility\", \"\")\n\n\tvisibility == \"PUBLIC\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": api_name,\n\t\t\"violation_path\": [\"Properties\", \"Visibility\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-group-bind-domain", Name: models.I18nString{"en": "API Gateway Group Bind Domain", "zh": "API 网关中 API 分组绑定自定义域名"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway groups have custom domains bound.", "zh": "确保 API 网关中的 API 分组绑定了自定义域名。"}, Reason: models.I18nString{"en": "Custom domains provide better branding and control.", "zh": "自定义域名提供更好的品牌控制和可管理性。"}, Recommendation: models.I18nString{"en": "Bind custom domains to API Gateway groups.", "zh": "为 API 网关分组绑定自定义域名。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/api-gateway-group-bind-domain.rego", PackageName: "infraguard.rules.aliyun.api_gateway_group_bind_domain", Content: "package infraguard.rules.aliyun.api_gateway_group_bind_domain\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-group-bind-domain\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group Bind Domain\",\n\t\t\"zh\": \"API 网关中 API 分组绑定自定义域名\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway groups have custom domains bound.\",\n\t\t\"zh\": \"确保 API 网关中的 API 分组绑定了自定义域名。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Custom domains provide better branding and control.\",\n\t\t\"zh\": \"自定义域名提供更好的品牌控制和可管理性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Bind custom domains to API Gateway groups.\",\n\t\t\"zh\": \"为 API 网关分组绑定自定义域名。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\ndeny contains result if {\n\tsome group_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tnot has_custom_domain_bound(group_name, resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nhas_custom_domain_bound(group_name, group_resource) if {\n\tsome domain_name, domain_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::CustomDomain\")\n\tbound_group_id := helpers.get_property(domain_resource, \"GroupId\", \"\")\n\tgroup_id := helpers.get_property(group_resource, \"GroupId\", \"\")\n\n\t# Handle direct string match\n\tbound_group_id == group_id\n}\n\nhas_custom_domain_bound(group_name, group_resource) if {\n\tsome domain_name, domain_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::CustomDomain\")\n\tbound_group_id := helpers.get_property(domain_resource, \"GroupId\", \"\")\n\n\t# Handle Fn::GetAtt reference - check if it references the group\n\thelpers.is_get_att_referencing(bound_group_id, group_name)\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-group-enabled-ssl", Name: models.I18nString{"en": "API Gateway Group SSL Enabled", "zh": "API 网关分组开启 SSL"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that SSL is enabled for API Gateway groups.", "zh": "确保 API 网关分组开启了 SSL。"}, Reason: models.I18nString{"en": "SSL encrypts traffic between clients and the API Gateway, ensuring data confidentiality.", "zh": "SSL 对客户端和 API 网关之间的流量进行加密，确保数据机密性。"}, Recommendation: models.I18nString{"en": "Configure an SSL certificate for the API Gateway group.", "zh": "为 API 网关分组配置 SSL 证书。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/api-gateway-group-enabled-ssl.rego", PackageName: "infraguard.rules.aliyun.api_gateway_group_enabled_ssl", Content: "package infraguard.rules.aliyun.api_gateway_group_enabled_ssl\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"api-gateway-group-enabled-ssl\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group SSL Enabled\",\n\t\t\"zh\": \"API 网关分组开启 SSL\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that SSL is enabled for API Gateway groups.\",\n\t\t\"zh\": \"确保 API 网关分组开启了 SSL。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL encrypts traffic between clients and the API Gateway, ensuring data confidentiality.\",\n\t\t\"zh\": \"SSL 对客户端和 API 网关之间的流量进行加密，确保数据机密性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure an SSL certificate for the API Gateway group.\",\n\t\t\"zh\": \"为 API 网关分组配置 SSL 证书。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\t# Conceptual check\n\tnot helpers.has_property(resource, \"CustomDomains\") # Simplified\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-group-force-https", Name: models.I18nString{"en": "API Gateway Group Force HTTPS", "zh": "API 分组绑定独立域名并开启 Https 强制跳转"}, Severity: "high", Description: models.I18nString{"en": "Ensures API Gateway groups with public custom domains have HTTPS force redirect enabled.", "zh": "检测网关分组下的所有公网独立域名是否都开启 HTTPS 强制跳转。"}, Reason: models.I18nString{"en": "HTTPS force redirect ensures all traffic is encrypted.", "zh": "HTTPS 强制跳转确保所有流量都经过加密。"}, Recommendation: models.I18nString{"en": "Enable HTTPS force redirect for all public domains.", "zh": "为所有公网域名启用 HTTPS 强制跳转。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/api-gateway-group-force-https.rego", PackageName: "infraguard.rules.aliyun.api_gateway_group_force_https", Content: "package infraguard.rules.aliyun.api_gateway_group_force_https\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-group-force-https\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group Force HTTPS\",\n\t\t\"zh\": \"API 分组绑定独立域名并开启 Https 强制跳转\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway groups with public custom domains have HTTPS force redirect enabled.\",\n\t\t\"zh\": \"检测网关分组下的所有公网独立域名是否都开启 HTTPS 强制跳转。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"HTTPS force redirect ensures all traffic is encrypted.\",\n\t\t\"zh\": \"HTTPS 强制跳转确保所有流量都经过加密。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable HTTPS force redirect for all public domains.\",\n\t\t\"zh\": \"为所有公网域名启用 HTTPS 强制跳转。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\ndeny contains result if {\n\tsome group_name, group_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tsome domain_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::CustomDomain\")\n\tbound_group_id := helpers.get_property(domain_resource, \"GroupId\", \"\")\n\n\t# Check if domain is bound to this group (direct match via Ref)\n\thelpers.is_referencing(bound_group_id, group_name)\n\n\tdomain_name := helpers.get_property(domain_resource, \"DomainName\", \"\")\n\tis_public_domain(domain_name)\n\n\tcert_body := helpers.get_property(domain_resource, \"CertificateBody\", \"\")\n\tcert_key := helpers.get_property(domain_resource, \"CertificatePrivateKey\", \"\")\n\tcert_body == \"\"\n\tcert_key == \"\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\", \"CustomDomains\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome group_name, group_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tsome domain_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::CustomDomain\")\n\tbound_group_id := helpers.get_property(domain_resource, \"GroupId\", \"\")\n\n\t# Check if domain is bound to this group (Fn::GetAtt reference)\n\thelpers.is_get_att_referencing(bound_group_id, group_name)\n\n\tdomain_name := helpers.get_property(domain_resource, \"DomainName\", \"\")\n\tis_public_domain(domain_name)\n\n\tcert_body := helpers.get_property(domain_resource, \"CertificateBody\", \"\")\n\tcert_key := helpers.get_property(domain_resource, \"CertificatePrivateKey\", \"\")\n\tcert_body == \"\"\n\tcert_key == \"\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\", \"CustomDomains\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nis_public_domain(domain) if {\n\tnot contains(domain, \".internal.\")\n\tnot contains(domain, \".local\")\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-group-https-policy-check", Name: models.I18nString{"en": "API Gateway Group HTTPS Policy Check", "zh": "API 网关中 API 分组的 HTTPS 安全策略满足要求"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway groups have HTTPS security policy set correctly.", "zh": "确保 API 网关中的 API 分组设置的 HTTPS 安全策略在指定的参数列表中。"}, Reason: models.I18nString{"en": "Strong HTTPS policies ensure secure connections.", "zh": "强 HTTPS 策略确保连接安全。"}, Recommendation: models.I18nString{"en": "Use TLS 1.2 or higher for HTTPS connections.", "zh": "使用 TLS 1.2 或更高版本进行 HTTPS 连接。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/api-gateway-group-https-policy-check.rego", PackageName: "infraguard.rules.aliyun.api_gateway_group_https_policy_check", Content: "package infraguard.rules.aliyun.api_gateway_group_https_policy_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-group-https-policy-check\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group HTTPS Policy Check\",\n\t\t\"zh\": \"API 网关中 API 分组的 HTTPS 安全策略满足要求\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway groups have HTTPS security policy set correctly.\",\n\t\t\"zh\": \"确保 API 网关中的 API 分组设置的 HTTPS 安全策略在指定的参数列表中。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Strong HTTPS policies ensure secure connections.\",\n\t\t\"zh\": \"强 HTTPS 策略确保连接安全。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use TLS 1.2 or higher for HTTPS connections.\",\n\t\t\"zh\": \"使用 TLS 1.2 或更高版本进行 HTTPS 连接。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\nallowed_https_policies := [\n\t\"HTTPS2_TLS1_2\",\n\t\"HTTPS2_TLS1_3\",\n]\n\ndeny contains result if {\n\tsome group_name, group_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tinstance_id := helpers.get_property(group_resource, \"InstanceId\", \"\")\n\n\t# Check all instances and find the one referenced by this group\n\tsome instance_name, instance_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Instance\")\n\n\t# Match by direct string ID\n\tinstance_id == instance_name\n\thttps_policy := helpers.get_property(instance_resource, \"HttpsPolicy\", \"\")\n\tnot https_policy in allowed_https_policies\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\", \"InstanceId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome group_name, group_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tinstance_id := helpers.get_property(group_resource, \"InstanceId\", \"\")\n\n\t# Check all instances and find the one referenced by this group via Fn::GetAtt\n\tsome instance_name, instance_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Instance\")\n\n\t# Match by Fn::GetAtt reference\n\thelpers.is_get_att_referencing(instance_id, instance_name)\n\n\thttps_policy := helpers.get_property(instance_resource, \"HttpsPolicy\", \"\")\n\tnot https_policy in allowed_https_policies\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\", \"InstanceId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:api-gateway-group-log-enabled", Name: models.I18nString{"en": "API Gateway Group Log Enabled", "zh": "为 API 分组设置调用日志存储"}, Severity: "medium", Description: models.I18nString{"en": "Ensures API Gateway groups have logging configured.", "zh": "确保 API 网关中 API 分组设置了调用日志存储。"}, Reason: models.I18nString{"en": "Logging enables monitoring and troubleshooting of API usage.", "zh": "日志记录可实现 API 使用的监控和故障排除。"}, Recommendation: models.I18nString{"en": "Enable logging for API Gateway groups.", "zh": "为 API 网关分组启用日志记录。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/api-gateway-group-log-enabled.rego", PackageName: "infraguard.rules.aliyun.api_gateway_group_log_enabled", Content: "package infraguard.rules.aliyun.api_gateway_group_log_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"api-gateway-group-log-enabled\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group Log Enabled\",\n\t\t\"zh\": \"为 API 分组设置调用日志存储\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway groups have logging configured.\",\n\t\t\"zh\": \"确保 API 网关中 API 分组设置了调用日志存储。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Logging enables monitoring and troubleshooting of API usage.\",\n\t\t\"zh\": \"日志记录可实现 API 使用的监控和故障排除。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable logging for API Gateway groups.\",\n\t\t\"zh\": \"为 API 网关分组启用日志记录。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\ndeny contains result if {\n\tsome group_name, group_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tnot has_log_config(group_name, group_resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nhas_log_config(group_name, group_resource) if {\n\tsome log_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::LogConfig\")\n\tbound_group_id := helpers.get_property(log_resource, \"GroupId\", \"\")\n\n\t# Handle direct string match\n\tbound_group_id == group_name\n\n\tlog_store := helpers.get_property(log_resource, \"LogStore\", \"\")\n\tlog_store != \"\"\n}\n\nhas_log_config(group_name, group_resource) if {\n\tsome log_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::LogConfig\")\n\tbound_group_id := helpers.get_property(log_resource, \"GroupId\", \"\")\n\n\t# Handle Fn::GetAtt reference\n\thelpers.is_get_att_referencing(bound_group_id, group_name)\n\n\tlog_store := helpers.get_property(log_resource, \"LogStore\", \"\")\n\tlog_store != \"\"\n}\n\nhas_log_config(group_name, group_resource) if {\n\tsome log_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::LogConfig\")\n\tbound_group_id := helpers.get_property(log_resource, \"GroupId\", \"\")\n\n\t# Handle direct string match\n\tbound_group_id == group_name\n\n\tsls_log_store := helpers.get_property(log_resource, \"SlsLogStore\", \"\")\n\tsls_log_store != \"\"\n}\n\nhas_log_config(group_name, group_resource) if {\n\tsome log_resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::LogConfig\")\n\tbound_group_id := helpers.get_property(log_resource, \"GroupId\", \"\")\n\n\t# Handle Fn::GetAtt reference\n\thelpers.is_get_att_referencing(bound_group_id, group_name)\n\n\tsls_log_store := helpers.get_property(log_resource, \"SlsLogStore\", \"\")\n\tsls_log_store != \"\"\n}\n\nhas_log_config(group_name, group_resource) if {\n\ttags := helpers.get_property(group_resource, \"Tags\", [])\n\tsome tag in tags\n\ttag.Key == \"LogEnabled\"\n\ttag.Value == \"true\"\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:apig-group-custom-trace-enabled", Name: models.I18nString{"en": "API Gateway Group Custom Trace Enabled", "zh": "API 分组自定义追踪启用"}, Severity: "low", Description: models.I18nString{"en": "Ensures API Gateway groups have custom tracing enabled.", "zh": "确保 API 网关分组启用了自定义追踪功能。"}, Reason: models.I18nString{"en": "Custom tracing enables better debugging and performance analysis.", "zh": "自定义追踪可实现更好的调试和性能分析。"}, Recommendation: models.I18nString{"en": "Enable custom tracing for API Gateway groups.", "zh": "为 API 网关分组启用自定义追踪。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Group"}, FilePath: "aliyun/rules/apig-group-custom-trace-enabled.rego", PackageName: "infraguard.rules.aliyun.apig_group_custom_trace_enabled", Content: "package infraguard.rules.aliyun.apig_group_custom_trace_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"apig-group-custom-trace-enabled\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Group Custom Trace Enabled\",\n\t\t\"zh\": \"API 分组自定义追踪启用\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures API Gateway groups have custom tracing enabled.\",\n\t\t\"zh\": \"确保 API 网关分组启用了自定义追踪功能。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Custom tracing enables better debugging and performance analysis.\",\n\t\t\"zh\": \"自定义追踪可实现更好的调试和性能分析。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable custom tracing for API Gateway groups.\",\n\t\t\"zh\": \"为 API 网关分组启用自定义追踪。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Group\"],\n}\n\ndeny contains result if {\n\tsome group_name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Group\")\n\n\tnot has_tracing_enabled(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nhas_tracing_enabled(resource) if {\n\ttags := helpers.get_property(resource, \"Tags\", [])\n\tsome tag in tags\n\ttag.Key == \"TracingEnabled\"\n\ttag.Value == \"true\"\n}\n\nhas_tracing_enabled(resource) if {\n\tsome name, config in helpers.resources_by_type(\"ALIYUN::ApiGateway::Tracing\")\n\tgroup_id := helpers.get_property(config, \"GroupId\", \"\")\n\tresource_group_id := helpers.get_property(resource, \"GroupId\", \"\")\n\tgroup_id == resource_group_id\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:apigateway-instance-multi-zone", Name: models.I18nString{"en": "API Gateway Instance Multi-Zone Deployment", "zh": "使用多可用区的 API 网关实例"}, Severity: "medium", Description: models.I18nString{"en": "API Gateway instances should be deployed in multi-zone configuration for high availability.", "zh": "使用多可用区的 API 网关实例，视为合规。"}, Reason: models.I18nString{"en": "The API Gateway instance is deployed in a single availability zone, creating a single point of failure.", "zh": "API 网关实例部署在单个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Deploy the API Gateway instance in a multi-zone configuration by specifying a ZoneId with MAZ (Multi-AZ) format, such as 'cn-beijing-MAZ2(f,g)'.", "zh": "通过指定 MAZ（多可用区）格式的 ZoneId（如'cn-beijing-MAZ2(f,g)'），将 API 网关实例部署在多可用区配置中。"}, ResourceTypes: []string{"ALIYUN::ApiGateway::Instance"}, FilePath: "aliyun/rules/apigateway-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.apigateway_instance_multi_zone", Content: "package infraguard.rules.aliyun.apigateway_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"apigateway-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"API Gateway Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 API 网关实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"API Gateway instances should be deployed in multi-zone configuration for high availability.\",\n\t\t\"zh\": \"使用多可用区的 API 网关实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The API Gateway instance is deployed in a single availability zone, creating a single point of failure.\",\n\t\t\"zh\": \"API 网关实例部署在单个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy the API Gateway instance in a multi-zone configuration by specifying a ZoneId with MAZ (Multi-AZ) format, such as 'cn-beijing-MAZ2(f,g)'.\",\n\t\t\"zh\": \"通过指定 MAZ（多可用区）格式的 ZoneId（如'cn-beijing-MAZ2(f,g)'），将 API 网关实例部署在多可用区配置中。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ApiGateway::Instance\"],\n}\n\n# Check if zone ID indicates multi-zone deployment\n# Multi-zone format: cn-region-MAZ#(zone1,zone2,...)\nis_multi_zone(zone_id) if {\n\tcontains(zone_id, \"MAZ\")\n\tcontains(zone_id, \"(\")\n\tcontains(zone_id, \")\")\n}\n\n# Check if instance is multi-zone\nhas_multi_zone_deployment(resource) if {\n\tzone_id := resource.Properties.ZoneId\n\tis_multi_zone(zone_id)\n}\n\n# Deny rule: API Gateway instances must be multi-zone\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ApiGateway::Instance\")\n\tnot has_multi_zone_deployment(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:bastionhost-instance-expired-check", Name: models.I18nString{"en": "BastionHost Instance Expiration Check", "zh": "堡垒机实例到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid BastionHost instances should have auto-renewal enabled.", "zh": "预付费堡垒机实例应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid BastionHost instance does not have auto-renewal enabled.", "zh": "预付费堡垒机实例未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid BastionHost instance by setting AutoRenew to true.", "zh": "通过将 AutoRenew 设置为 true 为预付费堡垒机实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::BastionHost::Instance"}, FilePath: "aliyun/rules/bastionhost-instance-expired-check.rego", PackageName: "infraguard.rules.aliyun.bastionhost_instance_expired_check", Content: "package infraguard.rules.aliyun.bastionhost_instance_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"bastionhost-instance-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"BastionHost Instance Expiration Check\",\n\t\t\"zh\": \"堡垒机实例到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid BastionHost instances should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费堡垒机实例应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid BastionHost instance does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费堡垒机实例未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid BastionHost instance by setting AutoRenew to true.\",\n\t\t\"zh\": \"通过将 AutoRenew 设置为 true 为预付费堡垒机实例开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::BastionHost::Instance\"],\n}\n\nis_prepaid(resource) if {\n\t# Check if Period is set, as it implies subscription\n\thelpers.has_property(resource, \"Period\")\n}\n\nis_auto_renew_enabled(resource) if {\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", false)\n\thelpers.is_true(auto_renew)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:bastionhost-instance-spec-check", Name: models.I18nString{"en": "BastionHost Instance Multi-Zone Spec Check", "zh": "使用多可用区部署的堡垒机版本"}, Severity: "medium", Description: models.I18nString{"en": "The BastionHost instance should use the Enterprise version which supports multi-zone deployment.", "zh": "使用多可用区部署的企业双擎或者国密版堡垒机，保障稳定性，视为合规。"}, Reason: models.I18nString{"en": "The BastionHost instance is using the Basic version which implies single-zone deployment.", "zh": "堡垒机实例使用的是不支持多可用区部署的基础版。"}, Recommendation: models.I18nString{"en": "Upgrade the BastionHost instance to the Enterprise version.", "zh": "将堡垒机实例升级到企业版。"}, ResourceTypes: []string{"ALIYUN::BastionHost::Instance"}, FilePath: "aliyun/rules/bastionhost-instance-spec-check.rego", PackageName: "infraguard.rules.aliyun.bastionhost_instance_spec_check", Content: "package infraguard.rules.aliyun.bastionhost_instance_spec_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"bastionhost-instance-spec-check\",\n\t\"name\": {\n\t\t\"en\": \"BastionHost Instance Multi-Zone Spec Check\",\n\t\t\"zh\": \"使用多可用区部署的堡垒机版本\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"The BastionHost instance should use the Enterprise version which supports multi-zone deployment.\",\n\t\t\"zh\": \"使用多可用区部署的企业双擎或者国密版堡垒机，保障稳定性，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The BastionHost instance is using the Basic version which implies single-zone deployment.\",\n\t\t\"zh\": \"堡垒机实例使用的是不支持多可用区部署的基础版。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the BastionHost instance to the Enterprise version.\",\n\t\t\"zh\": \"将堡垒机实例升级到企业版。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::BastionHost::Instance\"],\n}\n\n# Check if instance is Enterprise version\nis_enterprise(resource) if {\n\tresource.Properties.Version == \"Enterprise\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_enterprise(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Version\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cdn-domain-multiple-origin-servers", Name: models.I18nString{"en": "CDN Domain Multiple Origin Servers", "zh": "CDN 域名配置多个源站"}, Severity: "high", Description: models.I18nString{"en": "CDN domains should be configured with multiple origin servers for high availability and fault tolerance.", "zh": "CDN 域名配置多个源站，视为合规。"}, Reason: models.I18nString{"en": "The CDN domain is configured with only one origin server, creating a single point of failure.", "zh": "CDN 域名仅配置了一个源站，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure at least two origin servers in the OriginServers property to ensure high availability.", "zh": "在 OriginServers 属性中配置至少两个源站，以确保高可用性。"}, ResourceTypes: []string{"ALIYUN::CDN::Domain"}, FilePath: "aliyun/rules/cdn-domain-multiple-origin-servers.rego", PackageName: "infraguard.rules.aliyun.cdn_domain_multiple_origin_servers", Content: "package infraguard.rules.aliyun.cdn_domain_multiple_origin_servers\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"cdn-domain-multiple-origin-servers\",\n\t\"name\": {\n\t\t\"en\": \"CDN Domain Multiple Origin Servers\",\n\t\t\"zh\": \"CDN 域名配置多个源站\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"CDN domains should be configured with multiple origin servers for high availability and fault tolerance.\",\n\t\t\"zh\": \"CDN 域名配置多个源站，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The CDN domain is configured with only one origin server, creating a single point of failure.\",\n\t\t\"zh\": \"CDN 域名仅配置了一个源站，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two origin servers in the OriginServers property to ensure high availability.\",\n\t\t\"zh\": \"在 OriginServers 属性中配置至少两个源站，以确保高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CDN::Domain\"],\n}\n\n# Check if domain has multiple origin servers\nhas_multiple_origin_servers(resource) if {\n\torigin_servers := resource.Properties.OriginServers\n\tcount(origin_servers) >= 2\n}\n\n# Deny rule: CDN domains must have multiple origin servers\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CDN::Domain\")\n\tnot has_multiple_origin_servers(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"OriginServers\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cen-cross-region-bandwidth-check", Name: models.I18nString{"en": "CEN Cross-Region Bandwidth Check", "zh": "CEN 实例中的跨地域连接带宽分配满足指定要求"}, Severity: "medium", Description: models.I18nString{"en": "CEN instance cross-region connections should have sufficient bandwidth allocation to meet performance requirements.", "zh": "云企业网实例下所有跨地域连接分配的带宽大于参数指定值，视为合规。"}, Reason: models.I18nString{"en": "Insufficient cross-region bandwidth can lead to performance bottlenecks and degraded application performance.", "zh": "不足的跨地域带宽可能导致性能瓶颈和应用程序性能下降。"}, Recommendation: models.I18nString{"en": "Ensure cross-region connections have bandwidth allocation above the specified minimum threshold (default: 1Mbps).", "zh": "确保跨地域连接的带宽分配高于指定的最小阈值（默认：1Mbps）。"}, ResourceTypes: []string{"ALIYUN::CEN::CenInstance"}, FilePath: "aliyun/rules/cen-cross-region-bandwidth-check.rego", PackageName: "infraguard.rules.aliyun.cen_cross_region_bandwidth_check", Content: "package infraguard.rules.aliyun.cen_cross_region_bandwidth_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"cen-cross-region-bandwidth-check\",\n\t\"name\": {\n\t\t\"en\": \"CEN Cross-Region Bandwidth Check\",\n\t\t\"zh\": \"CEN 实例中的跨地域连接带宽分配满足指定要求\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"CEN instance cross-region connections should have sufficient bandwidth allocation to meet performance requirements.\",\n\t\t\"zh\": \"云企业网实例下所有跨地域连接分配的带宽大于参数指定值，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Insufficient cross-region bandwidth can lead to performance bottlenecks and degraded application performance.\",\n\t\t\"zh\": \"不足的跨地域带宽可能导致性能瓶颈和应用程序性能下降。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure cross-region connections have bandwidth allocation above the specified minimum threshold (default: 1Mbps).\",\n\t\t\"zh\": \"确保跨地域连接的带宽分配高于指定的最小阈值（默认：1Mbps）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CEN::CenInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CEN::CenInstance\")\n\n\t# Cross-resource check would examine CenBandwidthPackage associations\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:clickhouse-dbcluster-multi-zone", Name: models.I18nString{"en": "ClickHouse DBCluster Multi-Zone Deployment", "zh": "使用多可用区的 ClickHouse 集群实例"}, Severity: "medium", Description: models.I18nString{"en": "ClickHouse clusters should use the HighAvailability (Double-replica) edition for multi-zone deployment. Note: This applies only to community edition.", "zh": "使用多可用区的 ClickHouse 集群实例，视为合规，注意只包含社区版本。"}, Reason: models.I18nString{"en": "The ClickHouse cluster is using Single-replica Edition, which does not provide multi-zone high availability.", "zh": "ClickHouse 集群使用单副本版本，不提供多可用区高可用性。"}, Recommendation: models.I18nString{"en": "Use the HighAvailability (Double-replica) edition by setting Category to 'HighAvailability' for multi-zone deployment.", "zh": "通过将 Category 设置为'HighAvailability'来使用双副本版本，实现多可用区部署。"}, ResourceTypes: []string{"ALIYUN::ClickHouse::DBCluster"}, FilePath: "aliyun/rules/clickhouse-dbcluster-multi-zone.rego", PackageName: "infraguard.rules.aliyun.clickhouse_dbcluster_multi_zone", Content: "package infraguard.rules.aliyun.clickhouse_dbcluster_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"clickhouse-dbcluster-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"ClickHouse DBCluster Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 ClickHouse 集群实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ClickHouse clusters should use the HighAvailability (Double-replica) edition for multi-zone deployment. Note: This applies only to community edition.\",\n\t\t\"zh\": \"使用多可用区的 ClickHouse 集群实例，视为合规，注意只包含社区版本。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ClickHouse cluster is using Single-replica Edition, which does not provide multi-zone high availability.\",\n\t\t\"zh\": \"ClickHouse 集群使用单副本版本，不提供多可用区高可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use the HighAvailability (Double-replica) edition by setting Category to 'HighAvailability' for multi-zone deployment.\",\n\t\t\"zh\": \"通过将 Category 设置为'HighAvailability'来使用双副本版本，实现多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ClickHouse::DBCluster\"],\n}\n\n# Check if cluster is high availability (multi-zone)\nis_high_availability(resource) if {\n\tcategory := resource.Properties.Category\n\tcategory == \"HighAvailability\"\n}\n\n# Deny rule: ClickHouse clusters should use HighAvailability edition\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ClickHouse::DBCluster\")\n\tnot is_high_availability(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Category\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cr-instance-any-ip-access-check", Name: models.I18nString{"en": "CR Instance No Any IP Access", "zh": "容器镜像服务实例白名单检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures Container Registry instances do not have any IP (0.0.0.0/0) in their whitelist.", "zh": "确保容器镜像服务实例的白名单中不包含任意 IP（0.0.0.0/0）。"}, Reason: models.I18nString{"en": "Allowing any IP (0.0.0.0/0) in the whitelist exposes the container registry to potential unauthorized access from any internet user.", "zh": "在白名单中允许任意 IP（0.0.0.0/0）会使容器镜像服务面临来自任何互联网用户的潜在未授权访问风险。"}, Recommendation: models.I18nString{"en": "Remove 0.0.0.0/0 from the whitelist and specify specific IP ranges.", "zh": "从白名单中移除 0.0.0.0/0，并指定具体的 IP 范围。"}, ResourceTypes: []string{"ALIYUN::CR::Instance"}, FilePath: "aliyun/rules/cr-instance-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.cr_instance_any_ip_access_check", Content: "package infraguard.rules.aliyun.cr_instance_any_ip_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"cr-instance-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"CR Instance No Any IP Access\",\n\t\t\"zh\": \"容器镜像服务实例白名单检测\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Container Registry instances do not have any IP (0.0.0.0/0) in their whitelist.\",\n\t\t\"zh\": \"确保容器镜像服务实例的白名单中不包含任意 IP（0.0.0.0/0）。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Allowing any IP (0.0.0.0/0) in the whitelist exposes the container registry to potential unauthorized access from any internet user.\",\n\t\t\"zh\": \"在白名单中允许任意 IP（0.0.0.0/0）会使容器镜像服务面临来自任何互联网用户的潜在未授权访问风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove 0.0.0.0/0 from the whitelist and specify specific IP ranges.\",\n\t\t\"zh\": \"从白名单中移除 0.0.0.0/0，并指定具体的 IP 范围。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CR::Instance\"],\n}\n\n# Check if any ACL policy has 0.0.0.0/0 and is associated with a CR instance\nhas_any_ip_access(cr_instance_name) if {\n\tsome acl_name, acl_resource in helpers.resources_by_type(\"ALIYUN::CR::InstanceEndpointAclPolicy\")\n\n\t# Check if the entry is 0.0.0.0/0 (any IP)\n\tentry := helpers.get_property(acl_resource, \"Entry\", \"\")\n\tentry == \"0.0.0.0/0\"\n\n\t# Get the instance ID from the ACL policy (could be a GetAtt reference or string)\n\tinstance_id_prop := helpers.get_property(acl_resource, \"InstanceId\", \"\")\n\n\t# Check if InstanceId is a GetAtt reference pointing to this CR instance\n\thelpers.is_get_att_referencing(instance_id_prop, cr_instance_name)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CR::Instance\")\n\thas_any_ip_access(name)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cr-instance-multi-zone", Name: models.I18nString{"en": "CR Instance with Zone-Redundant OSS Bucket", "zh": "关联同城冗余的 oss 桶的容器镜像实例"}, Severity: "medium", Description: models.I18nString{"en": "Container Registry instances should be associated with zone-redundant OSS buckets for high availability.", "zh": "关联同城冗余的 oss 桶的容器镜像实例，视为合规。"}, Reason: models.I18nString{"en": "The Container Registry instance is associated with a non-redundant OSS bucket, which may affect availability.", "zh": "容器镜像实例关联的 OSS 桶不是同城冗余类型，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Associate the Container Registry instance with an OSS bucket that has zone-redundant storage (ZRS) enabled.", "zh": "将容器镜像实例关联到启用了同城冗余存储（ZRS）的 OSS 桶。"}, ResourceTypes: []string{"ALIYUN::CR::Instance"}, FilePath: "aliyun/rules/cr-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.cr_instance_multi_zone", Content: "package infraguard.rules.aliyun.cr_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"cr-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"CR Instance with Zone-Redundant OSS Bucket\",\n\t\t\"zh\": \"关联同城冗余的 oss 桶的容器镜像实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Container Registry instances should be associated with zone-redundant OSS buckets for high availability.\",\n\t\t\"zh\": \"关联同城冗余的 oss 桶的容器镜像实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Container Registry instance is associated with a non-redundant OSS bucket, which may affect availability.\",\n\t\t\"zh\": \"容器镜像实例关联的 OSS 桶不是同城冗余类型，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Associate the Container Registry instance with an OSS bucket that has zone-redundant storage (ZRS) enabled.\",\n\t\t\"zh\": \"将容器镜像实例关联到启用了同城冗余存储（ZRS）的 OSS 桶。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CR::Instance\"],\n}\n\n# Get OSS bucket name from CR instance (handle both direct string and Ref)\nget_oss_bucket_name(cr_instance) := bucket_name if {\n\tstorage_name := cr_instance.Properties.InstanceStorageName\n\tis_string(storage_name)\n\tbucket_name := storage_name\n}\n\nget_oss_bucket_name(cr_instance) := bucket_name if {\n\tstorage_name := cr_instance.Properties.InstanceStorageName\n\tis_object(storage_name)\n\tbucket_name := storage_name.Ref\n}\n\n# Check if associated OSS bucket is zone-redundant\nhas_zone_redundant_oss(cr_instance_name) if {\n\tbucket_name := get_oss_bucket_name(input.Resources[cr_instance_name])\n\n\t# Find the OSS bucket resource\n\tsome oss_name, oss_resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\toss_name == bucket_name\n\n\t# Check if storage class is ZRS (Zone-Redundant Storage)\n\tstorage_class := helpers.get_property(oss_resource, \"StorageClass\", \"Standard\")\n\tstorage_class == \"ZRS\"\n}\n\n# Deny rule: CR instances must be associated with zone-redundant OSS buckets\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CR::Instance\")\n\n\t# Only check if custom OSS bucket is specified\n\thelpers.has_property(resource, \"InstanceStorageName\")\n\n\t# Check if not zone-redundant\n\tnot has_zone_redundant_oss(name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InstanceStorageName\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cr-repository-image-scanning-enabled", Name: models.I18nString{"en": "CR Instance Image Scanning Enabled", "zh": "为容器镜像实例开启安全扫描"}, Severity: "high", Description: models.I18nString{"en": "Ensures Container Registry instances have image scanning enabled for security vulnerability detection.", "zh": "确保容器镜像实例开启了镜像安全扫描功能以检测安全漏洞。"}, Reason: models.I18nString{"en": "Image scanning helps identify and prevent deployment of vulnerable container images.", "zh": "镜像扫描有助于识别和防止部署有漏洞的容器镜像。"}, Recommendation: models.I18nString{"en": "Enable image scanning for the Container Registry instance.", "zh": "为容器镜像实例启用镜像扫描功能。"}, ResourceTypes: []string{"ALIYUN::CR::Instance"}, FilePath: "aliyun/rules/cr-repository-image-scanning-enabled.rego", PackageName: "infraguard.rules.aliyun.cr_repository_image_scanning_enabled", Content: "package infraguard.rules.aliyun.cr_repository_image_scanning_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"cr-repository-image-scanning-enabled\",\n\t\"name\": {\n\t\t\"en\": \"CR Instance Image Scanning Enabled\",\n\t\t\"zh\": \"为容器镜像实例开启安全扫描\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Container Registry instances have image scanning enabled for security vulnerability detection.\",\n\t\t\"zh\": \"确保容器镜像实例开启了镜像安全扫描功能以检测安全漏洞。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Image scanning helps identify and prevent deployment of vulnerable container images.\",\n\t\t\"zh\": \"镜像扫描有助于识别和防止部署有漏洞的容器镜像。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable image scanning for the Container Registry instance.\",\n\t\t\"zh\": \"为容器镜像实例启用镜像扫描功能。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CR::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# Check ImageScanner property\n\timage_scanner := helpers.get_property(resource, \"ImageScanner\", \"\")\n\tcount(image_scanner) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CR::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageScanner\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cr-repository-immutablity-enable", Name: models.I18nString{"en": "Container Registry repository image version is immutable", "zh": "容器镜像服务镜像版本为不可变"}, Severity: "low", Description: models.I18nString{"en": "Container Registry repository image version is immutable, considered compliant.", "zh": "容器镜像服务镜像版本为不可变,视为合规。"}, Reason: models.I18nString{"en": "Container Registry repository image version is not immutable", "zh": "容器镜像服务镜像版本不是不可变的"}, Recommendation: models.I18nString{"en": "Enable tag immutability for Container Registry repository to prevent image tags from being overwritten", "zh": "为容器镜像服务仓库启用标签不可变性以防止镜像标签被覆盖"}, ResourceTypes: []string{"ALIYUN::CR::Repository"}, FilePath: "aliyun/rules/cr-repository-immutablity-enable.rego", PackageName: "infraguard.rules.aliyun.cr_repository_immutablity_enable", Content: "package infraguard.rules.aliyun.cr_repository_immutablity_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"cr-repository-immutablity-enable\",\n\t\"name\": {\n\t\t\"en\": \"Container Registry repository image version is immutable\",\n\t\t\"zh\": \"容器镜像服务镜像版本为不可变\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Container Registry repository image version is immutable, considered compliant.\",\n\t\t\"zh\": \"容器镜像服务镜像版本为不可变,视为合规。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::CR::Repository\"],\n\t\"reason\": {\n\t\t\"en\": \"Container Registry repository image version is not immutable\",\n\t\t\"zh\": \"容器镜像服务镜像版本不是不可变的\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable tag immutability for Container Registry repository to prevent image tags from being overwritten\",\n\t\t\"zh\": \"为容器镜像服务仓库启用标签不可变性以防止镜像标签被覆盖\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CR::Repository\")\n\n\t# Check if TagImmutability is enabled\n\t# Only applicable when InstanceId is specified (Enterprise Edition)\n\thas_instance := helpers.has_property(resource, \"InstanceId\")\n\thas_instance\n\n\ttag_immutability := helpers.get_property(resource, \"TagImmutability\", false)\n\tnot helpers.is_true(tag_immutability)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:cr-repository-type-private", Name: models.I18nString{"en": "CR Repository Type Private", "zh": "容器镜像服务镜像仓库类型为私有"}, Severity: "high", Description: models.I18nString{"en": "Ensures that CR repositories are set to PRIVATE.", "zh": "确保容器镜像仓库类型设置为私有。"}, Reason: models.I18nString{"en": "Public repositories can be accessed by anyone, which may lead to exposure of sensitive code or data.", "zh": "公开仓库可以被任何人访问，可能导致敏感代码或数据泄露。"}, Recommendation: models.I18nString{"en": "Set the RepoType to 'PRIVATE' for the CR repository.", "zh": "将容器镜像仓库的 RepoType 设置为 'PRIVATE'。"}, ResourceTypes: []string{"ALIYUN::CR::Repository"}, FilePath: "aliyun/rules/cr-repository-type-private.rego", PackageName: "infraguard.rules.aliyun.cr_repository_type_private", Content: "package infraguard.rules.aliyun.cr_repository_type_private\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"cr-repository-type-private\",\n\t\"name\": {\n\t\t\"en\": \"CR Repository Type Private\",\n\t\t\"zh\": \"容器镜像服务镜像仓库类型为私有\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that CR repositories are set to PRIVATE.\",\n\t\t\"zh\": \"确保容器镜像仓库类型设置为私有。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public repositories can be accessed by anyone, which may lead to exposure of sensitive code or data.\",\n\t\t\"zh\": \"公开仓库可以被任何人访问，可能导致敏感代码或数据泄露。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set the RepoType to 'PRIVATE' for the CR repository.\",\n\t\t\"zh\": \"将容器镜像仓库的 RepoType 设置为 'PRIVATE'。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CR::Repository\"],\n}\n\nis_compliant(resource) if {\n\thelpers.get_property(resource, \"RepoType\", \"PRIVATE\") == \"PRIVATE\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CR::Repository\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RepoType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:dcdn-domain-multiple-origin-servers", Name: models.I18nString{"en": "DCDN Domain Multiple Origin Servers", "zh": "DCDN 域名配置多个源站"}, Severity: "high", Description: models.I18nString{"en": "DCDN domains should be configured with multiple origin servers for high availability and fault tolerance.", "zh": "DCDN 域名配置多个源站，视为合规。"}, Reason: models.I18nString{"en": "The DCDN domain is configured with only one origin server, creating a single point of failure.", "zh": "DCDN 域名仅配置了一个源站，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure at least two origin servers in the Sources property to ensure high availability.", "zh": "在 Sources 属性中配置至少两个源站，以确保高可用性。"}, ResourceTypes: []string{"ALIYUN::DCDN::Domain"}, FilePath: "aliyun/rules/dcdn-domain-multiple-origin-servers.rego", PackageName: "infraguard.rules.aliyun.dcdn_domain_multiple_origin_servers", Content: "package infraguard.rules.aliyun.dcdn_domain_multiple_origin_servers\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"dcdn-domain-multiple-origin-servers\",\n\t\"name\": {\n\t\t\"en\": \"DCDN Domain Multiple Origin Servers\",\n\t\t\"zh\": \"DCDN 域名配置多个源站\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"DCDN domains should be configured with multiple origin servers for high availability and fault tolerance.\",\n\t\t\"zh\": \"DCDN 域名配置多个源站，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The DCDN domain is configured with only one origin server, creating a single point of failure.\",\n\t\t\"zh\": \"DCDN 域名仅配置了一个源站，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two origin servers in the Sources property to ensure high availability.\",\n\t\t\"zh\": \"在 Sources 属性中配置至少两个源站，以确保高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::DCDN::Domain\"],\n}\n\n# Check if domain has multiple origin servers\nhas_multiple_origin_servers(resource) if {\n\tsources := resource.Properties.Sources\n\tcount(sources) >= 2\n}\n\n# Deny rule: DCDN domains must have multiple origin servers\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::DCDN::Domain\")\n\tnot has_multiple_origin_servers(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Sources\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:eci-container-group-volumn-mounts", Name: models.I18nString{"en": "ECI Volume Mounting Check", "zh": "ECI 容器组挂载卷核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ECI container groups have volumes mounted for persistent data storage.", "zh": "确保 ECI 容器组挂载了用于持久化数据存储的卷。"}, Reason: models.I18nString{"en": "Stateless containers may lose critical data upon restart if volumes are not mounted.", "zh": "如果未挂载卷，无状态容器在重启时可能会丢失关键数据。"}, Recommendation: models.I18nString{"en": "Configure volumes and volume mounts for the ECI container group.", "zh": "为 ECI 容器组配置卷及卷挂载。"}, ResourceTypes: []string{"ALIYUN::ECI::ContainerGroup"}, FilePath: "aliyun/rules/eci-container-group-volumn-mounts.rego", PackageName: "infraguard.rules.aliyun.eci_container_group_volumn_mounts", Content: "package infraguard.rules.aliyun.eci_container_group_volumn_mounts\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"eci-container-group-volumn-mounts\",\n\t\"name\": {\n\t\t\"en\": \"ECI Volume Mounting Check\",\n\t\t\"zh\": \"ECI 容器组挂载卷核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECI container groups have volumes mounted for persistent data storage.\",\n\t\t\"zh\": \"确保 ECI 容器组挂载了用于持久化数据存储的卷。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Stateless containers may lose critical data upon restart if volumes are not mounted.\",\n\t\t\"zh\": \"如果未挂载卷，无状态容器在重启时可能会丢失关键数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure volumes and volume mounts for the ECI container group.\",\n\t\t\"zh\": \"为 ECI 容器组配置卷及卷挂载。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECI::ContainerGroup\"],\n}\n\nis_compliant(resource) if {\n\tvolumes := helpers.get_property(resource, \"Volume\", [])\n\tcount(volumes) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECI::ContainerGroup\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Volume\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:eci-containergroup-environment-no-specified-keys", Name: models.I18nString{"en": "ECI Container Group Does Not Contain Sensitive Environment Variables", "zh": "ECI 容器组不包含敏感环境变量"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ECI container groups do not have sensitive environment variables like passwords or access keys.", "zh": "ECI 容器组不包含敏感环境变量（如密码、AccessKey 等），视为合规。"}, Reason: models.I18nString{"en": "ECI container group contains sensitive environment variables, which may leak credentials.", "zh": "ECI 容器组包含敏感环境变量，可能导致凭证泄露。"}, Recommendation: models.I18nString{"en": "Use Secrets or parameter store to manage sensitive environment variables.", "zh": "请使用 Secret 或参数存储来管理敏感环境变量。"}, ResourceTypes: []string{"ALIYUN::ECI::ContainerGroup"}, FilePath: "aliyun/rules/eci-containergroup-environment-no-specified-keys.rego", PackageName: "infraguard.rules.aliyun.eci_containergroup_environment_no_specified_keys", Content: "package infraguard.rules.aliyun.eci_containergroup_environment_no_specified_keys\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"eci-containergroup-environment-no-specified-keys\",\n\t\"name\": {\n\t\t\"en\": \"ECI Container Group Does Not Contain Sensitive Environment Variables\",\n\t\t\"zh\": \"ECI 容器组不包含敏感环境变量\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECI container groups do not have sensitive environment variables like passwords or access keys.\",\n\t\t\"zh\": \"ECI 容器组不包含敏感环境变量（如密码、AccessKey 等），视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"ECI container group contains sensitive environment variables, which may leak credentials.\",\n\t\t\"zh\": \"ECI 容器组包含敏感环境变量，可能导致凭证泄露。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use Secrets or parameter store to manage sensitive environment variables.\",\n\t\t\"zh\": \"请使用 Secret 或参数存储来管理敏感环境变量。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECI::ContainerGroup\"],\n}\n\n# Default sensitive environment variable keys\ndefault sensitive_keys := [\n\t\"password\",\n\t\"passwd\",\n\t\"pwd\",\n\t\"secret\",\n\t\"key\",\n\t\"token\",\n\t\"credential\",\n\t\"access_key\",\n\t\"accesskey\",\n\t\"secret_key\",\n\t\"secretkey\",\n\t\"access_key_id\",\n]\n\n# Get sensitive keys from parameters or use default\nget_sensitive_keys := input.rule_parameters.sensitive_env_keys if {\n\tcount(input.rule_parameters.sensitive_env_keys) > 0\n} else := sensitive_keys\n\n# Check if a key is sensitive (supports partial match)\nis_sensitive_key(key) if {\n\tsome sensitive in get_sensitive_keys\n\tcontains(lower(key), lower(sensitive))\n}\n\n# Check if environment variable contains sensitive key\nhas_sensitive_env(container) if {\n\tsome env in container.EnvironmentVar\n\tis_sensitive_key(env.Key)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECI::ContainerGroup\")\n\n\tsome container in resource.Properties.Container\n\thas_sensitive_env(container)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Container\", \"EnvironmentVar\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-available-disk-encrypted", Name: models.I18nString{"en": "ECS Disk Encryption Enabled", "zh": "可用的磁盘均已加密"}, Severity: "high", Description: models.I18nString{"en": "Ensures that all ECS disks are encrypted.", "zh": "确保所有 ECS 磁盘都已加密。"}, Reason: models.I18nString{"en": "Encryption protects data at rest from unauthorized physical access or theft.", "zh": "加密可以保护静态数据免受未经授权的物理访问或盗窃。"}, Recommendation: models.I18nString{"en": "Set 'Encrypted' to true for all ECS disks.", "zh": "将所有 ECS 磁盘的'Encrypted'属性设置为 true。"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-available-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ecs_available_disk_encrypted", Content: "package infraguard.rules.aliyun.ecs_available_disk_encrypted\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-available-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ECS Disk Encryption Enabled\",\n\t\t\"zh\": \"可用的磁盘均已加密\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that all ECS disks are encrypted.\",\n\t\t\"zh\": \"确保所有 ECS 磁盘都已加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Encryption protects data at rest from unauthorized physical access or theft.\",\n\t\t\"zh\": \"加密可以保护静态数据免受未经授权的物理访问或盗窃。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set 'Encrypted' to true for all ECS disks.\",\n\t\t\"zh\": \"将所有 ECS 磁盘的'Encrypted'属性设置为 true。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"Encrypted\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Encrypted\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-all-encrypted-by-kms", Name: models.I18nString{"en": "ECS disk with KMS encryption enabled", "zh": "ECS 磁盘开启 KMS 加密"}, Severity: "medium", Description: models.I18nString{"en": "ECS disks (including system disk and data disks) are encrypted with KMS, considered compliant.", "zh": "ECS 磁盘(包括系统盘和数据盘)开启 KMS 加密，视为合规。"}, Reason: models.I18nString{"en": "ECS disk is not encrypted with KMS", "zh": "ECS 磁盘未开启 KMS 加密"}, Recommendation: models.I18nString{"en": "Enable KMS encryption for ECS disks by setting Encrypted to true and specifying a KMSKeyId", "zh": "通过设置 Encrypted 为 true 并指定 KMSKeyId 来为 ECS 磁盘启用 KMS 加密"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-all-encrypted-by-kms.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_all_encrypted_by_kms", Content: "package infraguard.rules.aliyun.ecs_disk_all_encrypted_by_kms\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-disk-all-encrypted-by-kms\",\n\t\"name\": {\n\t\t\"en\": \"ECS disk with KMS encryption enabled\",\n\t\t\"zh\": \"ECS 磁盘开启 KMS 加密\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS disks (including system disk and data disks) are encrypted with KMS, considered compliant.\",\n\t\t\"zh\": \"ECS 磁盘(包括系统盘和数据盘)开启 KMS 加密，视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS disk is not encrypted with KMS\",\n\t\t\"zh\": \"ECS 磁盘未开启 KMS 加密\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable KMS encryption for ECS disks by setting Encrypted to true and specifying a KMSKeyId\",\n\t\t\"zh\": \"通过设置 Encrypted 为 true 并指定 KMSKeyId 来为 ECS 磁盘启用 KMS 加密\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Check if disk is encrypted\n\tencrypted := helpers.get_property(resource, \"Encrypted\", false)\n\tnot helpers.is_true(encrypted)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Encrypted\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-auto-snapshot-policy", Name: models.I18nString{"en": "ECS disk has auto snapshot policy configured", "zh": "ECS 磁盘设置自动快照策略"}, Severity: "low", Description: models.I18nString{"en": "ECS disk has auto snapshot policy configured, considered compliant. Disks not in use, disks that do not support auto snapshot policy, and non-persistent disks mounted by ACK clusters are not applicable. After enabling auto snapshot policy, Alibaba Cloud will automatically create snapshots for cloud disks according to preset time points and cycles, enabling quick recovery from virus intrusion or ransomware attacks.", "zh": "ECS 磁盘设置了自动快照策略,视为合规。状态非使用中的磁盘、不支持设置自动快照策略的磁盘、ACK 集群挂载的非持久化使用场景的磁盘视为不适用。开启自动快照策略后,阿里云会自动按照预设的时间点和周期为云盘创建快照,遭遇病毒入侵或勒索后能够快速从安全事件中恢复。"}, Reason: models.I18nString{"en": "ECS disk does not have auto snapshot policy configured", "zh": "ECS 磁盘未设置自动快照策略"}, Recommendation: models.I18nString{"en": "Configure auto snapshot policy for ECS disk to enable automatic backup and quick recovery from security incidents", "zh": "为 ECS 磁盘配置自动快照策略以启用自动备份并快速从安全事件中恢复"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-auto-snapshot-policy.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_auto_snapshot_policy", Content: "package infraguard.rules.aliyun.ecs_disk_auto_snapshot_policy\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-disk-auto-snapshot-policy\",\n\t\"name\": {\n\t\t\"en\": \"ECS disk has auto snapshot policy configured\",\n\t\t\"zh\": \"ECS 磁盘设置自动快照策略\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS disk has auto snapshot policy configured, considered compliant. Disks not in use, disks that do not support auto snapshot policy, and non-persistent disks mounted by ACK clusters are not applicable. After enabling auto snapshot policy, Alibaba Cloud will automatically create snapshots for cloud disks according to preset time points and cycles, enabling quick recovery from virus intrusion or ransomware attacks.\",\n\t\t\"zh\": \"ECS 磁盘设置了自动快照策略,视为合规。状态非使用中的磁盘、不支持设置自动快照策略的磁盘、ACK 集群挂载的非持久化使用场景的磁盘视为不适用。开启自动快照策略后,阿里云会自动按照预设的时间点和周期为云盘创建快照,遭遇病毒入侵或勒索后能够快速从安全事件中恢复。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS disk does not have auto snapshot policy configured\",\n\t\t\"zh\": \"ECS 磁盘未设置自动快照策略\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure auto snapshot policy for ECS disk to enable automatic backup and quick recovery from security incidents\",\n\t\t\"zh\": \"为 ECS 磁盘配置自动快照策略以启用自动备份并快速从安全事件中恢复\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Check if AutoSnapshotPolicyId is configured\n\tnot helpers.has_property(resource, \"AutoSnapshotPolicyId\")\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-encrypted", Name: models.I18nString{"en": "ECS data disk encryption enabled", "zh": "ECS 数据磁盘开启加密"}, Severity: "medium", Description: models.I18nString{"en": "ECS data disk has encryption enabled, considered compliant.", "zh": "ECS 数据磁盘已开启加密,视为合规。"}, Reason: models.I18nString{"en": "ECS data disk does not have encryption enabled", "zh": "ECS 数据磁盘未开启加密"}, Recommendation: models.I18nString{"en": "Enable encryption for ECS data disk to protect data at rest", "zh": "为 ECS 数据磁盘开启加密以保护静态数据"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_encrypted", Content: "package infraguard.rules.aliyun.ecs_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ECS data disk encryption enabled\",\n\t\t\"zh\": \"ECS 数据磁盘开启加密\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS data disk has encryption enabled, considered compliant.\",\n\t\t\"zh\": \"ECS 数据磁盘已开启加密,视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS data disk does not have encryption enabled\",\n\t\t\"zh\": \"ECS 数据磁盘未开启加密\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for ECS data disk to protect data at rest\",\n\t\t\"zh\": \"为 ECS 数据磁盘开启加密以保护静态数据\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Check if disk is encrypted\n\tencrypted := helpers.get_property(resource, \"Encrypted\", false)\n\tnot helpers.is_true(encrypted)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-idle-check", Name: models.I18nString{"en": "ECS Disk Idle Check", "zh": "ECS 磁盘闲置检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that ECS disks are attached to an instance and not in an idle state.", "zh": "确保 ECS 磁盘已挂载到实例，未处于闲置状态。"}, Reason: models.I18nString{"en": "Idle disks still incur costs and may represent unused resources.", "zh": "闲置磁盘仍会产生费用，并且可能表示资源未被使用。"}, Recommendation: models.I18nString{"en": "Attach the disk to an instance or delete it if it's no longer needed.", "zh": "将磁盘挂载到实例，如果不再需要，则将其删除。"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-idle-check.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_idle_check", Content: "package infraguard.rules.aliyun.ecs_disk_idle_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-disk-idle-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Disk Idle Check\",\n\t\t\"zh\": \"ECS 磁盘闲置检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS disks are attached to an instance and not in an idle state.\",\n\t\t\"zh\": \"确保 ECS 磁盘已挂载到实例，未处于闲置状态。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Idle disks still incur costs and may represent unused resources.\",\n\t\t\"zh\": \"闲置磁盘仍会产生费用，并且可能表示资源未被使用。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the disk to an instance or delete it if it's no longer needed.\",\n\t\t\"zh\": \"将磁盘挂载到实例，如果不再需要，则将其删除。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Conceptual check for attachment\n\tnot helpers.has_property(resource, \"InstanceId\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-in-use", Name: models.I18nString{"en": "ECS disk is in use", "zh": "ECS 磁盘正在使用中"}, Severity: "medium", Description: models.I18nString{"en": "ECS disks are attached to an instance or in use state, considered compliant. Disks that are available or unattached may be idle resources.", "zh": "ECS 磁盘已挂载到实例或处于使用中状态，视为合规。闲置或未挂载的磁盘可能造成资源浪费。"}, Reason: models.I18nString{"en": "ECS disk is not in use (Available status or unattached)", "zh": "ECS 磁盘未使用中（可用状态或未挂载）"}, Recommendation: models.I18nString{"en": "Attach the disk to an ECS instance or release unused disks to save costs", "zh": "将磁盘挂载到 ECS 实例，或释放未使用的磁盘以节省成本"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-in-use.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_in_use", Content: "package infraguard.rules.aliyun.ecs_disk_in_use\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-disk-in-use\",\n\t\"name\": {\n\t\t\"en\": \"ECS disk is in use\",\n\t\t\"zh\": \"ECS 磁盘正在使用中\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS disks are attached to an instance or in use state, considered compliant. Disks that are available or unattached may be idle resources.\",\n\t\t\"zh\": \"ECS 磁盘已挂载到实例或处于使用中状态，视为合规。闲置或未挂载的磁盘可能造成资源浪费。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS disk is not in use (Available status or unattached)\",\n\t\t\"zh\": \"ECS 磁盘未使用中（可用状态或未挂载）\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the disk to an ECS instance or release unused disks to save costs\",\n\t\t\"zh\": \"将磁盘挂载到 ECS 实例，或释放未使用的磁盘以节省成本\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Disk is not in use if not referenced by DiskAttachment and not attached via InstanceId\n\tnot helpers.is_referenced_by_property(name, \"ALIYUN::ECS::DiskAttachment\", [\"DiskId\"])\n\tnot helpers.has_property(resource, \"InstanceId\")\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-regional-auto-check", Name: models.I18nString{"en": "ECS Disk Zone-Redundant ESSD Storage", "zh": "使用同城冗余类型的 ESSD 数据盘"}, Severity: "low", Description: models.I18nString{"en": "ECS data disks should use zone-redundant ESSD storage for high availability. System disks are not applicable to this rule.", "zh": "使用同城冗余类型的 ESSD 数据盘，视为合规。系统盘视为不适用。"}, Reason: models.I18nString{"en": "The ECS data disk does not use zone-redundant storage, which may affect data availability.", "zh": "ECS 数据盘未使用同城冗余存储，可能影响数据可用性。"}, Recommendation: models.I18nString{"en": "Use zone-redundant ESSD storage by setting DiskCategory to 'cloud_regional_disk_auto' or 'cloud_essd' with appropriate redundancy configuration.", "zh": "通过将 DiskCategory 设置为'cloud_regional_disk_auto'或配置适当冗余的'cloud_essd'来使用同城冗余 ESSD 存储。"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-regional-auto-check.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_regional_auto_check", Content: "package infraguard.rules.aliyun.ecs_disk_regional_auto_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-disk-regional-auto-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Disk Zone-Redundant ESSD Storage\",\n\t\t\"zh\": \"使用同城冗余类型的 ESSD 数据盘\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"ECS data disks should use zone-redundant ESSD storage for high availability. System disks are not applicable to this rule.\",\n\t\t\"zh\": \"使用同城冗余类型的 ESSD 数据盘，视为合规。系统盘视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ECS data disk does not use zone-redundant storage, which may affect data availability.\",\n\t\t\"zh\": \"ECS 数据盘未使用同城冗余存储，可能影响数据可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use zone-redundant ESSD storage by setting DiskCategory to 'cloud_regional_disk_auto' or 'cloud_essd' with appropriate redundancy configuration.\",\n\t\t\"zh\": \"通过将 DiskCategory 设置为'cloud_regional_disk_auto'或配置适当冗余的'cloud_essd'来使用同城冗余 ESSD 存储。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n}\n\n# Check if disk is zone-redundant\nis_zone_redundant(resource) if {\n\tdisk_category := resource.Properties.DiskCategory\n\tdisk_category == \"cloud_regional_disk_auto\"\n}\n\n# Check if disk is attached to an instance (system disks are created with instance)\nis_data_disk(resource) if {\n\t# Data disks don't have InstanceId set (they are created separately)\n\tnot helpers.has_property(resource, \"InstanceId\")\n}\n\n# Deny rule: ECS data disks should use zone-redundant storage\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Only check data disks\n\tis_data_disk(resource)\n\n\t# Check if not zone-redundant\n\tnot is_zone_redundant(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DiskCategory\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-disk-retain-auto-snapshot", Name: models.I18nString{"en": "Retain auto snapshot when ECS disk is released", "zh": "ECS 数据磁盘释放时保留自动快照"}, Severity: "medium", Description: models.I18nString{"en": "Configure ECS disks to retain auto snapshots when released, considered compliant. This helps protect data from accidental deletion.", "zh": "设置 ECS 磁盘释放时保留自动快照，视为合规。这有助于防止数据意外删除。"}, Reason: models.I18nString{"en": "ECS disk will delete auto snapshots when released, risking data loss", "zh": "ECS 磁盘释放时将删除自动快照，可能导致数据丢失"}, Recommendation: models.I18nString{"en": "Set DeleteAutoSnapshot to false to retain auto snapshots when disk is released", "zh": "将 DeleteAutoSnapshot 设置为 false 以在磁盘释放时保留自动快照"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-disk-retain-auto-snapshot.rego", PackageName: "infraguard.rules.aliyun.ecs_disk_retain_auto_snapshot", Content: "package infraguard.rules.aliyun.ecs_disk_retain_auto_snapshot\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-disk-retain-auto-snapshot\",\n\t\"name\": {\n\t\t\"en\": \"Retain auto snapshot when ECS disk is released\",\n\t\t\"zh\": \"ECS 数据磁盘释放时保留自动快照\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Configure ECS disks to retain auto snapshots when released, considered compliant. This helps protect data from accidental deletion.\",\n\t\t\"zh\": \"设置 ECS 磁盘释放时保留自动快照，视为合规。这有助于防止数据意外删除。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS disk will delete auto snapshots when released, risking data loss\",\n\t\t\"zh\": \"ECS 磁盘释放时将删除自动快照，可能导致数据丢失\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set DeleteAutoSnapshot to false to retain auto snapshots when disk is released\",\n\t\t\"zh\": \"将 DeleteAutoSnapshot 设置为 false 以在磁盘释放时保留自动快照\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\n\t# Check if auto snapshots will be retained\n\tdelete_auto_snapshot := helpers.get_property(resource, \"DeleteAutoSnapshot\", false)\n\thelpers.is_true(delete_auto_snapshot)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeleteAutoSnapshot\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-in-use-disk-encrypted", Name: models.I18nString{"en": "ECS In-Use Disk Encryption", "zh": "使用中的 ECS 数据磁盘开启加密"}, Severity: "medium", Description: models.I18nString{"en": "ECS data disks should have encryption enabled to protect data at rest. Encrypted disks use KMS keys to encrypt data, ensuring data security and compliance with regulatory requirements.", "zh": "使用中的 ECS 数据磁盘应开启加密以保护静态数据。加密磁盘使用 KMS 密钥对数据进行加密，确保数据安全并符合合规要求。"}, Reason: models.I18nString{"en": "The ECS disk does not have encryption enabled, which may expose sensitive data to unauthorized access.", "zh": "ECS 磁盘未开启加密，可能导致敏感数据暴露给未授权访问。"}, Recommendation: models.I18nString{"en": "Enable encryption for the ECS disk by setting the Encrypted property to true.", "zh": "通过将 Encrypted 属性设置为 true 来为 ECS 磁盘启用加密。"}, ResourceTypes: []string{"ALIYUN::ECS::Disk"}, FilePath: "aliyun/rules/ecs-in-use-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ecs_in_use_disk_encrypted", Content: "package infraguard.rules.aliyun.ecs_in_use_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-in-use-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ECS In-Use Disk Encryption\",\n\t\t\"zh\": \"使用中的 ECS 数据磁盘开启加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ECS data disks should have encryption enabled to protect data at rest. Encrypted disks use KMS keys to encrypt data, ensuring data security and compliance with regulatory requirements.\",\n\t\t\"zh\": \"使用中的 ECS 数据磁盘应开启加密以保护静态数据。加密磁盘使用 KMS 密钥对数据进行加密，确保数据安全并符合合规要求。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ECS disk does not have encryption enabled, which may expose sensitive data to unauthorized access.\",\n\t\t\"zh\": \"ECS 磁盘未开启加密，可能导致敏感数据暴露给未授权访问。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for the ECS disk by setting the Encrypted property to true.\",\n\t\t\"zh\": \"通过将 Encrypted 属性设置为 true 来为 ECS 磁盘启用加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Disk\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::Disk\")\n\tnot is_encrypted(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Encrypted\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nis_encrypted(resource) if {\n\tresource.Properties.Encrypted == true\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-attached-security-group", Name: models.I18nString{"en": "ECS Instance Attached Security Group", "zh": "ECS 实例绑定安全组"}, Severity: "high", Description: models.I18nString{"en": "If the ECS instance is included in the specified security group, the configuration is considered compliant.", "zh": "如果 ECS 实例已关联指定的安全组，则视为合规。"}, Reason: models.I18nString{"en": "The ECS instance is not attached to any security group, which may leave it without proper network access control.", "zh": "ECS 实例未关联任何安全组，可能导致缺乏适当的网络访问控制。"}, Recommendation: models.I18nString{"en": "Attach the ECS instance to at least one security group by setting SecurityGroupId or SecurityGroupIds property.", "zh": "通过设置 SecurityGroupId 或 SecurityGroupIds 属性，将 ECS 实例关联至少一个安全组。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-attached-security-group.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_attached_security_group", Content: "package infraguard.rules.aliyun.ecs_instance_attached_security_group\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-attached-security-group\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Attached Security Group\",\n\t\t\"zh\": \"ECS 实例绑定安全组\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"If the ECS instance is included in the specified security group, the configuration is considered compliant.\",\n\t\t\"zh\": \"如果 ECS 实例已关联指定的安全组，则视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ECS instance is not attached to any security group, which may leave it without proper network access control.\",\n\t\t\"zh\": \"ECS 实例未关联任何安全组，可能导致缺乏适当的网络访问控制。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the ECS instance to at least one security group by setting SecurityGroupId or SecurityGroupIds property.\",\n\t\t\"zh\": \"通过设置 SecurityGroupId 或 SecurityGroupIds 属性，将 ECS 实例关联至少一个安全组。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\n# Check if the instance has SecurityGroupId set\nhas_security_group_id(resource) if {\n\thelpers.has_property(resource, \"SecurityGroupId\")\n\tresource.Properties.SecurityGroupId != \"\"\n}\n\n# Check if the instance has SecurityGroupIds set with at least one entry\nhas_security_group_ids(resource) if {\n\thelpers.has_property(resource, \"SecurityGroupIds\")\n\tcount(resource.Properties.SecurityGroupIds) > 0\n}\n\n# Instance is attached to security group if either property is set\nis_attached_to_security_group(resource) if {\n\thas_security_group_id(resource)\n}\n\nis_attached_to_security_group(resource) if {\n\thas_security_group_ids(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types({\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"})\n\tnot is_attached_to_security_group(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-auto-renewal-enabled", Name: models.I18nString{"en": "ECS subscription instance has auto-renewal enabled", "zh": "ECS 包年包月实例开启自动续费"}, Severity: "medium", Description: models.I18nString{"en": "ECS subscription (prepaid) instances have auto-renewal enabled, considered compliant. Pay-as-you-go instances are not applicable.", "zh": "ECS 包年包月的实例开启自动续费，视为合规。按量付费的实例不适用本规则。"}, Reason: models.I18nString{"en": "ECS subscription instance does not have auto-renewal enabled", "zh": "ECS 包年包月实例未开启自动续费"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for subscription instances to avoid service interruption due to expiration", "zh": "为订阅实例启用自动续费，避免因到期导致服务中断"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-auto-renewal-enabled.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_auto_renewal_enabled", Content: "package infraguard.rules.aliyun.ecs_instance_auto_renewal_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-auto-renewal-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ECS subscription instance has auto-renewal enabled\",\n\t\t\"zh\": \"ECS 包年包月实例开启自动续费\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS subscription (prepaid) instances have auto-renewal enabled, considered compliant. Pay-as-you-go instances are not applicable.\",\n\t\t\"zh\": \"ECS 包年包月的实例开启自动续费，视为合规。按量付费的实例不适用本规则。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS subscription instance does not have auto-renewal enabled\",\n\t\t\"zh\": \"ECS 包年包月实例未开启自动续费\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for subscription instances to avoid service interruption due to expiration\",\n\t\t\"zh\": \"为订阅实例启用自动续费，避免因到期导致服务中断\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Only check subscription instances\n\tinstance_charge_type := helpers.get_property(resource, \"InstanceChargeType\", \"Postpaid\")\n\n\t# Skip postpaid instances\n\tnot instance_charge_type in [\"Postpaid\", \"PayAsYouGo\", \"PostPaid\", \"PayOnDemand\"]\n\n\t# For subscription instances, check if auto-renewal is enabled\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", \"False\")\n\tauto_renew == \"False\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-chargetype-check", Name: models.I18nString{"en": "ECS Instance Charge Type Check", "zh": "ECS 实例付费类型核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ECS instances use the authorized charge type.", "zh": "确保 ECS 实例使用授权的付费类型。"}, Reason: models.I18nString{"en": "Enforcing specific charge types (e.g., PostPaid) aligns with organizational budget policies.", "zh": "强制执行特定的付费类型（如后付费）符合组织预算政策。"}, Recommendation: models.I18nString{"en": "Set InstanceChargeType to 'PostPaid'.", "zh": "将 InstanceChargeType 设置为'PostPaid'。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-chargetype-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_chargetype_check", Content: "package infraguard.rules.aliyun.ecs_instance_chargetype_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-instance-chargetype-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Charge Type Check\",\n\t\t\"zh\": \"ECS 实例付费类型核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS instances use the authorized charge type.\",\n\t\t\"zh\": \"确保 ECS 实例使用授权的付费类型。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Enforcing specific charge types (e.g., PostPaid) aligns with organizational budget policies.\",\n\t\t\"zh\": \"强制执行特定的付费类型（如后付费）符合组织预算政策。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set InstanceChargeType to 'PostPaid'.\",\n\t\t\"zh\": \"将 InstanceChargeType 设置为'PostPaid'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\tcharge_type := helpers.get_property(resource, \"InstanceChargeType\", \"PostPaid\")\n\tcharge_type == \"PostPaid\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InstanceChargeType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-deletion-protection-enabled", Name: models.I18nString{"en": "ECS Instance Deletion Protection Enabled", "zh": "ECS 实例开启释放保护"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ECS instances have deletion protection enabled.", "zh": "确保 ECS 实例开启了释放保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the instance may be released accidentally, causing service interruption or data loss.", "zh": "如果未开启释放保护，实例可能会被意外释放，导致业务中断或数据丢失。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the ECS instance.", "zh": "为 ECS 实例开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-deletion-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_deletion_protection_enabled", Content: "package infraguard.rules.aliyun.ecs_instance_deletion_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-deletion-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Deletion Protection Enabled\",\n\t\t\"zh\": \"ECS 实例开启释放保护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS instances have deletion protection enabled.\",\n\t\t\"zh\": \"确保 ECS 实例开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the instance may be released accidentally, causing service interruption or data loss.\",\n\t\t\"zh\": \"如果未开启释放保护，实例可能会被意外释放，导致业务中断或数据丢失。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the ECS instance.\",\n\t\t\"zh\": \"为 ECS 实例开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-enabled-security-protection", Name: models.I18nString{"en": "ECS Instance Enabled Security Protection", "zh": "运行中的 ECS 实例开启云安全中心防护"}, Severity: "high", Description: models.I18nString{"en": "Ensures that ECS instances have security enhancement strategy enabled.", "zh": "确保 ECS 实例开启了安全增强策略（云安全中心防护）。"}, Reason: models.I18nString{"en": "Without security protection, the instance is more vulnerable to attacks and malware.", "zh": "如果没有安全防护，实例更容易受到攻击和恶意软件的侵害。"}, Recommendation: models.I18nString{"en": "Enable security enhancement strategy for the ECS instance by setting SecurityEnhancementStrategy to 'Active'.", "zh": "通过将 SecurityEnhancementStrategy 设置为 'Active' 为 ECS 实例开启安全增强策略。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-enabled-security-protection.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_enabled_security_protection", Content: "package infraguard.rules.aliyun.ecs_instance_enabled_security_protection\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-enabled-security-protection\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Enabled Security Protection\",\n\t\t\"zh\": \"运行中的 ECS 实例开启云安全中心防护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS instances have security enhancement strategy enabled.\",\n\t\t\"zh\": \"确保 ECS 实例开启了安全增强策略（云安全中心防护）。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Without security protection, the instance is more vulnerable to attacks and malware.\",\n\t\t\"zh\": \"如果没有安全防护，实例更容易受到攻击和恶意软件的侵害。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable security enhancement strategy for the ECS instance by setting SecurityEnhancementStrategy to 'Active'.\",\n\t\t\"zh\": \"通过将 SecurityEnhancementStrategy 设置为 'Active' 为 ECS 实例开启安全增强策略。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\thelpers.get_property(resource, \"SecurityEnhancementStrategy\", \"Active\") == \"Active\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityEnhancementStrategy\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-expired-check", Name: models.I18nString{"en": "ECS Prepaid Instance Expiration Check", "zh": "ECS 预付费实例到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid instances should have auto-renewal enabled to avoid service interruption due to expiration.", "zh": "预付费实例应开启自动续费，避免出现因费用问题停机。"}, Reason: models.I18nString{"en": "The prepaid ECS instance does not have auto-renewal enabled.", "zh": "预付费 ECS 实例未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid ECS instance by setting AutoRenew to true.", "zh": "通过将 AutoRenew 设置为 true 为预付费 ECS 实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance"}, FilePath: "aliyun/rules/ecs-instance-expired-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_expired_check", Content: "package infraguard.rules.aliyun.ecs_instance_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Prepaid Instance Expiration Check\",\n\t\t\"zh\": \"ECS 预付费实例到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid instances should have auto-renewal enabled to avoid service interruption due to expiration.\",\n\t\t\"zh\": \"预付费实例应开启自动续费，避免出现因费用问题停机。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid ECS instance does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 ECS 实例未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid ECS instance by setting AutoRenew to true.\",\n\t\t\"zh\": \"通过将 AutoRenew 设置为 true 为预付费 ECS 实例开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\"],\n}\n\n# Check if instance is Prepaid\nis_prepaid(resource) if {\n\t# Check InstanceChargeType\n\tcharge_type := helpers.get_property(resource, \"InstanceChargeType\", \"PostPaid\")\n\tcharge_type == \"PrePaid\"\n}\n\n# Check if AutoRenew is enabled\nis_auto_renew_enabled(resource) if {\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", false)\n\thelpers.is_true(auto_renew)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-image-expired-check", Name: models.I18nString{"en": "ECS Instance Image Expired Check", "zh": "ECS 实例镜像过期检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the image used by the ECS instance has not expired.", "zh": "确保 ECS 实例使用的镜像未过期。"}, Reason: models.I18nString{"en": "Using an expired image may lead to security vulnerabilities and lack of support.", "zh": "使用过期的镜像可能导致安全漏洞和缺乏技术支持。"}, Recommendation: models.I18nString{"en": "Update the ECS instance to use a supported, non-expired image.", "zh": "更新 ECS 实例以使用受支持、未过期的镜像。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-image-expired-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_image_expired_check", Content: "package infraguard.rules.aliyun.ecs_instance_image_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-instance-image-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Image Expired Check\",\n\t\t\"zh\": \"ECS 实例镜像过期检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the image used by the ECS instance has not expired.\",\n\t\t\"zh\": \"确保 ECS 实例使用的镜像未过期。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using an expired image may lead to security vulnerabilities and lack of support.\",\n\t\t\"zh\": \"使用过期的镜像可能导致安全漏洞和缺乏技术支持。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Update the ECS instance to use a supported, non-expired image.\",\n\t\t\"zh\": \"更新 ECS 实例以使用受支持、未过期的镜像。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Conceptual check\n\thelpers.has_property(resource, \"ImageId\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-image-type-check", Name: models.I18nString{"en": "ECS Instance Image Type Check", "zh": "ECS 实例镜像来源核查"}, Severity: "medium", Description: models.I18nString{"en": "Ensures ECS instances use images from authorized sources.", "zh": "确保 ECS 实例使用来自授权来源的镜像。"}, Reason: models.I18nString{"en": "Using untrusted image sources can introduce security vulnerabilities or malware.", "zh": "使用未经信任的镜像来源可能会引入安全漏洞或恶意软件。"}, Recommendation: models.I18nString{"en": "Specify an authorized ImageId for the ECS instance.", "zh": "为 ECS 实例指定授权的镜像 ID。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-image-type-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_image_type_check", Content: "package infraguard.rules.aliyun.ecs_instance_image_type_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-instance-image-type-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Image Type Check\",\n\t\t\"zh\": \"ECS 实例镜像来源核查\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS instances use images from authorized sources.\",\n\t\t\"zh\": \"确保 ECS 实例使用来自授权来源的镜像。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using untrusted image sources can introduce security vulnerabilities or malware.\",\n\t\t\"zh\": \"使用未经信任的镜像来源可能会引入安全漏洞或恶意软件。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Specify an authorized ImageId for the ECS instance.\",\n\t\t\"zh\": \"为 ECS 实例指定授权的镜像 ID。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\t# In ROS, we usually check if ImageId is set.\n\t# Complex source checking often requires runtime tags, but we ensure ImageId is present.\n\thelpers.has_property(resource, \"ImageId\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-login-use-keypair", Name: models.I18nString{"en": "ECS Instance Login Using Key Pair", "zh": "ECS 实例登录使用密钥对"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that ECS instances use key pairs for login instead of passwords.", "zh": "确保 ECS 实例使用密钥对进行登录，而不是密码。"}, Reason: models.I18nString{"en": "Key pair login is more secure than password login.", "zh": "密钥对登录比密码登录更安全。"}, Recommendation: models.I18nString{"en": "Configure key pair login for the ECS instance and disable password login.", "zh": "为 ECS 实例配置密钥对登录，并禁用密码登录。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-login-use-keypair.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_login_use_keypair", Content: "package infraguard.rules.aliyun.ecs_instance_login_use_keypair\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-instance-login-use-keypair\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Login Using Key Pair\",\n\t\t\"zh\": \"ECS 实例登录使用密钥对\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS instances use key pairs for login instead of passwords.\",\n\t\t\"zh\": \"确保 ECS 实例使用密钥对进行登录，而不是密码。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Key pair login is more secure than password login.\",\n\t\t\"zh\": \"密钥对登录比密码登录更安全。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure key pair login for the ECS instance and disable password login.\",\n\t\t\"zh\": \"为 ECS 实例配置密钥对登录，并禁用密码登录。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot helpers.has_property(resource, \"KeyPairName\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"KeyPairName\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-meta-data-mode-check", Name: models.I18nString{"en": "ECS instance metadata access uses security-enhanced mode (IMDSv2)", "zh": "访问 ECS 实例元数据时强制使用加固模式"}, Severity: "medium", Description: models.I18nString{"en": "When accessing ECS instance metadata, security-enhanced mode (IMDSv2) is enforced, considered compliant. Instances associated with ACK clusters are not applicable.", "zh": "访问 ECS 实例元数据时强制使用加固模式，视为合规。ACK 集群关联的实例视为不适用。"}, Reason: models.I18nString{"en": "ECS instance metadata is accessible without security-enhanced mode (IMDSv1)", "zh": "ECS 实例元数据可在未启用加固模式(IMDSv1)的情况下访问"}, Recommendation: models.I18nString{"en": "Set HttpEndpoint to 'enabled' and HttpTokens to 'required' to enforce IMDSv2", "zh": "将 HttpEndpoint 设置为 'enabled'，并将 HttpTokens 设置为 'required' 以强制使用 IMDSv2"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-meta-data-mode-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_meta_data_mode_check", Content: "package infraguard.rules.aliyun.ecs_instance_meta_data_mode_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-meta-data-mode-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS instance metadata access uses security-enhanced mode (IMDSv2)\",\n\t\t\"zh\": \"访问 ECS 实例元数据时强制使用加固模式\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"When accessing ECS instance metadata, security-enhanced mode (IMDSv2) is enforced, considered compliant. Instances associated with ACK clusters are not applicable.\",\n\t\t\"zh\": \"访问 ECS 实例元数据时强制使用加固模式，视为合规。ACK 集群关联的实例视为不适用。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS instance metadata is accessible without security-enhanced mode (IMDSv1)\",\n\t\t\"zh\": \"ECS 实例元数据可在未启用加固模式(IMDSv1)的情况下访问\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set HttpEndpoint to 'enabled' and HttpTokens to 'required' to enforce IMDSv2\",\n\t\t\"zh\": \"将 HttpEndpoint 设置为 'enabled'，并将 HttpTokens 设置为 'required' 以强制使用 IMDSv2\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Check if metadata endpoint is enabled\n\thttp_endpoint := helpers.get_property(resource, \"HttpEndpoint\", \"enabled\")\n\n\t# If endpoint is disabled, metadata access is not possible\n\thttp_endpoint == \"disabled\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HttpEndpoint\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# If endpoint is not disabled, check if tokens are required (IMDSv2)\n\thttp_endpoint := helpers.get_property(resource, \"HttpEndpoint\", \"enabled\")\n\thttp_endpoint != \"disabled\"\n\n\thttp_tokens := helpers.get_property(resource, \"HttpTokens\", \"optional\")\n\thttp_tokens == \"optional\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HttpTokens\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-multiple-eni-check", Name: models.I18nString{"en": "ECS instance is bound to only one elastic network interface", "zh": "ECS 实例仅绑定一个弹性网卡"}, Severity: "low", Description: models.I18nString{"en": "ECS instances are bound to only one elastic network interface, considered compliant. This helps simplify network configuration and reduce complexity.", "zh": "ECS 实例仅绑定一个弹性网卡，视为合规。这有助于简化网络配置并减少复杂性。"}, Reason: models.I18nString{"en": "ECS instance is bound to multiple elastic network interfaces", "zh": "ECS 实例绑定了多个弹性网卡"}, Recommendation: models.I18nString{"en": "Simplify instance network configuration by using only one ENI", "zh": "通过仅使用一个 ENI 来简化实例网络配置"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-multiple-eni-check.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_multiple_eni_check", Content: "package infraguard.rules.aliyun.ecs_instance_multiple_eni_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-multiple-eni-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS instance is bound to only one elastic network interface\",\n\t\t\"zh\": \"ECS 实例仅绑定一个弹性网卡\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS instances are bound to only one elastic network interface, considered compliant. This helps simplify network configuration and reduce complexity.\",\n\t\t\"zh\": \"ECS 实例仅绑定一个弹性网卡，视为合规。这有助于简化网络配置并减少复杂性。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS instance is bound to multiple elastic network interfaces\",\n\t\t\"zh\": \"ECS 实例绑定了多个弹性网卡\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Simplify instance network configuration by using only one ENI\",\n\t\t\"zh\": \"通过仅使用一个 ENI 来简化实例网络配置\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Check if NetworkInterfaces is specified with multiple ENIs\n\tnetwork_interfaces := helpers.get_property(resource, \"NetworkInterfaces\", [])\n\tcount(network_interfaces) > 1\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NetworkInterfaces\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Count NetworkInterfaceAttachment resources that reference this instance\n\tattachment_count := count([att_name |\n\t\tsome att_name, att_resource in helpers.resources_by_type(\"ALIYUN::ECS::NetworkInterfaceAttachment\")\n\t\tinstance_id := helpers.get_property(att_resource, \"InstanceId\", \"\")\n\t\thelpers.is_referencing(instance_id, name)\n\t])\n\n\t# If more than one attachment references this instance, it's a violation\n\tattachment_count > 1\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Count NetworkInterfaceAttachment resources that reference this instance via GetAtt\n\tattachment_count := count([att_name |\n\t\tsome att_name, att_resource in helpers.resources_by_type(\"ALIYUN::ECS::NetworkInterfaceAttachment\")\n\t\tinstance_id := helpers.get_property(att_resource, \"InstanceId\", \"\")\n\t\thelpers.is_get_att_referencing(instance_id, name)\n\t])\n\n\t# If more than one attachment references this instance, it's a violation\n\tattachment_count > 1\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-no-public-and-anyip", Name: models.I18nString{"en": "ECS Instance Should Not Bind Public IP or Allow Any IP Access", "zh": "ECS 实例禁止绑定公网地址和开放任意 ip"}, Severity: "medium", Description: models.I18nString{"en": "ECS instances should not directly bind IPv4 public IPs or Elastic IPs, and associated security groups should not expose 0.0.0.0/0. Compliant when no public IP is bound.", "zh": "ECS 实例没有直接绑定 IPv4 公网 IP 或弹性公网 IP，或关联的安全组未开放 0.0.0.0/0，视为合规。"}, Reason: models.I18nString{"en": "ECS instance has public IP allocation enabled or uses unrestricted internet bandwidth", "zh": "ECS 实例启用了公网 IP 分配或使用了不受限制的互联网带宽"}, Recommendation: models.I18nString{"en": "Disable public IP allocation (AllocatePublicIP=false) and set InternetMaxBandwidthOut to 0. Use NAT Gateway or SLB for internet access instead.", "zh": "禁用公网 IP 分配(AllocatePublicIP=false)并将 InternetMaxBandwidthOut 设置为 0。改用 NAT 网关或 SLB 进行互联网访问。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-no-public-and-anyip.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_no_public_and_anyip", Content: "package infraguard.rules.aliyun.ecs_instance_no_public_and_anyip\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-no-public-and-anyip\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Should Not Bind Public IP or Allow Any IP Access\",\n\t\t\"zh\": \"ECS 实例禁止绑定公网地址和开放任意 ip\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS instances should not directly bind IPv4 public IPs or Elastic IPs, and associated security groups should not expose 0.0.0.0/0. Compliant when no public IP is bound.\",\n\t\t\"zh\": \"ECS 实例没有直接绑定 IPv4 公网 IP 或弹性公网 IP，或关联的安全组未开放 0.0.0.0/0，视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS instance has public IP allocation enabled or uses unrestricted internet bandwidth\",\n\t\t\"zh\": \"ECS 实例启用了公网 IP 分配或使用了不受限制的互联网带宽\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public IP allocation (AllocatePublicIP=false) and set InternetMaxBandwidthOut to 0. Use NAT Gateway or SLB for internet access instead.\",\n\t\t\"zh\": \"禁用公网 IP 分配(AllocatePublicIP=false)并将 InternetMaxBandwidthOut 设置为 0。改用 NAT 网关或 SLB 进行互联网访问。\",\n\t},\n}\n\n# Check if instance has public IP allocated\nhas_public_ip(resource) if {\n\tprint(\"public_ip\", helpers.get_property(resource, \"AllocatePublicIP\", false))\n\thelpers.get_property(resource, \"AllocatePublicIP\", false) == true\n}\n\n# Check if instance has internet bandwidth (which implies public IP access)\nhas_internet_bandwidth(resource) if {\n\thelpers.has_property(resource, \"InternetMaxBandwidthOut\")\n\tresource.Properties.InternetMaxBandwidthOut > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\thas_public_ip(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AllocatePublicIP\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\thas_internet_bandwidth(resource)\n\tnot has_public_ip(resource) # Only report if not already reported by AllocatePublicIP check\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetMaxBandwidthOut\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-no-public-ip", Name: models.I18nString{"en": "ECS instance should not bind public IP", "zh": "ECS 实例禁止绑定公网地址"}, Severity: "high", Description: models.I18nString{"en": "ECS instances should not directly bind IPv4 public IP or Elastic IP, considered compliant.", "zh": "ECS 实例没有直接绑定 IPv4 公网 IP 或弹性公网 IP，视为合规。"}, Reason: models.I18nString{"en": "ECS instance has a public IP bound", "zh": "ECS 实例绑定了公网地址"}, Recommendation: models.I18nString{"en": "Use NAT Gateway or SLB for internet access instead of direct public IP binding", "zh": "使用 NAT 网关或 SLB 进行互联网访问，而不是直接绑定公网 IP"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-no-public-ip.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_no_public_ip", Content: "package infraguard.rules.aliyun.ecs_instance_no_public_ip\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instance-no-public-ip\",\n\t\"name\": {\n\t\t\"en\": \"ECS instance should not bind public IP\",\n\t\t\"zh\": \"ECS 实例禁止绑定公网地址\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS instances should not directly bind IPv4 public IP or Elastic IP, considered compliant.\",\n\t\t\"zh\": \"ECS 实例没有直接绑定 IPv4 公网 IP 或弹性公网 IP，视为合规。\",\n\t},\n\t\"severity\": \"high\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS instance has a public IP bound\",\n\t\t\"zh\": \"ECS 实例绑定了公网地址\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use NAT Gateway or SLB for internet access instead of direct public IP binding\",\n\t\t\"zh\": \"使用 NAT 网关或 SLB 进行互联网访问，而不是直接绑定公网 IP\",\n\t},\n}\n\n# Check if instance allocates public IP\nallocates_public_ip(resource) if {\n\thelpers.get_property(resource, \"AllocatePublicIP\", false) == true\n}\n\n# Check if instance has internet bandwidth (which may result in public IP)\nhas_internet_bandwidth(resource) if {\n\thelpers.has_property(resource, \"InternetMaxBandwidthOut\")\n\tresource.Properties.InternetMaxBandwidthOut > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tallocates_public_ip(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AllocatePublicIP\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\thas_internet_bandwidth(resource)\n\tnot allocates_public_ip(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetMaxBandwidthOut\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Check if instance is referenced by EIPAssociation via Ref\n\tsome eip_name, eip_resource in helpers.resources_by_type(\"ALIYUN::VPC::EIPAssociation\")\n\tinstance_id := helpers.get_property(eip_resource, \"InstanceId\", \"\")\n\thelpers.is_referencing(instance_id, name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Check if instance is referenced by EIPAssociation via GetAtt\n\tsome eip_name, eip_resource in helpers.resources_by_type(\"ALIYUN::VPC::EIPAssociation\")\n\tinstance_id := helpers.get_property(eip_resource, \"InstanceId\", \"\")\n\thelpers.is_get_att_referencing(instance_id, name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-not-bind-key-pair", Name: models.I18nString{"en": "ECS Instance Not Bound to Key Pair", "zh": "ECS 实例未绑定密钥对检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that ECS instances use key pairs for authentication instead of passwords.", "zh": "确保 ECS 实例使用密钥对进行身份验证，而不是密码。"}, Reason: models.I18nString{"en": "Key pair authentication is more secure than password authentication.", "zh": "密钥对身份验证比密码身份验证更安全。"}, Recommendation: models.I18nString{"en": "Bind a key pair to the ECS instance and disable password authentication.", "zh": "为 ECS 实例绑定密钥对，并禁用密码身份验证。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-not-bind-key-pair.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_not_bind_key_pair", Content: "package infraguard.rules.aliyun.ecs_instance_not_bind_key_pair\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-instance-not-bind-key-pair\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Not Bound to Key Pair\",\n\t\t\"zh\": \"ECS 实例未绑定密钥对检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS instances use key pairs for authentication instead of passwords.\",\n\t\t\"zh\": \"确保 ECS 实例使用密钥对进行身份验证，而不是密码。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Key pair authentication is more secure than password authentication.\",\n\t\t\"zh\": \"密钥对身份验证比密码身份验证更安全。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Bind a key pair to the ECS instance and disable password authentication.\",\n\t\t\"zh\": \"为 ECS 实例绑定密钥对，并禁用密码身份验证。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot helpers.has_property(resource, \"KeyPairName\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"KeyPairName\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-ram-role-attached", Name: models.I18nString{"en": "ECS Instance RAM Role Attached", "zh": "ECS 实例被授予实例 RAM 角色"}, Severity: "low", Description: models.I18nString{"en": "Ensures that ECS instances have an IAM role attached for secure access to other cloud services.", "zh": "确保 ECS 实例被授予了实例 RAM 角色，以便安全地访问其他云服务。"}, Reason: models.I18nString{"en": "Using RAM roles instead of hardcoded AccessKeys improves security by providing temporary credentials.", "zh": "使用 RAM 角色代替硬编码的 AccessKey，通过提供临时凭证来提高安全性。"}, Recommendation: models.I18nString{"en": "Attach a RAM role to the ECS instance.", "zh": "为 ECS 实例授予 RAM 角色。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-ram-role-attached.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_ram_role_attached", Content: "package infraguard.rules.aliyun.ecs_instance_ram_role_attached\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ecs-instance-ram-role-attached\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance RAM Role Attached\",\n\t\t\"zh\": \"ECS 实例被授予实例 RAM 角色\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ECS instances have an IAM role attached for secure access to other cloud services.\",\n\t\t\"zh\": \"确保 ECS 实例被授予了实例 RAM 角色，以便安全地访问其他云服务。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using RAM roles instead of hardcoded AccessKeys improves security by providing temporary credentials.\",\n\t\t\"zh\": \"使用 RAM 角色代替硬编码的 AccessKey，通过提供临时凭证来提高安全性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach a RAM role to the ECS instance.\",\n\t\t\"zh\": \"为 ECS 实例授予 RAM 角色。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\n# Check if instance has RAM role attached\nhas_ram_role(resource) if {\n\thelpers.has_property(resource, \"RamRoleName\")\n\trole := resource.Properties.RamRoleName\n\trole != \"\"\n}\n\n# Deny rule: ECS instances should have RAM role attached\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\tnot has_ram_role(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RamRoleName\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instance-type-family-not-deprecated", Name: models.I18nString{"en": "ECS Instance Type Not Deprecated", "zh": "ECS 弃用规格族预警"}, Severity: "medium", Description: models.I18nString{"en": "Ensures ECS instances do not use deprecated or legacy instance types.", "zh": "确保 ECS 实例未使用已弃用或陈旧的规格类型。"}, Reason: models.I18nString{"en": "Legacy instance types may have lower performance and limited future availability.", "zh": "陈旧的实例类型可能性能较低，且未来的可用性受限。"}, Recommendation: models.I18nString{"en": "Move to newer generation instance types (e.g., g6, c6, r6).", "zh": "迁移至新一代实例规格（如 g6, c6, r6）。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instance-type-family-not-deprecated.rego", PackageName: "infraguard.rules.aliyun.ecs_instance_type_family_not_deprecated", Content: "package infraguard.rules.aliyun.ecs_instance_type_family_not_deprecated\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-instance-type-family-not-deprecated\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance Type Not Deprecated\",\n\t\t\"zh\": \"ECS 弃用规格族预警\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS instances do not use deprecated or legacy instance types.\",\n\t\t\"zh\": \"确保 ECS 实例未使用已弃用或陈旧的规格类型。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Legacy instance types may have lower performance and limited future availability.\",\n\t\t\"zh\": \"陈旧的实例类型可能性能较低，且未来的可用性受限。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Move to newer generation instance types (e.g., g6, c6, r6).\",\n\t\t\"zh\": \"迁移至新一代实例规格（如 g6, c6, r6）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\ndeprecated_prefixes := [\"ecs.t1.\", \"ecs.s1.\", \"ecs.m1.\", \"ecs.c1.\", \"ecs.n1.\"]\n\nis_compliant(resource) if {\n\ttype := helpers.get_property(resource, \"InstanceType\", \"\")\n\tnot is_deprecated(type)\n}\n\nis_deprecated(type) if {\n\tsome prefix in deprecated_prefixes\n\tstartswith(type, prefix)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InstanceType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-instances-in-vpc", Name: models.I18nString{"en": "ECS Instances in VPC", "zh": "使用专有网络类型的 ECS 实例"}, Severity: "medium", Description: models.I18nString{"en": "ECS instances should be deployed in VPC (Virtual Private Cloud) networks rather than classic networks. VPC provides better network isolation, security, and flexibility.", "zh": "ECS 实例应部署在专有网络(VPC)而非经典网络中。VPC 提供更好的网络隔离、安全性和灵活性。"}, Reason: models.I18nString{"en": "The ECS instance is not deployed in a VPC, which may result in insufficient network isolation and security.", "zh": "ECS 实例未部署在 VPC 中，可能导致网络隔离和安全性不足。"}, Recommendation: models.I18nString{"en": "Deploy the ECS instance in a VPC by specifying the VpcId and VSwitchId properties.", "zh": "通过指定 VpcId 和 VSwitchId 属性，将 ECS 实例部署在 VPC 中。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-instances-in-vpc.rego", PackageName: "infraguard.rules.aliyun.ecs_instances_in_vpc", Content: "package infraguard.rules.aliyun.ecs_instances_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-instances-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instances in VPC\",\n\t\t\"zh\": \"使用专有网络类型的 ECS 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ECS instances should be deployed in VPC (Virtual Private Cloud) networks rather than classic networks. VPC provides better network isolation, security, and flexibility.\",\n\t\t\"zh\": \"ECS 实例应部署在专有网络(VPC)而非经典网络中。VPC 提供更好的网络隔离、安全性和灵活性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ECS instance is not deployed in a VPC, which may result in insufficient network isolation and security.\",\n\t\t\"zh\": \"ECS 实例未部署在 VPC 中，可能导致网络隔离和安全性不足。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy the ECS instance in a VPC by specifying the VpcId and VSwitchId properties.\",\n\t\t\"zh\": \"通过指定 VpcId 和 VSwitchId 属性，将 ECS 实例部署在 VPC 中。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types({\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"})\n\tnot is_in_vpc(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nis_in_vpc(resource) if {\n\thelpers.has_property(resource, \"VpcId\")\n\thelpers.has_property(resource, \"VSwitchId\")\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-internet-charge-type-check", Name: models.I18nString{"en": "ECS Internet Charge Type Check", "zh": "ECS 公网带宽计费方式核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ECS instances use the preferred internet charge type.", "zh": "确保 ECS 实例使用首选的公网带宽计费方式。"}, Reason: models.I18nString{"en": "Consistent charge types help in predictable billing and cost management.", "zh": "一致的计费方式有助于实现可预测的账单和成本管理。"}, Recommendation: models.I18nString{"en": "Set InternetChargeType to 'PayByTraffic'.", "zh": "将 InternetChargeType 设置为'PayByTraffic'。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-internet-charge-type-check.rego", PackageName: "infraguard.rules.aliyun.ecs_internet_charge_type_check", Content: "package infraguard.rules.aliyun.ecs_internet_charge_type_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-internet-charge-type-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Internet Charge Type Check\",\n\t\t\"zh\": \"ECS 公网带宽计费方式核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS instances use the preferred internet charge type.\",\n\t\t\"zh\": \"确保 ECS 实例使用首选的公网带宽计费方式。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Consistent charge types help in predictable billing and cost management.\",\n\t\t\"zh\": \"一致的计费方式有助于实现可预测的账单和成本管理。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set InternetChargeType to 'PayByTraffic'.\",\n\t\t\"zh\": \"将 InternetChargeType 设置为'PayByTraffic'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\tcharge_type := helpers.get_property(resource, \"InternetChargeType\", \"PayByTraffic\")\n\tcharge_type == \"PayByTraffic\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetChargeType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-internetmaxbandwidth-check", Name: models.I18nString{"en": "ECS Internet Max Bandwidth Check", "zh": "ECS 公网出口带宽检查"}, Severity: "medium", Description: models.I18nString{"en": "Ensures ECS internet outbound bandwidth does not exceed specified limits.", "zh": "确保 ECS 公网出口带宽不超过指定限制。"}, Reason: models.I18nString{"en": "High bandwidth settings can lead to unexpected costs and increased attack surface.", "zh": "高带宽设置可能导致意外成本增加并扩大攻击面。"}, Recommendation: models.I18nString{"en": "Limit the InternetMaxBandwidthOut to a reasonable value (e.g., 100Mbps).", "zh": "将 InternetMaxBandwidthOut 限制在合理范围内（例如 100Mbps）。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-internetmaxbandwidth-check.rego", PackageName: "infraguard.rules.aliyun.ecs_internetmaxbandwidth_check", Content: "package infraguard.rules.aliyun.ecs_internetmaxbandwidth_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-internetmaxbandwidth-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS Internet Max Bandwidth Check\",\n\t\t\"zh\": \"ECS 公网出口带宽检查\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS internet outbound bandwidth does not exceed specified limits.\",\n\t\t\"zh\": \"确保 ECS 公网出口带宽不超过指定限制。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"High bandwidth settings can lead to unexpected costs and increased attack surface.\",\n\t\t\"zh\": \"高带宽设置可能导致意外成本增加并扩大攻击面。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Limit the InternetMaxBandwidthOut to a reasonable value (e.g., 100Mbps).\",\n\t\t\"zh\": \"将 InternetMaxBandwidthOut 限制在合理范围内（例如 100Mbps）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\tbandwidth := helpers.get_property(resource, \"InternetMaxBandwidthOut\", 1)\n\tbandwidth <= 100\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetMaxBandwidthOut\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-launch-template-network-type-check", Name: models.I18nString{"en": "ECS launch template uses VPC network type", "zh": "ECS 启动模版配置不应设置公网访问"}, Severity: "medium", Description: models.I18nString{"en": "ECS launch template versions have network type set to VPC, considered compliant. Classic network type is not recommended for production environments.", "zh": "ECS 启动模版版本中网络类型为 VPC 类型，视为合规。"}, Reason: models.I18nString{"en": "ECS launch template is configured with classic network type", "zh": "ECS 启动模板配置了经典网络类型"}, Recommendation: models.I18nString{"en": "Use VPC network type in launch templates for better network isolation", "zh": "在启动模板中使用 VPC 网络类型以获得更好的网络隔离"}, ResourceTypes: []string{"ALIYUN::ECS::LaunchTemplate"}, FilePath: "aliyun/rules/ecs-launch-template-network-type-check.rego", PackageName: "infraguard.rules.aliyun.ecs_launch_template_network_type_check", Content: "package infraguard.rules.aliyun.ecs_launch_template_network_type_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-launch-template-network-type-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS launch template uses VPC network type\",\n\t\t\"zh\": \"ECS 启动模版配置不应设置公网访问\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS launch template versions have network type set to VPC, considered compliant. Classic network type is not recommended for production environments.\",\n\t\t\"zh\": \"ECS 启动模版版本中网络类型为 VPC 类型，视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::LaunchTemplate\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS launch template is configured with classic network type\",\n\t\t\"zh\": \"ECS 启动模板配置了经典网络类型\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use VPC network type in launch templates for better network isolation\",\n\t\t\"zh\": \"在启动模板中使用 VPC 网络类型以获得更好的网络隔离\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::LaunchTemplate\")\n\n\t# Check network type\n\tnetwork_type := helpers.get_property(resource, \"NetworkType\", \"\")\n\n\t# Classic network is not recommended\n\tnetwork_type == \"classic\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NetworkType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-launch-template-version-attach-security-group", Name: models.I18nString{"en": "ECS launch template version attaches security groups", "zh": "ECS 启动模版版本中设置加入的安全组"}, Severity: "high", Description: models.I18nString{"en": "ECS launch template versions have security groups configured for instances, considered compliant.", "zh": "ECS 启动模版版本中设置了实例要加入的安全组，视为合规。"}, Reason: models.I18nString{"en": "ECS launch template version does not have security groups configured", "zh": "ECS 启动模板版本未配置安全组"}, Recommendation: models.I18nString{"en": "Configure security groups in launch template versions for instance network security", "zh": "在启动模板版本中配置安全组以确保实例网络安全"}, ResourceTypes: []string{"ALIYUN::ECS::LaunchTemplate"}, FilePath: "aliyun/rules/ecs-launch-template-version-attach-security-group.rego", PackageName: "infraguard.rules.aliyun.ecs_launch_template_version_attach_security_group", Content: "package infraguard.rules.aliyun.ecs_launch_template_version_attach_security_group\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-launch-template-version-attach-security-group\",\n\t\"name\": {\n\t\t\"en\": \"ECS launch template version attaches security groups\",\n\t\t\"zh\": \"ECS 启动模版版本中设置加入的安全组\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS launch template versions have security groups configured for instances, considered compliant.\",\n\t\t\"zh\": \"ECS 启动模版版本中设置了实例要加入的安全组，视为合规。\",\n\t},\n\t\"severity\": \"high\",\n\t\"resource_types\": [\"ALIYUN::ECS::LaunchTemplate\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS launch template version does not have security groups configured\",\n\t\t\"zh\": \"ECS 启动模板版本未配置安全组\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure security groups in launch template versions for instance network security\",\n\t\t\"zh\": \"在启动模板版本中配置安全组以确保实例网络安全\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::LaunchTemplate\")\n\n\t# Check if security group is configured\n\tsecurity_group_id := helpers.get_property(resource, \"SecurityGroupId\", \"\")\n\tsecurity_group_ids := helpers.get_property(resource, \"SecurityGroupIds\", [])\n\n\t# Neither SecurityGroupId nor SecurityGroupIds is specified\n\tsecurity_group_id == \"\"\n\tcount(security_group_ids) == 0\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-launch-template-version-data-disk-encrypted", Name: models.I18nString{"en": "ECS launch template version enables data disk encryption", "zh": "ECS 启动模版版本中设置数据磁盘加密"}, Severity: "medium", Description: models.I18nString{"en": "All data disks configured in ECS launch template versions are encrypted, considered compliant.", "zh": "ECS 启动模版版本中数据磁盘配置均设置为加密，视为合规。"}, Reason: models.I18nString{"en": "ECS launch template version has data disks without encryption enabled", "zh": "ECS 启动模板版本的数据磁盘未启用加密"}, Recommendation: models.I18nString{"en": "Enable encryption for all data disks in launch template versions", "zh": "在启动模板版本中为所有数据磁盘启用加密"}, ResourceTypes: []string{"ALIYUN::ECS::LaunchTemplate"}, FilePath: "aliyun/rules/ecs-launch-template-version-data-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ecs_launch_template_version_data_disk_encrypted", Content: "package infraguard.rules.aliyun.ecs_launch_template_version_data_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-launch-template-version-data-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ECS launch template version enables data disk encryption\",\n\t\t\"zh\": \"ECS 启动模版版本中设置数据磁盘加密\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"All data disks configured in ECS launch template versions are encrypted, considered compliant.\",\n\t\t\"zh\": \"ECS 启动模版版本中数据磁盘配置均设置为加密，视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::LaunchTemplate\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS launch template version has data disks without encryption enabled\",\n\t\t\"zh\": \"ECS 启动模板版本的数据磁盘未启用加密\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for all data disks in launch template versions\",\n\t\t\"zh\": \"在启动模板版本中为所有数据磁盘启用加密\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in input.Resources\n\tresource.Type == \"ALIYUN::ECS::LaunchTemplate\"\n\tresource.Properties.DiskMappings != null\n\n\tsome disk in resource.Properties.DiskMappings\n\tdisk.Encrypted != true\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DiskMappings\", \"Encrypted\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-launch-template-version-image-type-check", Name: models.I18nString{"en": "Launch Template Image Type Check", "zh": "启动模板镜像来源核查"}, Severity: "medium", Description: models.I18nString{"en": "Ensures ECS launch templates use authorized image types.", "zh": "确保 ECS 启动模板使用授权的镜像类型。"}, Reason: models.I18nString{"en": "Restricting image sources in templates ensures consistent security baselines.", "zh": "在模板中限制镜像来源可确保一致的安全基线。"}, Recommendation: models.I18nString{"en": "Update the launch template to use authorized images.", "zh": "更新启动模板以使用授权镜像。"}, ResourceTypes: []string{"ALIYUN::ECS::LaunchTemplate"}, FilePath: "aliyun/rules/ecs-launch-template-version-image-type-check.rego", PackageName: "infraguard.rules.aliyun.ecs_launch_template_version_image_type_check", Content: "package infraguard.rules.aliyun.ecs_launch_template_version_image_type_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-launch-template-version-image-type-check\",\n\t\"name\": {\n\t\t\"en\": \"Launch Template Image Type Check\",\n\t\t\"zh\": \"启动模板镜像来源核查\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS launch templates use authorized image types.\",\n\t\t\"zh\": \"确保 ECS 启动模板使用授权的镜像类型。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Restricting image sources in templates ensures consistent security baselines.\",\n\t\t\"zh\": \"在模板中限制镜像来源可确保一致的安全基线。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Update the launch template to use authorized images.\",\n\t\t\"zh\": \"更新启动模板以使用授权镜像。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::LaunchTemplate\"],\n}\n\nis_compliant(resource) if {\n\t# Check ImageId directly in Properties\n\thelpers.get_property(resource, \"ImageId\", null) != null\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::LaunchTemplate\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-running-instance-no-public-ip", Name: models.I18nString{"en": "ECS Instance No Public IP", "zh": "ECS 实例不分配公网 IP"}, Severity: "high", Description: models.I18nString{"en": "ECS instances should not have a public IP address to reduce direct internet exposure.", "zh": "ECS 实例不应分配公网 IP，以减少直接暴露在互联网上的风险。"}, Reason: models.I18nString{"en": "Public IP addresses allow direct access from the internet, increasing the attack surface.", "zh": "分配公网 IP 会使实例直接暴露在互联网上，增加了攻击面。"}, Recommendation: models.I18nString{"en": "Remove public IP assignment by setting AllocatePublicIP to false or using a NAT gateway for egress.", "zh": "通过将 AllocatePublicIP 设置为 false 或使用 NAT 网关来取消分配公网 IP。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-running-instance-no-public-ip.rego", PackageName: "infraguard.rules.aliyun.ecs_running_instance_no_public_ip", Content: "package infraguard.rules.aliyun.ecs_running_instance_no_public_ip\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-running-instance-no-public-ip\",\n\t\"name\": {\n\t\t\"en\": \"ECS Instance No Public IP\",\n\t\t\"zh\": \"ECS 实例不分配公网 IP\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ECS instances should not have a public IP address to reduce direct internet exposure.\",\n\t\t\"zh\": \"ECS 实例不应分配公网 IP，以减少直接暴露在互联网上的风险。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public IP addresses allow direct access from the internet, increasing the attack surface.\",\n\t\t\"zh\": \"分配公网 IP 会使实例直接暴露在互联网上，增加了攻击面。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove public IP assignment by setting AllocatePublicIP to false or using a NAT gateway for egress.\",\n\t\t\"zh\": \"通过将 AllocatePublicIP 设置为 false 或使用 NAT 网关来取消分配公网 IP。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\n# Check if the instance has a public IP allocated\nhas_public_ip(resource) if {\n\thelpers.get_property(resource, \"AllocatePublicIP\", false) == true\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\thas_public_ip(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AllocatePublicIP\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-running-instances-in-vpc", Name: models.I18nString{"en": "Running ECS instances are in VPC", "zh": "运行中的 ECS 实例在专有网络"}, Severity: "medium", Description: models.I18nString{"en": "Running ECS instances are deployed in Virtual Private Cloud (VPC), considered compliant. This provides network isolation and enhanced security.", "zh": "阿里云推荐购买的 ECS 放在 VPC 里面。如果 ECS 有归属 VPC 则视为合规。"}, Reason: models.I18nString{"en": "ECS instance is not deployed in VPC (Classic network)", "zh": "ECS 实例未部署在专有网络（经典网络）"}, Recommendation: models.I18nString{"en": "Deploy ECS instances in VPC for network isolation and enhanced security", "zh": "将 ECS 实例部署在专有网络中以实现网络隔离和增强安全性"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-running-instances-in-vpc.rego", PackageName: "infraguard.rules.aliyun.ecs_running_instances_in_vpc", Content: "package infraguard.rules.aliyun.ecs_running_instances_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-running-instances-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"Running ECS instances are in VPC\",\n\t\t\"zh\": \"运行中的 ECS 实例在专有网络\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Running ECS instances are deployed in Virtual Private Cloud (VPC), considered compliant. This provides network isolation and enhanced security.\",\n\t\t\"zh\": \"阿里云推荐购买的 ECS 放在 VPC 里面。如果 ECS 有归属 VPC 则视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"ECS instance is not deployed in VPC (Classic network)\",\n\t\t\"zh\": \"ECS 实例未部署在专有网络（经典网络）\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy ECS instances in VPC for network isolation and enhanced security\",\n\t\t\"zh\": \"将 ECS 实例部署在专有网络中以实现网络隔离和增强安全性\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"])\n\n\t# Check if instance is in classic network (no VPC specified)\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvswitch_id := helpers.get_property(resource, \"VSwitchId\", \"\")\n\n\t# If neither VpcId nor VSwitchId is specified, it's classic network\n\tvpc_id == \"\"\n\tvswitch_id == \"\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-description-check", Name: models.I18nString{"en": "Security Group Description Not Empty", "zh": "安全组描述信息不能为空"}, Severity: "low", Description: models.I18nString{"en": "Security group description should not be empty. Having a description helps with management and auditing.", "zh": "安全组描述信息不为空，视为合规。"}, Reason: models.I18nString{"en": "The security group does not have a description, which makes it difficult to understand its purpose and manage it effectively.", "zh": "安全组没有描述信息，难以理解其用途并进行有效管理。"}, Recommendation: models.I18nString{"en": "Add a meaningful description to the security group using the Description property to explain its purpose and usage.", "zh": "使用 Description 属性为安全组添加有意义的描述，说明其用途和使用场景。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup"}, FilePath: "aliyun/rules/ecs-security-group-description-check.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_description_check", Content: "package infraguard.rules.aliyun.ecs_security_group_description_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-description-check\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Description Not Empty\",\n\t\t\"zh\": \"安全组描述信息不能为空\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Security group description should not be empty. Having a description helps with management and auditing.\",\n\t\t\"zh\": \"安全组描述信息不为空，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group does not have a description, which makes it difficult to understand its purpose and manage it effectively.\",\n\t\t\"zh\": \"安全组没有描述信息，难以理解其用途并进行有效管理。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add a meaningful description to the security group using the Description property to explain its purpose and usage.\",\n\t\t\"zh\": \"使用 Description 属性为安全组添加有意义的描述，说明其用途和使用场景。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\"],\n}\n\n# Check if security group has a non-empty description\nhas_description(resource) if {\n\thelpers.has_property(resource, \"Description\")\n\tresource.Properties.Description != \"\"\n}\n\n# Generate deny for non-compliant resources\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tnot has_description(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Description\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-egress-not-all-access", Name: models.I18nString{"en": "Security Group Egress Not Set to All Access", "zh": "安全组出方向未设置为全通"}, Severity: "high", Description: models.I18nString{"en": "Security group egress direction should not be set to allow all access (all protocols, all ports, all destinations).", "zh": "安全组出网方向未设置为全通，视为合规。"}, Reason: models.I18nString{"en": "The security group has an egress rule that allows all access (all protocols to all destinations), which poses a security risk.", "zh": "安全组有一条出网规则允许全通访问（所有协议到所有目标），存在安全风险。"}, Recommendation: models.I18nString{"en": "Restrict egress rules to specific protocols, ports, and destination IP ranges based on actual business requirements.", "zh": "根据实际业务需求，将出网规则限制为特定的协议、端口和目标 IP 范围。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupEgress", "ALIYUN::ECS::SecurityGroupEgresses"}, FilePath: "aliyun/rules/ecs-security-group-egress-not-all-access.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_egress_not_all_access", Content: "package infraguard.rules.aliyun.ecs_security_group_egress_not_all_access\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-egress-not-all-access\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Egress Not Set to All Access\",\n\t\t\"zh\": \"安全组出方向未设置为全通\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Security group egress direction should not be set to allow all access (all protocols, all ports, all destinations).\",\n\t\t\"zh\": \"安全组出网方向未设置为全通，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group has an egress rule that allows all access (all protocols to all destinations), which poses a security risk.\",\n\t\t\"zh\": \"安全组有一条出网规则允许全通访问（所有协议到所有目标），存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict egress rules to specific protocols, ports, and destination IP ranges based on actual business requirements.\",\n\t\t\"zh\": \"根据实际业务需求，将出网规则限制为特定的协议、端口和目标 IP 范围。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupEgress\", \"ALIYUN::ECS::SecurityGroupEgresses\"],\n}\n\n# Check if an egress rule allows all access\nis_all_access_egress(rule) if {\n\trule.IpProtocol == \"all\"\n\trule.PortRange == \"-1/-1\"\n\trule.DestCidrIp == \"0.0.0.0/0\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\nis_all_access_egress(rule) if {\n\trule.IpProtocol == \"all\"\n\trule.PortRange == \"-1/-1\"\n\trule.Ipv6DestCidrIp == \"::/0\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\n# Check SecurityGroup resource for egress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupEgress\n\tis_all_access_egress(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupEgress\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupEgress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupEgress\")\n\tprops := resource.Properties\n\tegress_rule := {\n\t\t\"IpProtocol\": props.IpProtocol,\n\t\t\"PortRange\": props.PortRange,\n\t\t\"DestCidrIp\": object.get(props, \"DestCidrIp\", \"\"),\n\t\t\"Ipv6DestCidrIp\": object.get(props, \"Ipv6DestCidrIp\", \"\"),\n\t\t\"Policy\": object.get(props, \"Policy\", \"accept\"),\n\t}\n\tis_all_access_egress(egress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupEgresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupEgresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tegress_rule := {\n\t\t\"IpProtocol\": perm.IpProtocol,\n\t\t\"PortRange\": perm.PortRange,\n\t\t\"DestCidrIp\": object.get(perm, \"DestCidrIp\", \"\"),\n\t\t\"Ipv6DestCidrIp\": object.get(perm, \"Ipv6DestCidrIp\", \"\"),\n\t\t\"Policy\": object.get(perm, \"Policy\", \"accept\"),\n\t}\n\tis_all_access_egress(egress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-not-internet-cidr-access", Name: models.I18nString{"en": "Security Group Ingress Source IP Not Include Public IP", "zh": "安全组入网设置允许的来源 IP 不包含公网 IP"}, Severity: "high", Description: models.I18nString{"en": "Security group ingress rules with accept policy should not have source IP containing public internet IPs.", "zh": "安全组入网方向授权策略为允许的来源 IP 地址段不包含公网 IP，视为合规。"}, Reason: models.I18nString{"en": "The security group has an ingress rule that allows access from public internet IP addresses, which may expose the resources to external attacks.", "zh": "安全组有一条入网规则允许从公网 IP 地址访问，可能将资源暴露给外部攻击。"}, Recommendation: models.I18nString{"en": "Restrict ingress source IP to private network ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) unless public internet access is explicitly required.", "zh": "将入网来源 IP 限制为私有网络范围（10.0.0.0/8、172.16.0.0/12、192.168.0.0/16），除非确实需要公网访问。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/ecs-security-group-not-internet-cidr-access.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_not_internet_cidr_access", Content: "package infraguard.rules.aliyun.ecs_security_group_not_internet_cidr_access\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-not-internet-cidr-access\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Ingress Source IP Not Include Public IP\",\n\t\t\"zh\": \"安全组入网设置允许的来源 IP 不包含公网 IP\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Security group ingress rules with accept policy should not have source IP containing public internet IPs.\",\n\t\t\"zh\": \"安全组入网方向授权策略为允许的来源 IP 地址段不包含公网 IP，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group has an ingress rule that allows access from public internet IP addresses, which may expose the resources to external attacks.\",\n\t\t\"zh\": \"安全组有一条入网规则允许从公网 IP 地址访问，可能将资源暴露给外部攻击。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict ingress source IP to private network ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) unless public internet access is explicitly required.\",\n\t\t\"zh\": \"将入网来源 IP 限制为私有网络范围（10.0.0.0/8、172.16.0.0/12、192.168.0.0/16），除非确实需要公网访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Check if a rule allows access from internet CIDR\nis_internet_source_rule(rule) if {\n\t# Source CIDR is a public internet IP\n\tcidr := rule.SourceCidrIp\n\tcidr != \"\"\n\thelpers.is_internet_cidr(cidr)\n\n\t# Policy is accept (default)\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_internet_source_rule(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10), \"SourceCidrIp\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tingress_rule := {\n\t\t\"SourceCidrIp\": object.get(props, \"SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(props, \"Policy\", \"accept\"),\n\t}\n\tis_internet_source_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SourceCidrIp\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tingress_rule := {\n\t\t\"SourceCidrIp\": object.get(perm, \"SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(perm, \"Policy\", \"accept\"),\n\t}\n\tis_internet_source_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10), \"SourceCidrIp\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-not-open-all-port", Name: models.I18nString{"en": "Security Group Ingress Not Open All Ports", "zh": "安全组入网设置中不能有对所有端口开放的访问规则"}, Severity: "high", Description: models.I18nString{"en": "Security group ingress rules should not allow all ports. When the port range is not set to -1/-1, it is considered compliant.", "zh": "安全组入方向授权策略为允许，当端口范围未设置为-1/-1 时，视为合规。如果端口范围设置为-1/-1，但被优先级更高的授权策略拒绝，视为合规。"}, Reason: models.I18nString{"en": "The security group has an ingress rule that allows all ports (PortRange=-1/-1), which poses a security risk by allowing access to any port.", "zh": "安全组有一条入网规则允许所有端口（PortRange=-1/-1），允许访问任何端口，存在安全风险。"}, Recommendation: models.I18nString{"en": "Restrict ingress rules to specific port ranges based on actual business requirements instead of using '-1/-1' (all ports).", "zh": "根据实际业务需求，将入网规则限制为特定的端口范围，而不是使用'-1/-1'（所有端口）。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/ecs-security-group-not-open-all-port.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_not_open_all_port", Content: "package infraguard.rules.aliyun.ecs_security_group_not_open_all_port\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-not-open-all-port\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Ingress Not Open All Ports\",\n\t\t\"zh\": \"安全组入网设置中不能有对所有端口开放的访问规则\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Security group ingress rules should not allow all ports. When the port range is not set to -1/-1, it is considered compliant.\",\n\t\t\"zh\": \"安全组入方向授权策略为允许，当端口范围未设置为-1/-1 时，视为合规。如果端口范围设置为-1/-1，但被优先级更高的授权策略拒绝，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group has an ingress rule that allows all ports (PortRange=-1/-1), which poses a security risk by allowing access to any port.\",\n\t\t\"zh\": \"安全组有一条入网规则允许所有端口（PortRange=-1/-1），允许访问任何端口，存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict ingress rules to specific port ranges based on actual business requirements instead of using '-1/-1' (all ports).\",\n\t\t\"zh\": \"根据实际业务需求，将入网规则限制为特定的端口范围，而不是使用'-1/-1'（所有端口）。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Check if an ingress rule allows all ports with accept policy\nis_all_port_accept(rule) if {\n\trule.PortRange == \"-1/-1\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_all_port_accept(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10), \"PortRange\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tis_all_port_accept(props)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"PortRange\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tis_all_port_accept(perm)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10), \"PortRange\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-not-open-all-protocol", Name: models.I18nString{"en": "Security Group Ingress Not Open All Protocols", "zh": "安全组入网设置不能有对所有协议开放的访问规则"}, Severity: "high", Description: models.I18nString{"en": "Security group ingress rules should not allow all protocols. When the protocol type is not set to ALL, it is considered compliant.", "zh": "安全组入方向授权策略为允许，当协议类型未设置为 ALL 时，视为合规。如果协议类型设置为 ALL，但被优先级更高的授权策略拒绝，视为合规。"}, Reason: models.I18nString{"en": "The security group has an ingress rule that allows all protocols (IpProtocol=all), which poses a security risk by allowing any type of network traffic.", "zh": "安全组有一条入网规则允许所有协议（IpProtocol=all），允许任何类型的网络流量，存在安全风险。"}, Recommendation: models.I18nString{"en": "Restrict ingress rules to specific protocols (tcp, udp, icmp) based on actual business requirements instead of using 'all'.", "zh": "根据实际业务需求，将入网规则限制为特定的协议（tcp、udp、icmp），而不是使用'all'。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/ecs-security-group-not-open-all-protocol.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_not_open_all_protocol", Content: "package infraguard.rules.aliyun.ecs_security_group_not_open_all_protocol\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-not-open-all-protocol\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Ingress Not Open All Protocols\",\n\t\t\"zh\": \"安全组入网设置不能有对所有协议开放的访问规则\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Security group ingress rules should not allow all protocols. When the protocol type is not set to ALL, it is considered compliant.\",\n\t\t\"zh\": \"安全组入方向授权策略为允许，当协议类型未设置为 ALL 时，视为合规。如果协议类型设置为 ALL，但被优先级更高的授权策略拒绝，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group has an ingress rule that allows all protocols (IpProtocol=all), which poses a security risk by allowing any type of network traffic.\",\n\t\t\"zh\": \"安全组有一条入网规则允许所有协议（IpProtocol=all），允许任何类型的网络流量，存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict ingress rules to specific protocols (tcp, udp, icmp) based on actual business requirements instead of using 'all'.\",\n\t\t\"zh\": \"根据实际业务需求，将入网规则限制为特定的协议（tcp、udp、icmp），而不是使用'all'。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Check if an ingress rule allows all protocols with accept policy\nis_all_protocol_accept(rule) if {\n\trule.IpProtocol == \"all\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_all_protocol_accept(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10), \"IpProtocol\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tis_all_protocol_accept(props)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"IpProtocol\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tis_all_protocol_accept(perm)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10), \"IpProtocol\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", Name: models.I18nString{"en": "Security Group Risky Ports Check with Protocol", "zh": "安全组指定协议不允许对全部网段开启风险端口"}, Severity: "high", Description: models.I18nString{"en": "When security group ingress source is set to 0.0.0.0/0, the port range should not include risky ports (22, 3389) for specified protocols (TCP/UDP), to reduce the risk of brute force attacks.", "zh": "当安全组入网网段设置为 0.0.0.0/0 时，指定协议的端口范围不包含指定风险端口，降低服务器登录密码被暴力破解风险，视为合规。默认检测风险端口为 22、3389。"}, Reason: models.I18nString{"en": "The security group allows access to risky ports (SSH:22, RDP:3389) from all sources (0.0.0.0/0), which increases the risk of brute force password attacks.", "zh": "安全组允许从所有来源（0.0.0.0/0）访问风险端口（SSH:22、RDP:3389），增加了暴力破解密码的风险。"}, Recommendation: models.I18nString{"en": "Restrict access to ports 22 (SSH) and 3389 (RDP) by limiting the source CIDR to specific trusted IP ranges instead of 0.0.0.0/0.", "zh": "限制对端口 22（SSH）和 3389（RDP）的访问，将来源 CIDR 限制为特定的可信 IP 范围，而不是 0.0.0.0/0。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/ecs-security-group-risky-ports-check-with-protocol.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_risky_ports_check_with_protocol", Content: "package infraguard.rules.aliyun.ecs_security_group_risky_ports_check_with_protocol\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-risky-ports-check-with-protocol\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Risky Ports Check with Protocol\",\n\t\t\"zh\": \"安全组指定协议不允许对全部网段开启风险端口\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"When security group ingress source is set to 0.0.0.0/0, the port range should not include risky ports (22, 3389) for specified protocols (TCP/UDP), to reduce the risk of brute force attacks.\",\n\t\t\"zh\": \"当安全组入网网段设置为 0.0.0.0/0 时，指定协议的端口范围不包含指定风险端口，降低服务器登录密码被暴力破解风险，视为合规。默认检测风险端口为 22、3389。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group allows access to risky ports (SSH:22, RDP:3389) from all sources (0.0.0.0/0), which increases the risk of brute force password attacks.\",\n\t\t\"zh\": \"安全组允许从所有来源（0.0.0.0/0）访问风险端口（SSH:22、RDP:3389），增加了暴力破解密码的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict access to ports 22 (SSH) and 3389 (RDP) by limiting the source CIDR to specific trusted IP ranges instead of 0.0.0.0/0.\",\n\t\t\"zh\": \"限制对端口 22（SSH）和 3389（RDP）的访问，将来源 CIDR 限制为特定的可信 IP 范围，而不是 0.0.0.0/0。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Risky ports that should not be exposed to all sources\nrisky_ports := [22, 3389]\n\n# Protocols to check (TCP and UDP are relevant for SSH and RDP)\nrisky_protocols := [\"tcp\", \"udp\"]\n\n# Check if a rule exposes risky ports from public sources\nis_risky_public_rule(rule) if {\n\t# Source is 0.0.0.0/0 (all IPv4)\n\trule.SourceCidrIp == \"0.0.0.0/0\"\n\n\t# Protocol is TCP, UDP, or ALL\n\tlower(rule.IpProtocol) in risky_protocols\n\n\t# Policy is accept (default)\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n\n\t# Check if any risky port is in the range\n\tsome port in risky_ports\n\thelpers.port_in_range(port, rule.PortRange)\n}\n\nis_risky_public_rule(rule) if {\n\t# Source is ::/0 (all IPv6)\n\trule.Ipv6SourceCidrIp == \"::/0\"\n\n\t# Protocol is TCP, UDP, or ALL\n\tlower(rule.IpProtocol) in risky_protocols\n\n\t# Policy is accept (default)\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n\n\t# Check if any risky port is in the range\n\tsome port in risky_ports\n\thelpers.port_in_range(port, rule.PortRange)\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_risky_public_rule(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tingress_rule := {\n\t\t\"IpProtocol\": props.IpProtocol,\n\t\t\"PortRange\": props.PortRange,\n\t\t\"SourceCidrIp\": object.get(props, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(props, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(props, \"Policy\", \"accept\"),\n\t}\n\tis_risky_public_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tingress_rule := {\n\t\t\"IpProtocol\": perm.IpProtocol,\n\t\t\"PortRange\": perm.PortRange,\n\t\t\"SourceCidrIp\": object.get(perm, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(perm, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(perm, \"Policy\", \"accept\"),\n\t}\n\tis_risky_public_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-type-not-normal", Name: models.I18nString{"en": "Use Enterprise Security Group Type", "zh": "使用企业类型安全组"}, Severity: "low", Description: models.I18nString{"en": "ECS security group type should not be normal type. Using enterprise security group is considered compliant.", "zh": "ECS 安全组类型非普通安全组，视为合规。"}, Reason: models.I18nString{"en": "The security group is using normal type instead of enterprise type, which may have limitations in functionality and performance.", "zh": "安全组使用了普通类型而非企业类型，可能在功能和性能上存在限制。"}, Recommendation: models.I18nString{"en": "Set SecurityGroupType property to 'enterprise' to use enterprise security group which provides better performance and more features.", "zh": "将 SecurityGroupType 属性设置为'enterprise'以使用企业安全组，获得更好的性能和更多功能。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup"}, FilePath: "aliyun/rules/ecs-security-group-type-not-normal.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_type_not_normal", Content: "package infraguard.rules.aliyun.ecs_security_group_type_not_normal\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-type-not-normal\",\n\t\"name\": {\n\t\t\"en\": \"Use Enterprise Security Group Type\",\n\t\t\"zh\": \"使用企业类型安全组\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"ECS security group type should not be normal type. Using enterprise security group is considered compliant.\",\n\t\t\"zh\": \"ECS 安全组类型非普通安全组，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group is using normal type instead of enterprise type, which may have limitations in functionality and performance.\",\n\t\t\"zh\": \"安全组使用了普通类型而非企业类型，可能在功能和性能上存在限制。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set SecurityGroupType property to 'enterprise' to use enterprise security group which provides better performance and more features.\",\n\t\t\"zh\": \"将 SecurityGroupType 属性设置为'enterprise'以使用企业安全组，获得更好的性能和更多功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\"],\n}\n\n# Check if security group uses enterprise type\nis_enterprise_type(resource) if {\n\tresource.Properties.SecurityGroupType == \"enterprise\"\n}\n\n# Generate deny for non-compliant resources (normal type or not specified)\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tnot is_enterprise_type(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-security-group-white-list-port-check", Name: models.I18nString{"en": "Security Group Non-Whitelist Port Ingress Check", "zh": "安全组非白名单端口入网设置有效"}, Severity: "high", Description: models.I18nString{"en": "Except for whitelisted ports (80), other ports should not have ingress rules allowing access from 0.0.0.0/0.", "zh": "除指定的白名单端口（80）外，其余端口不能有授权策略设置为允许而且来源为 0.0.0.0/0 的入方向规则，视为合规。"}, Reason: models.I18nString{"en": "The security group allows access to non-whitelisted ports from all sources (0.0.0.0/0), which may expose unnecessary services to the internet.", "zh": "安全组允许从所有来源（0.0.0.0/0）访问非白名单端口，可能将不必要的服务暴露到互联网。"}, Recommendation: models.I18nString{"en": "Only allow whitelisted ports (e.g., 80 for HTTP) to be accessible from 0.0.0.0/0. Restrict other ports to specific trusted source IP ranges.", "zh": "仅允许白名单端口（如 HTTP 的 80 端口）从 0.0.0.0/0 访问。将其他端口限制为特定的可信源 IP 范围。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/ecs-security-group-white-list-port-check.rego", PackageName: "infraguard.rules.aliyun.ecs_security_group_white_list_port_check", Content: "package infraguard.rules.aliyun.ecs_security_group_white_list_port_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"ecs-security-group-white-list-port-check\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Non-Whitelist Port Ingress Check\",\n\t\t\"zh\": \"安全组非白名单端口入网设置有效\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Except for whitelisted ports (80), other ports should not have ingress rules allowing access from 0.0.0.0/0.\",\n\t\t\"zh\": \"除指定的白名单端口（80）外，其余端口不能有授权策略设置为允许而且来源为 0.0.0.0/0 的入方向规则，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group allows access to non-whitelisted ports from all sources (0.0.0.0/0), which may expose unnecessary services to the internet.\",\n\t\t\"zh\": \"安全组允许从所有来源（0.0.0.0/0）访问非白名单端口，可能将不必要的服务暴露到互联网。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Only allow whitelisted ports (e.g., 80 for HTTP) to be accessible from 0.0.0.0/0. Restrict other ports to specific trusted source IP ranges.\",\n\t\t\"zh\": \"仅允许白名单端口（如 HTTP 的 80 端口）从 0.0.0.0/0 访问。将其他端口限制为特定的可信源 IP 范围。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Whitelisted ports that are allowed from 0.0.0.0/0\nwhitelist_ports := [80]\n\n# Check if a port range contains only whitelisted ports\nis_only_whitelist_ports(port_range) if {\n\t[start, end] := helpers.parse_port_range(port_range)\n\tstart == end\n\tsome port in whitelist_ports\n\tstart == port\n}\n\n# Check if a rule allows non-whitelisted ports from public sources\nis_non_whitelist_public_rule(rule) if {\n\t# Source is 0.0.0.0/0 (all IPv4)\n\trule.SourceCidrIp == \"0.0.0.0/0\"\n\n\t# Policy is accept (default)\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n\n\t# Not all ports (-1/-1 is handled by other rules)\n\trule.PortRange != \"-1/-1\"\n\n\t# Port range is not only whitelisted ports\n\tnot is_only_whitelist_ports(rule.PortRange)\n}\n\nis_non_whitelist_public_rule(rule) if {\n\t# Source is ::/0 (all IPv6)\n\trule.Ipv6SourceCidrIp == \"::/0\"\n\n\t# Policy is accept (default)\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n\n\t# Not all ports (-1/-1 is handled by other rules)\n\trule.PortRange != \"-1/-1\"\n\n\t# Port range is not only whitelisted ports\n\tnot is_only_whitelist_ports(rule.PortRange)\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_non_whitelist_public_rule(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tingress_rule := {\n\t\t\"PortRange\": props.PortRange,\n\t\t\"SourceCidrIp\": object.get(props, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(props, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(props, \"Policy\", \"accept\"),\n\t}\n\tis_non_whitelist_public_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tingress_rule := {\n\t\t\"PortRange\": perm.PortRange,\n\t\t\"SourceCidrIp\": object.get(perm, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(perm, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(perm, \"Policy\", \"accept\"),\n\t}\n\tis_non_whitelist_public_rule(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-snapshot-policy-timepoints-check", Name: models.I18nString{"en": "ECS auto snapshot policy timepoints configured reasonably", "zh": "为自动快照策略设置合理的创建时间点"}, Severity: "medium", Description: models.I18nString{"en": "The snapshot creation timepoints in the auto snapshot policy are within the specified time range, considered compliant. Creating snapshots temporarily reduces block storage I/O performance, with performance differences generally within 10%, causing brief slowdowns. It is recommended to select timepoints that avoid business peak hours.", "zh": "自动快照策略中设置的快照创建时间点在参数指定的时间点范围内,视为合规。创建快照会暂时降低块存储 I/O 性能,一般性能差异在 10%以内,出现短暂瞬间变慢。建议您选择避开业务高峰的时间点。"}, Reason: models.I18nString{"en": "Auto snapshot policy timepoints may not be configured to avoid business peak hours", "zh": "自动快照策略时间点可能未配置为避开业务高峰时段"}, Recommendation: models.I18nString{"en": "Configure snapshot creation timepoints during off-peak hours (e.g., 2:00-6:00 AM) to minimize impact on business operations", "zh": "将快照创建时间点配置在非高峰时段(如凌晨 2:00-6:00)以最小化对业务运营的影响"}, ResourceTypes: []string{"ALIYUN::ECS::AutoSnapshotPolicy"}, FilePath: "aliyun/rules/ecs-snapshot-policy-timepoints-check.rego", PackageName: "infraguard.rules.aliyun.ecs_snapshot_policy_timepoints_check", Content: "package infraguard.rules.aliyun.ecs_snapshot_policy_timepoints_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-snapshot-policy-timepoints-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS auto snapshot policy timepoints configured reasonably\",\n\t\t\"zh\": \"为自动快照策略设置合理的创建时间点\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"The snapshot creation timepoints in the auto snapshot policy are within the specified time range, considered compliant. Creating snapshots temporarily reduces block storage I/O performance, with performance differences generally within 10%, causing brief slowdowns. It is recommended to select timepoints that avoid business peak hours.\",\n\t\t\"zh\": \"自动快照策略中设置的快照创建时间点在参数指定的时间点范围内,视为合规。创建快照会暂时降低块存储 I/O 性能,一般性能差异在 10%以内,出现短暂瞬间变慢。建议您选择避开业务高峰的时间点。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::ECS::AutoSnapshotPolicy\"],\n\t\"reason\": {\n\t\t\"en\": \"Auto snapshot policy timepoints may not be configured to avoid business peak hours\",\n\t\t\"zh\": \"自动快照策略时间点可能未配置为避开业务高峰时段\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure snapshot creation timepoints during off-peak hours (e.g., 2:00-6:00 AM) to minimize impact on business operations\",\n\t\t\"zh\": \"将快照创建时间点配置在非高峰时段(如凌晨 2:00-6:00)以最小化对业务运营的影响\",\n\t},\n}\n\n# Recommended off-peak hours: 2:00-6:00 AM (hours 2-5)\nrecommended_timepoints := {2, 3, 4, 5}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::AutoSnapshotPolicy\")\n\n\t# Get configured timepoints\n\ttimepoints := helpers.get_property(resource, \"TimePoints\", [])\n\n\t# Check if any timepoint is outside recommended range\n\tsome point in timepoints\n\tnot point in recommended_timepoints\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TimePoints\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-snapshot-retention-days", Name: models.I18nString{"en": "ECS auto snapshot retention days meets requirements", "zh": "ECS 自动快照保留天数满足指定要求"}, Severity: "low", Description: models.I18nString{"en": "ECS auto snapshot policy retention days is greater than the specified number of days, considered compliant. Default value: 7 days.", "zh": "ECS 自动快照策略设置快照保留天数大于设置的天数,视为合规。默认值:7 天。"}, Reason: models.I18nString{"en": "Auto snapshot retention days is less than the minimum required days (7 days)", "zh": "自动快照保留天数少于最低要求天数(7 天)"}, Recommendation: models.I18nString{"en": "Set auto snapshot retention days to at least 7 days to ensure adequate backup coverage", "zh": "将自动快照保留天数设置为至少 7 天以确保足够的备份覆盖"}, ResourceTypes: []string{"ALIYUN::ECS::AutoSnapshotPolicy"}, FilePath: "aliyun/rules/ecs-snapshot-retention-days.rego", PackageName: "infraguard.rules.aliyun.ecs_snapshot_retention_days", Content: "package infraguard.rules.aliyun.ecs_snapshot_retention_days\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ecs-snapshot-retention-days\",\n\t\"name\": {\n\t\t\"en\": \"ECS auto snapshot retention days meets requirements\",\n\t\t\"zh\": \"ECS 自动快照保留天数满足指定要求\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"ECS auto snapshot policy retention days is greater than the specified number of days, considered compliant. Default value: 7 days.\",\n\t\t\"zh\": \"ECS 自动快照策略设置快照保留天数大于设置的天数,视为合规。默认值:7 天。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::ECS::AutoSnapshotPolicy\"],\n\t\"reason\": {\n\t\t\"en\": \"Auto snapshot retention days is less than the minimum required days (7 days)\",\n\t\t\"zh\": \"自动快照保留天数少于最低要求天数(7 天)\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set auto snapshot retention days to at least 7 days to ensure adequate backup coverage\",\n\t\t\"zh\": \"将自动快照保留天数设置为至少 7 天以确保足够的备份覆盖\",\n\t},\n}\n\n# Minimum retention days requirement\nmin_retention_days := 7\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::AutoSnapshotPolicy\")\n\n\t# Get retention days (-1 means permanent, which is compliant)\n\tretention_days := helpers.get_property(resource, \"RetentionDays\", 0)\n\n\t# Check if retention is less than minimum (but not -1 for permanent)\n\tretention_days != -1\n\tretention_days < min_retention_days\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RetentionDays\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ecs-system-disk-size-check", Name: models.I18nString{"en": "ECS System Disk Size Check", "zh": "ECS 系统盘大小检查"}, Severity: "low", Description: models.I18nString{"en": "Ensures ECS system disks meet the minimum required size.", "zh": "确保 ECS 系统盘满足最低大小要求。"}, Reason: models.I18nString{"en": "System disks that are too small may run out of space, causing system instability.", "zh": "系统盘过小可能导致空间耗尽，引发系统不稳定。"}, Recommendation: models.I18nString{"en": "Increase the system disk size to at least 40GB.", "zh": "将系统盘大小增加到至少 40GB。"}, ResourceTypes: []string{"ALIYUN::ECS::Instance", "ALIYUN::ECS::InstanceGroup"}, FilePath: "aliyun/rules/ecs-system-disk-size-check.rego", PackageName: "infraguard.rules.aliyun.ecs_system_disk_size_check", Content: "package infraguard.rules.aliyun.ecs_system_disk_size_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ecs-system-disk-size-check\",\n\t\"name\": {\n\t\t\"en\": \"ECS System Disk Size Check\",\n\t\t\"zh\": \"ECS 系统盘大小检查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures ECS system disks meet the minimum required size.\",\n\t\t\"zh\": \"确保 ECS 系统盘满足最低大小要求。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"System disks that are too small may run out of space, causing system instability.\",\n\t\t\"zh\": \"系统盘过小可能导致空间耗尽，引发系统不稳定。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Increase the system disk size to at least 40GB.\",\n\t\t\"zh\": \"将系统盘大小增加到至少 40GB。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"],\n}\n\nis_compliant(resource) if {\n\tsize := helpers.get_property(resource, \"SystemDiskSize\", 40)\n\tsize >= 40\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SystemDiskSize\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:eip-attached", Name: models.I18nString{"en": "EIP Attached", "zh": "EIP 必须处于绑定状态"}, Severity: "low", Description: models.I18nString{"en": "Ensures that EIP instances are associated with a resource.", "zh": "确保 EIP 实例已与资源关联。"}, Reason: models.I18nString{"en": "Unattached EIPs incur costs without providing any service.", "zh": "未绑定的 EIP 会产生费用，但未提供任何服务。"}, Recommendation: models.I18nString{"en": "Associate the EIP with an ECS instance, NAT Gateway, or Load Balancer.", "zh": "将 EIP 与 ECS 实例、NAT 网关或负载均衡器关联。"}, ResourceTypes: []string{"ALIYUN::VPC::EIP"}, FilePath: "aliyun/rules/eip-attached.rego", PackageName: "infraguard.rules.aliyun.eip_attached", Content: "package infraguard.rules.aliyun.eip_attached\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"eip-attached\",\n\t\"name\": {\n\t\t\"en\": \"EIP Attached\",\n\t\t\"zh\": \"EIP 必须处于绑定状态\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that EIP instances are associated with a resource.\",\n\t\t\"zh\": \"确保 EIP 实例已与资源关联。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Unattached EIPs incur costs without providing any service.\",\n\t\t\"zh\": \"未绑定的 EIP 会产生费用，但未提供任何服务。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Associate the EIP with an ECS instance, NAT Gateway, or Load Balancer.\",\n\t\t\"zh\": \"将 EIP 与 ECS 实例、NAT 网关或负载均衡器关联。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::EIP\"],\n}\n\n# In ROS, attachment is usually done via ALIYUN::VPC::EIPAssociation\nis_attached(eip_id) if {\n\tsome name, res in helpers.resources_by_type(\"ALIYUN::VPC::EIPAssociation\")\n\thelpers.is_referencing(helpers.get_property(res, \"AllocationId\", \"\"), eip_id)\n}\n\ndeny contains result if {\n\tsome eip_id, resource in helpers.resources_by_type(\"ALIYUN::VPC::EIP\")\n\tnot is_attached(eip_id)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": eip_id,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:eip-bandwidth-limit", Name: models.I18nString{"en": "EIP Bandwidth Limit", "zh": "EIP 带宽上限核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures EIP bandwidth does not exceed a specified maximum value.", "zh": "确保 EIP 带宽不超过指定的最高值。"}, Reason: models.I18nString{"en": "Excessive bandwidth settings can lead to higher than expected costs.", "zh": "过高的带宽设置可能导致超出预期的成本。"}, Recommendation: models.I18nString{"en": "Set EIP bandwidth to a reasonable value (e.g., up to 100Mbps).", "zh": "将 EIP 带宽设置为合理的值（如不超过 100Mbps）。"}, ResourceTypes: []string{"ALIYUN::VPC::EIP"}, FilePath: "aliyun/rules/eip-bandwidth-limit.rego", PackageName: "infraguard.rules.aliyun.eip_bandwidth_limit", Content: "package infraguard.rules.aliyun.eip_bandwidth_limit\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"eip-bandwidth-limit\",\n\t\"name\": {\n\t\t\"en\": \"EIP Bandwidth Limit\",\n\t\t\"zh\": \"EIP 带宽上限核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures EIP bandwidth does not exceed a specified maximum value.\",\n\t\t\"zh\": \"确保 EIP 带宽不超过指定的最高值。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Excessive bandwidth settings can lead to higher than expected costs.\",\n\t\t\"zh\": \"过高的带宽设置可能导致超出预期的成本。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set EIP bandwidth to a reasonable value (e.g., up to 100Mbps).\",\n\t\t\"zh\": \"将 EIP 带宽设置为合理的值（如不超过 100Mbps）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::EIP\"],\n}\n\nis_compliant(resource) if {\n\tbandwidth := helpers.get_property(resource, \"Bandwidth\", 5)\n\tbandwidth <= 100\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::EIP\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Bandwidth\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:eip-delete-protection-enabled", Name: models.I18nString{"en": "EIP Deletion Protection Enabled", "zh": "弹性公网 IP 开启删除保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that EIP instances have deletion protection enabled.", "zh": "确保弹性公网 IP 开启了删除保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the EIP may be released accidentally, potentially changing the public IP of your services.", "zh": "如果未开启删除保护，弹性公网 IP 可能会被意外释放，从而可能导致您的服务公网 IP 发生变化。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the EIP instance.", "zh": "为弹性公网 IP 开启删除保护功能。"}, ResourceTypes: []string{"ALIYUN::VPC::EIP"}, FilePath: "aliyun/rules/eip-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.eip_delete_protection_enabled", Content: "package infraguard.rules.aliyun.eip_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"eip-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"EIP Deletion Protection Enabled\",\n\t\t\"zh\": \"弹性公网 IP 开启删除保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that EIP instances have deletion protection enabled.\",\n\t\t\"zh\": \"确保弹性公网 IP 开启了删除保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the EIP may be released accidentally, potentially changing the public IP of your services.\",\n\t\t\"zh\": \"如果未开启删除保护，弹性公网 IP 可能会被意外释放，从而可能导致您的服务公网 IP 发生变化。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the EIP instance.\",\n\t\t\"zh\": \"为弹性公网 IP 开启删除保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::EIP\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::EIP\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", Name: models.I18nString{"en": "Elasticsearch Data Node Encryption Enabled", "zh": "Elasticsearch 数据节点开启加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that data nodes in the Elasticsearch instance have disk encryption enabled.", "zh": "确保 Elasticsearch 实例中的数据节点已开启磁盘加密。"}, Reason: models.I18nString{"en": "Disk encryption protects sensitive data stored on Elasticsearch nodes.", "zh": "磁盘加密可保护存储在 Elasticsearch 节点上的敏感数据。"}, Recommendation: models.I18nString{"en": "Enable disk encryption for the Elasticsearch instance data nodes.", "zh": "为 Elasticsearch 实例数据节点开启磁盘加密。"}, ResourceTypes: []string{"ALIYUN::Elasticsearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-enabled-data-node-encryption.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_enabled_data_node_encryption", Content: "package infraguard.rules.aliyun.elasticsearch_instance_enabled_data_node_encryption\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-enabled-data-node-encryption\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Data Node Encryption Enabled\",\n\t\t\"zh\": \"Elasticsearch 数据节点开启加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that data nodes in the Elasticsearch instance have disk encryption enabled.\",\n\t\t\"zh\": \"确保 Elasticsearch 实例中的数据节点已开启磁盘加密。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Disk encryption protects sensitive data stored on Elasticsearch nodes.\",\n\t\t\"zh\": \"磁盘加密可保护存储在 Elasticsearch 节点上的敏感数据。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable disk encryption for the Elasticsearch instance data nodes.\",\n\t\t\"zh\": \"为 Elasticsearch 实例数据节点开启磁盘加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::Elasticsearch::Instance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Elasticsearch::Instance\")\n\n\t# Conceptual check for disk encryption\n\tnot helpers.has_property(resource, \"EncryptionAtRest\") # Simplified\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-enabled-kibana-public-check", Name: models.I18nString{"en": "Elasticsearch Instance Kibana Does Not Enable Public Access", "zh": "Elasticsearch 实例 Kibana 未开启公网访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Elasticsearch instance Kibana is not accessible from public networks.", "zh": "Elasticsearch 实例 Kibana 未开启公网访问，视为合规。"}, Reason: models.I18nString{"en": "Elasticsearch instance Kibana is accessible from public network, which is a security risk.", "zh": "Elasticsearch 实例 Kibana 开启公网访问，存在安全风险。"}, Recommendation: models.I18nString{"en": "Configure Kibana to only allow access from VPC or specific IPs.", "zh": "请配置 Kibana 仅允许 VPC 或特定 IP 访问。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-enabled-kibana-public-check.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_enabled_kibana_public_check", Content: "package infraguard.rules.aliyun.elasticsearch_instance_enabled_kibana_public_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-enabled-kibana-public-check\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Instance Kibana Does Not Enable Public Access\",\n\t\t\"zh\": \"Elasticsearch 实例 Kibana 未开启公网访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Elasticsearch instance Kibana is not accessible from public networks.\",\n\t\t\"zh\": \"Elasticsearch 实例 Kibana 未开启公网访问，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Elasticsearch instance Kibana is accessible from public network, which is a security risk.\",\n\t\t\"zh\": \"Elasticsearch 实例 Kibana 开启公网访问，存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure Kibana to only allow access from VPC or specific IPs.\",\n\t\t\"zh\": \"请配置 Kibana 仅允许 VPC 或特定 IP 访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\n# Check if Kibana public access is enabled\nis_kibana_public_access_enabled(resource) if {\n\tresource.Properties.KibanaPublicNetworkAccess == true\n}\n\nis_kibana_public_access_enabled(resource) if {\n\tcount(resource.Properties.KibanaWhitelist) > 0\n\t\"0.0.0.0/0\" in resource.Properties.KibanaWhitelist\n}\n\nis_kibana_public_access_enabled(resource) if {\n\tcount(resource.Properties.KibanaWhitelist) > 0\n\t\"0.0.0.0\" in resource.Properties.KibanaWhitelist\n}\n\nis_kibana_public_access_enabled(resource) if {\n\tresource.Properties.KibanaWhitelist == \"0.0.0.0/0\"\n}\n\nis_kibana_public_access_enabled(resource) if {\n\tresource.Properties.KibanaWhitelist == \"0.0.0.0\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\tis_kibana_public_access_enabled(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"KibanaPublicNetworkAccess\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-enabled-node-config-disk-encryption", Name: models.I18nString{"en": "ES Node Config Disk Encryption", "zh": "ES 弹性节点磁盘加密核查"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Elasticsearch elastic node configurations have disk encryption enabled.", "zh": "确保 Elasticsearch 弹性节点配置开启了磁盘加密。"}, Reason: models.I18nString{"en": "Elastic nodes can store sensitive transient data.", "zh": "弹性节点可能存储敏感的临时数据。"}, Recommendation: models.I18nString{"en": "Enable disk encryption for all node configurations in the ES instance.", "zh": "为 Elasticsearch 实例中的所有节点配置开启磁盘加密。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-enabled-node-config-disk-encryption.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_enabled_node_config_disk_encryption", Content: "package infraguard.rules.aliyun.elasticsearch_instance_enabled_node_config_disk_encryption\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-enabled-node-config-disk-encryption\",\n\t\"name\": {\n\t\t\"en\": \"ES Node Config Disk Encryption\",\n\t\t\"zh\": \"ES 弹性节点磁盘加密核查\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Elasticsearch elastic node configurations have disk encryption enabled.\",\n\t\t\"zh\": \"确保 Elasticsearch 弹性节点配置开启了磁盘加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Elastic nodes can store sensitive transient data.\",\n\t\t\"zh\": \"弹性节点可能存储敏感的临时数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable disk encryption for all node configurations in the ES instance.\",\n\t\t\"zh\": \"为 Elasticsearch 实例中的所有节点配置开启磁盘加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# DataNode disk encryption check\n\tnode := helpers.get_property(resource, \"DataNode\", {})\n\thelpers.is_true(object.get(node, \"DiskEncryption\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DataNode\", \"DiskEncryption\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-enabled-public-check", Name: models.I18nString{"en": "Elasticsearch Instance Does Not Enable Public Access", "zh": "Elasticsearch 实例未开启公网访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Elasticsearch instances are not accessible from public networks.", "zh": "Elasticsearch 实例未开启公网访问，视为合规。"}, Reason: models.I18nString{"en": "Elasticsearch instance is accessible from public network, which is a security risk.", "zh": "Elasticsearch 实例开启公网访问，存在安全风险。"}, Recommendation: models.I18nString{"en": "Configure the instance to only allow access from VPC or specific IPs.", "zh": "请配置实例仅允许 VPC 或特定 IP 访问。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-enabled-public-check.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_enabled_public_check", Content: "package infraguard.rules.aliyun.elasticsearch_instance_enabled_public_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-enabled-public-check\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Instance Does Not Enable Public Access\",\n\t\t\"zh\": \"Elasticsearch 实例未开启公网访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Elasticsearch instances are not accessible from public networks.\",\n\t\t\"zh\": \"Elasticsearch 实例未开启公网访问，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Elasticsearch instance is accessible from public network, which is a security risk.\",\n\t\t\"zh\": \"Elasticsearch 实例开启公网访问，存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the instance to only allow access from VPC or specific IPs.\",\n\t\t\"zh\": \"请配置实例仅允许 VPC 或特定 IP 访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\n# Check if public network access is enabled\nis_public_access_enabled(resource) if {\n\tresource.Properties.EnablePublic == true\n}\n\nis_public_access_enabled(resource) if {\n\tcount(resource.Properties.PublicWhitelist) > 0\n\t\"0.0.0.0/0\" in resource.Properties.PublicWhitelist\n}\n\nis_public_access_enabled(resource) if {\n\tcount(resource.Properties.PublicWhitelist) > 0\n\t\"0.0.0.0\" in resource.Properties.PublicWhitelist\n}\n\nis_public_access_enabled(resource) if {\n\tresource.Properties.PublicWhitelist == \"0.0.0.0/0\"\n}\n\nis_public_access_enabled(resource) if {\n\tresource.Properties.PublicWhitelist == \"0.0.0.0\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\tis_public_access_enabled(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EnablePublic\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-multi-zone", Name: models.I18nString{"en": "Elasticsearch Instance Multi-Zone Deployment", "zh": "Elasticsearch 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "Elasticsearch instances should be deployed across multiple availability zones.", "zh": "Elasticsearch 实例应部署在多个可用区。"}, Reason: models.I18nString{"en": "The Elasticsearch instance is configured with fewer than 2 availability zones.", "zh": "Elasticsearch 实例配置的可用区数量少于 2 个。"}, Recommendation: models.I18nString{"en": "Increase the ZoneCount to at least 2.", "zh": "将 ZoneCount 增加到至少 2。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_multi_zone", Content: "package infraguard.rules.aliyun.elasticsearch_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"Elasticsearch 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Elasticsearch instances should be deployed across multiple availability zones.\",\n\t\t\"zh\": \"Elasticsearch 实例应部署在多个可用区。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Elasticsearch instance is configured with fewer than 2 availability zones.\",\n\t\t\"zh\": \"Elasticsearch 实例配置的可用区数量少于 2 个。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Increase the ZoneCount to at least 2.\",\n\t\t\"zh\": \"将 ZoneCount 增加到至少 2。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\n# Check if instance is multi-zone\nis_multi_zone(resource) if {\n\t# Check ZoneCount >= 2\n\tobject.get(resource.Properties, \"ZoneCount\", 1) >= 2\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneCount\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-node-not-use-specified-spec", Name: models.I18nString{"en": "Elasticsearch Instance Does Not Use Deprecated Spec", "zh": "未使用不推荐的 Elasticsearch 实例"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Elasticsearch instances do not use deprecated or unsupported node specifications.", "zh": "未使用参数指定的 Elasticsearch 规格实例，视为合规。"}, Reason: models.I18nString{"en": "Using deprecated Elasticsearch node specifications may lack support and security updates.", "zh": "使用不推荐的 Elasticsearch 规格实例，可能缺少支持和安全更新。"}, Recommendation: models.I18nString{"en": "Upgrade to a supported Elasticsearch node specification.", "zh": "请升级到支持的 Elasticsearch 节点规格。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-node-not-use-specified-spec.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_node_not_use_specified_spec", Content: "package infraguard.rules.aliyun.elasticsearch_instance_node_not_use_specified_spec\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-node-not-use-specified-spec\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Instance Does Not Use Deprecated Spec\",\n\t\t\"zh\": \"未使用不推荐的 Elasticsearch 实例\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Elasticsearch instances do not use deprecated or unsupported node specifications.\",\n\t\t\"zh\": \"未使用参数指定的 Elasticsearch 规格实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using deprecated Elasticsearch node specifications may lack support and security updates.\",\n\t\t\"zh\": \"使用不推荐的 Elasticsearch 规格实例，可能缺少支持和安全更新。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade to a supported Elasticsearch node specification.\",\n\t\t\"zh\": \"请升级到支持的 Elasticsearch 节点规格。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\n# Default deprecated specs (should be parameterized in production)\ndeprecated_specs := [\n\t\"elasticsearch.sn1.small\",\n\t\"elasticsearch.sn2.small\",\n\t\"elasticsearch.mn1.small\",\n]\n\n# Check if rule parameters exist\nhas_rule_parameters := count(input.rule_parameters) > 0\n\n# Get deprecated specs from parameters or use default\ndeprecated_list := deprecated_specs if {\n\tnot has_rule_parameters\n}\n\ndeprecated_list := deprecated_specs if {\n\thas_rule_parameters\n\tinput.rule_parameters.deprecated_node_specs == \"\"\n}\n\ndeprecated_list := deprecated_specs if {\n\thas_rule_parameters\n\tnot input.rule_parameters.deprecated_node_specs\n}\n\ndeprecated_list := input.rule_parameters.deprecated_node_specs if {\n\thas_rule_parameters\n\tinput.rule_parameters.deprecated_node_specs != \"\"\n}\n\n# Check if a node spec is deprecated\nis_deprecated_spec(node_spec) if {\n\tsome deprecated in deprecated_list\n\tcontains(node_spec, deprecated)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\n\tdata_node := resource.Properties.DataNode\n\tnode_spec := data_node.Spec\n\n\tis_deprecated_spec(node_spec)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DataNode\", \"Spec\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-instance-version-not-deprecated", Name: models.I18nString{"en": "Elasticsearch Instance Does Not Use Deprecated Version", "zh": "未使用不推荐的 Elasticsearch 实例版本"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Elasticsearch instances are not using deprecated or EOL versions.", "zh": "Elasticsearch 实例所使用的版本未在参数指定的不推荐版本范围内，视为合规。"}, Reason: models.I18nString{"en": "Using deprecated Elasticsearch versions may have security vulnerabilities and lack support.", "zh": "使用不推荐的 Elasticsearch 版本可能存在安全漏洞且缺乏支持。"}, Recommendation: models.I18nString{"en": "Upgrade to a supported Elasticsearch version.", "zh": "请升级到支持的 Elasticsearch 版本。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-instance-version-not-deprecated.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_instance_version_not_deprecated", Content: "package infraguard.rules.aliyun.elasticsearch_instance_version_not_deprecated\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"elasticsearch-instance-version-not-deprecated\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Instance Does Not Use Deprecated Version\",\n\t\t\"zh\": \"未使用不推荐的 Elasticsearch 实例版本\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Elasticsearch instances are not using deprecated or EOL versions.\",\n\t\t\"zh\": \"Elasticsearch 实例所使用的版本未在参数指定的不推荐版本范围内，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using deprecated Elasticsearch versions may have security vulnerabilities and lack support.\",\n\t\t\"zh\": \"使用不推荐的 Elasticsearch 版本可能存在安全漏洞且缺乏支持。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade to a supported Elasticsearch version.\",\n\t\t\"zh\": \"请升级到支持的 Elasticsearch 版本。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\n# Default deprecated versions (major versions that are EOL)\ndefault deprecated_versions := [\n\t\"5.5.3\",\n\t\"5.6.16\",\n\t\"6.3\",\n\t\"6.7\",\n\t\"7.0\",\n]\n\n# Get deprecated versions from parameters or use default\nget_deprecated_versions := deprecated_versions if {\n\tparams := object.get(input, \"rule_parameters\", {})\n\tval := object.get(params, \"deprecated_versions\", \"\")\n\tval == \"\"\n}\n\nget_deprecated_versions := versions if {\n\tparams := object.get(input, \"rule_parameters\", {})\n\tval := object.get(params, \"deprecated_versions\", \"\")\n\tval != \"\"\n\tversions := val\n}\n\n# Check if a version is deprecated\nis_deprecated_version(version) if {\n\tsome deprecated in get_deprecated_versions\n\tstartswith(version, deprecated)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\n\tversion := resource.Properties.Version\n\n\tis_deprecated_version(version)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Version\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:elasticsearch-public-and-any-ip-access-check", Name: models.I18nString{"en": "Elasticsearch Public and Any IP Access Check", "zh": "Elasticsearch 实例未开启公网或不允许任意 IP 访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Elasticsearch instances do not have public access enabled or an open whitelist.", "zh": "确保 Elasticsearch 实例未开启公网访问，或者白名单未设置为对所有 IP 开放。"}, Reason: models.I18nString{"en": "Public access or an open whitelist exposes the Elasticsearch cluster to the internet, increasing the risk of unauthorized access or attacks.", "zh": "开启公网访问或设置开放白名单会将 Elasticsearch 集群暴露在互联网上，增加未经授权访问或攻击的风险。"}, Recommendation: models.I18nString{"en": "Disable public access or restrict the IP whitelist for the Elasticsearch instance.", "zh": "禁用 Elasticsearch 实例的公网访问或限制 IP 白名单。"}, ResourceTypes: []string{"ALIYUN::ElasticSearch::Instance"}, FilePath: "aliyun/rules/elasticsearch-public-and-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.elasticsearch_public_and_any_ip_access_check", Content: "package infraguard.rules.aliyun.elasticsearch_public_and_any_ip_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"elasticsearch-public-and-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"Elasticsearch Public and Any IP Access Check\",\n\t\t\"zh\": \"Elasticsearch 实例未开启公网或不允许任意 IP 访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Elasticsearch instances do not have public access enabled or an open whitelist.\",\n\t\t\"zh\": \"确保 Elasticsearch 实例未开启公网访问，或者白名单未设置为对所有 IP 开放。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public access or an open whitelist exposes the Elasticsearch cluster to the internet, increasing the risk of unauthorized access or attacks.\",\n\t\t\"zh\": \"开启公网访问或设置开放白名单会将 Elasticsearch 集群暴露在互联网上，增加未经授权访问或攻击的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public access or restrict the IP whitelist for the Elasticsearch instance.\",\n\t\t\"zh\": \"禁用 Elasticsearch 实例的公网访问或限制 IP 白名单。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ElasticSearch::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# If public access is not enabled, it's compliant\n\tnot helpers.is_true(helpers.get_property(resource, \"EnablePublic\", false))\n}\n\nis_compliant(resource) if {\n\t# If public access is enabled, check the whitelist\n\thelpers.is_true(helpers.get_property(resource, \"EnablePublic\", false))\n\twhitelist := helpers.get_property(resource, \"PublicWhitelist\", [])\n\tnot has_open_cidr(whitelist)\n}\n\nhas_open_cidr(whitelist) if {\n\tsome cidr in whitelist\n\thelpers.is_public_cidr(cidr)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ElasticSearch::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EnablePublic\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:emr-cluster-master-public-access-check", Name: models.I18nString{"en": "EMR Cluster Master Node Public Access Check", "zh": "EMR 集群 Master 节点公网开启检测"}, Severity: "medium", Description: models.I18nString{"en": "EMR on ECS cluster master nodes should not have public IP enabled.", "zh": "EMR on ECS 集群 Master 节点公网不开启，视为合规。"}, Reason: models.I18nString{"en": "EMR master nodes with public IP enabled may be exposed to the internet, increasing security risks.", "zh": "EMR Master 节点开启公网 IP 可能会暴露在互联网中，增加安全风险。"}, Recommendation: models.I18nString{"en": "Set 'IsOpenPublicIp' to false for the EMR cluster and use a NAT gateway or bastion host for access.", "zh": "将 EMR 集群的'IsOpenPublicIp'属性设置为 false，并使用 NAT 网关或堡垒机进行访问。"}, ResourceTypes: []string{"ALIYUN::EMR::Cluster"}, FilePath: "aliyun/rules/emr-cluster-master-public-access-check.rego", PackageName: "infraguard.rules.aliyun.emr_cluster_master_public_access_check", Content: "package infraguard.rules.aliyun.emr_cluster_master_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"emr-cluster-master-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"EMR Cluster Master Node Public Access Check\",\n\t\t\"zh\": \"EMR 集群 Master 节点公网开启检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"EMR on ECS cluster master nodes should not have public IP enabled.\",\n\t\t\"zh\": \"EMR on ECS 集群 Master 节点公网不开启，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"EMR master nodes with public IP enabled may be exposed to the internet, increasing security risks.\",\n\t\t\"zh\": \"EMR Master 节点开启公网 IP 可能会暴露在互联网中，增加安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set 'IsOpenPublicIp' to false for the EMR cluster and use a NAT gateway or bastion host for access.\",\n\t\t\"zh\": \"将 EMR 集群的'IsOpenPublicIp'属性设置为 false，并使用 NAT 网关或堡垒机进行访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::EMR::Cluster\"],\n}\n\n# Deny if IsOpenPublicIp is true\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::EMR::Cluster\")\n\tresource.Properties.IsOpenPublicIp == true\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"IsOpenPublicIp\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-group-health-check", Name: models.I18nString{"en": "ESS Scaling Group Health Check", "zh": "弹性伸缩组开启 ECS 实例健康检查"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling groups should enable ECS instance health check to ensure only healthy instances are in service.", "zh": "弹性伸缩组开启对 ECS 实例的健康检查，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling group does not have health check enabled, which may result in unhealthy instances serving traffic.", "zh": "弹性伸缩组未开启健康检查，可能导致异常实例仍在提供服务。"}, Recommendation: models.I18nString{"en": "Enable health check type for the ESS scaling group by setting HealthCheckType to ECS or configuring HealthCheckTypes.", "zh": "为弹性伸缩组启用健康检查，将 HealthCheckType 设置为 ECS 或配置 HealthCheckTypes。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingGroup"}, FilePath: "aliyun/rules/ess-group-health-check.rego", PackageName: "infraguard.rules.aliyun.ess_group_health_check", Content: "package infraguard.rules.aliyun.ess_group_health_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-group-health-check\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Group Health Check\",\n\t\t\"zh\": \"弹性伸缩组开启 ECS 实例健康检查\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling groups should enable ECS instance health check to ensure only healthy instances are in service.\",\n\t\t\"zh\": \"弹性伸缩组开启对 ECS 实例的健康检查，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling group does not have health check enabled, which may result in unhealthy instances serving traffic.\",\n\t\t\"zh\": \"弹性伸缩组未开启健康检查，可能导致异常实例仍在提供服务。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable health check type for the ESS scaling group by setting HealthCheckType to ECS or configuring HealthCheckTypes.\",\n\t\t\"zh\": \"为弹性伸缩组启用健康检查，将 HealthCheckType 设置为 ECS 或配置 HealthCheckTypes。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingGroup\"],\n}\n\n# Check if scaling group has health check enabled\nhas_health_check_enabled(resource) if {\n\thealth_check_type := helpers.get_property(resource, \"HealthCheckType\", \"\")\n\thealth_check_type != \"\"\n\thealth_check_type != \"NONE\"\n}\n\nhas_health_check_enabled(resource) if {\n\thealth_check_types := helpers.get_property(resource, \"HealthCheckTypes\", [])\n\tcount(health_check_types) > 0\n}\n\n# Deny rule: ESS scaling groups must have health check enabled\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingGroup\")\n\tnot has_health_check_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HealthCheckType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-attach-security-group", Name: models.I18nString{"en": "ESS Scaling Configuration Security Group", "zh": "弹性伸缩配置中为实例设置关联安全组"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling configurations should attach security groups to instances for proper network isolation and access control.", "zh": "弹性伸缩配置中设置了实例要加入的安全组，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling configuration does not have security groups attached, which may result in instances without proper network access control.", "zh": "弹性伸缩配置未关联安全组，实例可能缺少网络访问控制。"}, Recommendation: models.I18nString{"en": "Add security groups to the scaling configuration using SecurityGroupId or SecurityGroupIds properties.", "zh": "在伸缩配置中使用 SecurityGroupId 或 SecurityGroupIds 属性添加安全组。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-attach-security-group.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_attach_security_group", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_attach_security_group\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-attach-security-group\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Security Group\",\n\t\t\"zh\": \"弹性伸缩配置中为实例设置关联安全组\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configurations should attach security groups to instances for proper network isolation and access control.\",\n\t\t\"zh\": \"弹性伸缩配置中设置了实例要加入的安全组，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration does not have security groups attached, which may result in instances without proper network access control.\",\n\t\t\"zh\": \"弹性伸缩配置未关联安全组，实例可能缺少网络访问控制。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add security groups to the scaling configuration using SecurityGroupId or SecurityGroupIds properties.\",\n\t\t\"zh\": \"在伸缩配置中使用 SecurityGroupId 或 SecurityGroupIds 属性添加安全组。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\n# Check if scaling configuration has security groups attached\nhas_security_group(resource) if {\n\tsecurity_group_id := helpers.get_property(resource, \"SecurityGroupId\", \"\")\n\tsecurity_group_id != \"\"\n}\n\nhas_security_group(resource) if {\n\tsecurity_group_ids := helpers.get_property(resource, \"SecurityGroupIds\", [])\n\tcount(security_group_ids) > 0\n}\n\n# Deny rule: ESS scaling configurations must have security groups attached\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot has_security_group(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-data-disk-encrypted", Name: models.I18nString{"en": "ESS Scaling Configuration Data Disk Encryption", "zh": "弹性伸缩配置中设置数据磁盘加密"}, Severity: "high", Description: models.I18nString{"en": "ESS scaling configurations should enable data disk encryption to protect data at rest.", "zh": "弹性伸缩配置中数据磁盘配置均设置为加密，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling configuration has data disks that are not encrypted, which may expose sensitive data at rest.", "zh": "弹性伸缩配置中的数据磁盘未加密，静态数据可能面临泄露风险。"}, Recommendation: models.I18nString{"en": "Enable encryption for all data disks in the scaling configuration by setting DiskMappings[*].Encrypted to true.", "zh": "在伸缩配置中，将所有数据磁盘的 DiskMappings[*].Encrypted 设置为 true 以启用加密。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-data-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_data_disk_encrypted", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_data_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-data-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Data Disk Encryption\",\n\t\t\"zh\": \"弹性伸缩配置中设置数据磁盘加密\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configurations should enable data disk encryption to protect data at rest.\",\n\t\t\"zh\": \"弹性伸缩配置中数据磁盘配置均设置为加密，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration has data disks that are not encrypted, which may expose sensitive data at rest.\",\n\t\t\"zh\": \"弹性伸缩配置中的数据磁盘未加密，静态数据可能面临泄露风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for all data disks in the scaling configuration by setting DiskMappings[*].Encrypted to true.\",\n\t\t\"zh\": \"在伸缩配置中，将所有数据磁盘的 DiskMappings[*].Encrypted 设置为 true 以启用加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\n# Check if all data disks are encrypted\nall_data_disks_encrypted(resource) if {\n\tdisk_mappings := helpers.get_property(resource, \"DiskMappings\", [])\n\tdisk_mappings == []\n}\n\nall_data_disks_encrypted(resource) if {\n\tdisk_mappings := helpers.get_property(resource, \"DiskMappings\", [])\n\tdisk_mappings != []\n\tevery disk in disk_mappings {\n\t\tdisk.Encrypted == true\n\t}\n}\n\nall_data_disks_encrypted(resource) if {\n\tdisk_mappings := helpers.get_property(resource, \"DiskMappings\", [])\n\tdisk_mappings != []\n\tevery disk in disk_mappings {\n\t\tdisk.Encrypted == \"true\"\n\t}\n}\n\n# Deny rule: ESS scaling configurations must have all data disks encrypted\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot all_data_disks_encrypted(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DiskMappings\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-enabled-internet-check", Name: models.I18nString{"en": "ESS Scaling Configuration Internet Access Check", "zh": "ESS 伸缩配置公网访问检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that ESS scaling configurations do not enable public IP addresses for instances unless necessary.", "zh": "确保 ESS 伸缩配置未为实例开启公网 IP 地址，除非必要。"}, Reason: models.I18nString{"en": "Enabling public IPs for all instances in a scaling group increases the attack surface.", "zh": "为伸缩组中的所有实例开启公网 IP 会增加攻击面。"}, Recommendation: models.I18nString{"en": "Use internal IPs and a NAT gateway or SLB for internet access instead of public IPs on each instance.", "zh": "使用内网 IP 和 NAT 网关或 SLB 进行公网访问，而不是在每个实例上使用公网 IP。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-enabled-internet-check.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_enabled_internet_check", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_enabled_internet_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-enabled-internet-check\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Internet Access Check\",\n\t\t\"zh\": \"ESS 伸缩配置公网访问检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that ESS scaling configurations do not enable public IP addresses for instances unless necessary.\",\n\t\t\"zh\": \"确保 ESS 伸缩配置未为实例开启公网 IP 地址，除非必要。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Enabling public IPs for all instances in a scaling group increases the attack surface.\",\n\t\t\"zh\": \"为伸缩组中的所有实例开启公网 IP 会增加攻击面。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use internal IPs and a NAT gateway or SLB for internet access instead of public IPs on each instance.\",\n\t\t\"zh\": \"使用内网 IP 和 NAT 网关或 SLB 进行公网访问，而不是在每个实例上使用公网 IP。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\thelpers.get_property(resource, \"InternetMaxBandwidthOut\", 0) > 0\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetMaxBandwidthOut\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-image-check", Name: models.I18nString{"en": "ESS Scaling Configuration Image Check", "zh": "弹性伸缩配置镜像检测"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling configurations should use maintained images to ensure security and stability.", "zh": "弹性伸缩配置中镜像为保有中资源，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling configuration may be using an image that is no longer maintained or available.", "zh": "弹性伸缩配置中使用的镜像可能已不再维护或不再可用。"}, Recommendation: models.I18nString{"en": "Use images that are in maintained status. You can use ImageId or ImageFamily properties with valid image IDs.", "zh": "使用状态为保有中的镜像资源。可通过 ImageId 或 ImageFamily 属性指定有效镜像 ID。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-image-check.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_image_check", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_image_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-image-check\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Image Check\",\n\t\t\"zh\": \"弹性伸缩配置镜像检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configurations should use maintained images to ensure security and stability.\",\n\t\t\"zh\": \"弹性伸缩配置中镜像为保有中资源，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration may be using an image that is no longer maintained or available.\",\n\t\t\"zh\": \"弹性伸缩配置中使用的镜像可能已不再维护或不再可用。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use images that are in maintained status. You can use ImageId or ImageFamily properties with valid image IDs.\",\n\t\t\"zh\": \"使用状态为保有中的镜像资源。可通过 ImageId 或 ImageFamily 属性指定有效镜像 ID。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\n# Check if scaling configuration has a valid image\nhas_valid_image(resource) if {\n\timage_id := helpers.get_property(resource, \"ImageId\", \"\")\n\timage_id != \"\"\n}\n\nhas_valid_image(resource) if {\n\timage_family := helpers.get_property(resource, \"ImageFamily\", \"\")\n\timage_family != \"\"\n}\n\n# Deny rule: ESS scaling configurations must have a valid image\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot has_valid_image(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-image-type-check", Name: models.I18nString{"en": "ESS Scaling Configuration Image Type Check", "zh": "弹性伸缩配置中使用指定来源的镜像"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling configurations should use images from specified sources for better security and management.", "zh": "弹性伸缩配置中镜像来源为指定类型的来源，视为合规。参数默认值为共享类型。"}, Reason: models.I18nString{"en": "The ESS scaling configuration is not using an image from the specified source type.", "zh": "弹性伸缩配置中镜像来源非指定类型，可能存在安全风险或管理问题。"}, Recommendation: models.I18nString{"en": "Use images from trusted sources. Set the image source type according to your security requirements.", "zh": "使用来自可信来源的镜像。根据安全要求设置镜像来源类型。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-image-type-check.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_image_type_check", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_image_type_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-image-type-check\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Image Type Check\",\n\t\t\"zh\": \"弹性伸缩配置中使用指定来源的镜像\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configurations should use images from specified sources for better security and management.\",\n\t\t\"zh\": \"弹性伸缩配置中镜像来源为指定类型的来源，视为合规。参数默认值为共享类型。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration is not using an image from the specified source type.\",\n\t\t\"zh\": \"弹性伸缩配置中镜像来源非指定类型，可能存在安全风险或管理问题。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use images from trusted sources. Set the image source type according to your security requirements.\",\n\t\t\"zh\": \"使用来自可信来源的镜像。根据安全要求设置镜像来源类型。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\nhas_specified_image_type(resource) if {\n\timage_id := helpers.get_property(resource, \"ImageId\", \"\")\n\timage_id != \"\"\n}\n\nhas_specified_image_type(resource) if {\n\timage_family := helpers.get_property(resource, \"ImageFamily\", \"\")\n\timage_family != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot has_specified_image_type(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ImageId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-sg-public-access", Name: models.I18nString{"en": "ESS Scaling Configuration Security Group Public Access", "zh": "ESS 伸缩组配置的安全组不应设置为 0.0.0.0/0"}, Severity: "high", Description: models.I18nString{"en": "ESS scaling configuration security groups should not allow access from 0.0.0.0/0 to prevent unauthorized access.", "zh": "ESS 伸缩组配置中的安全组不包含 0.0.0.0/0，则视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling configuration's security group allows access from 0.0.0.0/0, which may expose instances to the public internet.", "zh": "ESS 伸缩组配置的安全组规则中允许 0.0.0.0/0 访问，可能导致实例暴露于公网。"}, Recommendation: models.I18nString{"en": "Restrict security group rules to specific IP ranges instead of 0.0.0.0/0.", "zh": "将安全组规则限制为特定 IP 范围，避免使用 0.0.0.0/0。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-sg-public-access.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_sg_public_access", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_sg_public_access\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-sg-public-access\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration Security Group Public Access\",\n\t\t\"zh\": \"ESS 伸缩组配置的安全组不应设置为 0.0.0.0/0\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configuration security groups should not allow access from 0.0.0.0/0 to prevent unauthorized access.\",\n\t\t\"zh\": \"ESS 伸缩组配置中的安全组不包含 0.0.0.0/0，则视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration's security group allows access from 0.0.0.0/0, which may expose instances to the public internet.\",\n\t\t\"zh\": \"ESS 伸缩组配置的安全组规则中允许 0.0.0.0/0 访问，可能导致实例暴露于公网。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict security group rules to specific IP ranges instead of 0.0.0.0/0.\",\n\t\t\"zh\": \"将安全组规则限制为特定 IP 范围，避免使用 0.0.0.0/0。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\nhas_security_group(resource) if {\n\tsecurity_group_id := helpers.get_property(resource, \"SecurityGroupId\", \"\")\n\tsecurity_group_id != \"\"\n}\n\nhas_security_group(resource) if {\n\tsecurity_group_ids := helpers.get_property(resource, \"SecurityGroupIds\", [])\n\tcount(security_group_ids) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot has_security_group(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": \"The scaling configuration does not have explicit security groups configured.\",\n\t\t\t\"recommendation\": \"Configure specific security groups for the scaling configuration.\",\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-configuration-system-disk-encrypted", Name: models.I18nString{"en": "ESS Scaling Configuration System Disk Encryption", "zh": "弹性伸缩配置中设置系统磁盘加密"}, Severity: "high", Description: models.I18nString{"en": "ESS scaling configurations should enable system disk encryption to protect system data at rest.", "zh": "弹性伸缩配置中系统磁盘配置设置为加密，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling configuration does not have system disk encryption enabled.", "zh": "弹性伸缩配置中的系统磁盘未加密，静态数据可能面临泄露风险。"}, Recommendation: models.I18nString{"en": "Enable system disk encryption in the scaling configuration settings.", "zh": "在伸缩配置中启用系统磁盘加密功能。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingConfiguration"}, FilePath: "aliyun/rules/ess-scaling-configuration-system-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_configuration_system_disk_encrypted", Content: "package infraguard.rules.aliyun.ess_scaling_configuration_system_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-configuration-system-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Configuration System Disk Encryption\",\n\t\t\"zh\": \"弹性伸缩配置中设置系统磁盘加密\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling configurations should enable system disk encryption to protect system data at rest.\",\n\t\t\"zh\": \"弹性伸缩配置中系统磁盘配置设置为加密，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling configuration does not have system disk encryption enabled.\",\n\t\t\"zh\": \"弹性伸缩配置中的系统磁盘未加密，静态数据可能面临泄露风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable system disk encryption in the scaling configuration settings.\",\n\t\t\"zh\": \"在伸缩配置中启用系统磁盘加密功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingConfiguration\"],\n}\n\n# Check if system disk encryption is enabled\nis_system_disk_encrypted(resource) if {\n\tsystem_disk_encrypted := helpers.get_property(resource, \"SystemDiskEncryptAlgorithm\", \"\")\n\tsystem_disk_encrypted != \"\"\n}\n\nis_system_disk_encrypted(resource) if {\n\tkms_key_id := helpers.get_property(resource, \"SystemDiskKMSKeyId\", \"\")\n\tkms_key_id != \"\"\n}\n\n# If no explicit encryption setting, consider it non-compliant\n# Note: Some images have default encryption, but explicit configuration is preferred\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingConfiguration\")\n\tnot is_system_disk_encrypted(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SystemDiskEncryptAlgorithm\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-group-attach-multi-switch", Name: models.I18nString{"en": "ESS Scaling Group Multi-VSwitch", "zh": "弹性伸缩组关联至少两个交换机"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling groups should be associated with at least two VSwitches for high availability across multiple zones.", "zh": "弹性伸缩组关联至少两个交换机，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling group is associated with fewer than two VSwitches, which may affect availability.", "zh": "弹性伸缩组关联的交换机少于两个，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Configure at least two VSwitches in the VSwitchIds property to ensure high availability across multiple zones.", "zh": "在 VSwitchIds 属性中配置至少两个交换机，以确保跨多个可用区的高可用性。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingGroup"}, FilePath: "aliyun/rules/ess-scaling-group-attach-multi-switch.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_group_attach_multi_switch", Content: "package infraguard.rules.aliyun.ess_scaling_group_attach_multi_switch\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-group-attach-multi-switch\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Group Multi-VSwitch\",\n\t\t\"zh\": \"弹性伸缩组关联至少两个交换机\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling groups should be associated with at least two VSwitches for high availability across multiple zones.\",\n\t\t\"zh\": \"弹性伸缩组关联至少两个交换机，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling group is associated with fewer than two VSwitches, which may affect availability.\",\n\t\t\"zh\": \"弹性伸缩组关联的交换机少于两个，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two VSwitches in the VSwitchIds property to ensure high availability across multiple zones.\",\n\t\t\"zh\": \"在 VSwitchIds 属性中配置至少两个交换机，以确保跨多个可用区的高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingGroup\"],\n}\n\n# Check if scaling group has multiple VSwitches\nhas_multiple_vswitches(resource) if {\n\tvswitches := resource.Properties.VSwitchIds\n\tcount(vswitches) >= 2\n}\n\n# Deny rule: ESS scaling groups must have at least two VSwitches\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingGroup\")\n\tnot has_multiple_vswitches(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VSwitchIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-group-attach-slb", Name: models.I18nString{"en": "ESS Scaling Group Attach SLB", "zh": "弹性伸缩组设置关联负载均衡"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling groups should be attached to Classic Load Balancer (SLB) for proper traffic distribution.", "zh": "弹性伸缩组关联传统型负载均衡，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling group is not attached to a Classic Load Balancer, which may affect traffic distribution.", "zh": "弹性伸缩组未关联传统型负载均衡，可能影响流量的分发和可用性。"}, Recommendation: models.I18nString{"en": "Attach the scaling group to a Classic Load Balancer using the LoadBalancerIds property.", "zh": "使用 LoadBalancerIds 属性将伸缩组关联到传统型负载均衡实例。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingGroup"}, FilePath: "aliyun/rules/ess-scaling-group-attach-slb.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_group_attach_slb", Content: "package infraguard.rules.aliyun.ess_scaling_group_attach_slb\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-group-attach-slb\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Group Attach SLB\",\n\t\t\"zh\": \"弹性伸缩组设置关联负载均衡\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling groups should be attached to Classic Load Balancer (SLB) for proper traffic distribution.\",\n\t\t\"zh\": \"弹性伸缩组关联传统型负载均衡，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling group is not attached to a Classic Load Balancer, which may affect traffic distribution.\",\n\t\t\"zh\": \"弹性伸缩组未关联传统型负载均衡，可能影响流量的分发和可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the scaling group to a Classic Load Balancer using the LoadBalancerIds property.\",\n\t\t\"zh\": \"使用 LoadBalancerIds 属性将伸缩组关联到传统型负载均衡实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingGroup\"],\n}\n\n# Check if scaling group has Classic Load Balancer attached\nhas_classic_slb(resource) if {\n\tload_balancer_ids := helpers.get_property(resource, \"LoadBalancerIds\", [])\n\tcount(load_balancer_ids) > 0\n}\n\n# Deny rule: ESS scaling groups should be attached to Classic Load Balancer\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingGroup\")\n\tnot has_classic_slb(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoadBalancerIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ess-scaling-group-loadbalancer-check", Name: models.I18nString{"en": "ESS Scaling Group Load Balancer Existence Check", "zh": "弹性伸缩组关联负载均衡存在性检测"}, Severity: "medium", Description: models.I18nString{"en": "ESS scaling groups should be attached to existing and active Load Balancer instances for proper traffic distribution.", "zh": "弹性伸缩组关联传统型负载均衡或者应用负载均衡仍然为保有中资源，视为合规。"}, Reason: models.I18nString{"en": "The ESS scaling group may be attached to a Load Balancer that no longer exists or is inactive.", "zh": "弹性伸缩组关联的负载均衡可能已不存在或已失效。"}, Recommendation: models.I18nString{"en": "Ensure the Load Balancer IDs referenced in the scaling group are valid and active resources.", "zh": "确保伸缩组中引用的负载均衡 ID 是有效的保有中资源。"}, ResourceTypes: []string{"ALIYUN::ESS::ScalingGroup"}, FilePath: "aliyun/rules/ess-scaling-group-loadbalancer-check.rego", PackageName: "infraguard.rules.aliyun.ess_scaling_group_loadbalancer_check", Content: "package infraguard.rules.aliyun.ess_scaling_group_loadbalancer_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ess-scaling-group-loadbalancer-check\",\n\t\"name\": {\n\t\t\"en\": \"ESS Scaling Group Load Balancer Existence Check\",\n\t\t\"zh\": \"弹性伸缩组关联负载均衡存在性检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"ESS scaling groups should be attached to existing and active Load Balancer instances for proper traffic distribution.\",\n\t\t\"zh\": \"弹性伸缩组关联传统型负载均衡或者应用负载均衡仍然为保有中资源，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ESS scaling group may be attached to a Load Balancer that no longer exists or is inactive.\",\n\t\t\"zh\": \"弹性伸缩组关联的负载均衡可能已不存在或已失效。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure the Load Balancer IDs referenced in the scaling group are valid and active resources.\",\n\t\t\"zh\": \"确保伸缩组中引用的负载均衡 ID 是有效的保有中资源。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ESS::ScalingGroup\"],\n}\n\n# Check if scaling group has load balancer IDs configured\nhas_load_balancer(resource) if {\n\tload_balancer_ids := helpers.get_property(resource, \"LoadBalancerIds\", [])\n\tcount(load_balancer_ids) > 0\n}\n\nhas_load_balancer(resource) if {\n\tserver_groups := helpers.get_property(resource, \"ServerGroups\", [])\n\tcount(server_groups) > 0\n}\n\n# Deny rule: ESS scaling groups should have valid load balancer attachments\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ESS::ScalingGroup\")\n\tnot has_load_balancer(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoadBalancerIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-custom-domain-and-cert-enable", Name: models.I18nString{"en": "FC Function Custom Domain Certificate Check", "zh": "函数计算函数绑定到自定义域名且上传证书"}, Severity: "medium", Description: models.I18nString{"en": "FC custom domains should have SSL certificates configured for secure communication.", "zh": "函数计算函数绑定的自定义域名已上传 SSL 证书，视为合规。"}, Reason: models.I18nString{"en": "The FC custom domain does not have an SSL certificate configured, which may expose traffic to security risks.", "zh": "函数计算自定义域名未配置 SSL 证书，可能导致流量面临安全风险。"}, Recommendation: models.I18nString{"en": "Upload SSL certificates for the custom domain in the FC console or API.", "zh": "在函数计算控制台或 API 为自定义域名上传 SSL 证书。"}, ResourceTypes: []string{"ALIYUN::FC::CustomDomain"}, FilePath: "aliyun/rules/fc-function-custom-domain-and-cert-enable.rego", PackageName: "infraguard.rules.aliyun.fc_function_custom_domain_and_cert_enable", Content: "package infraguard.rules.aliyun.fc_function_custom_domain_and_cert_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-custom-domain-and-cert-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Function Custom Domain Certificate Check\",\n\t\t\"zh\": \"函数计算函数绑定到自定义域名且上传证书\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC custom domains should have SSL certificates configured for secure communication.\",\n\t\t\"zh\": \"函数计算函数绑定的自定义域名已上传 SSL 证书，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC custom domain does not have an SSL certificate configured, which may expose traffic to security risks.\",\n\t\t\"zh\": \"函数计算自定义域名未配置 SSL 证书，可能导致流量面临安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upload SSL certificates for the custom domain in the FC console or API.\",\n\t\t\"zh\": \"在函数计算控制台或 API 为自定义域名上传 SSL 证书。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::CustomDomain\"],\n}\n\n# Check if custom domain has certificate configured\nhas_certificate(resource) if {\n\tcert_config := helpers.get_property(resource, \"CertConfig\", {})\n\tcert_config != {}\n}\n\n# Deny rule: Custom domains should have SSL certificates\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::CustomDomain\")\n\tnot has_certificate(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"CertConfig\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-custom-domain-and-https-enable", Name: models.I18nString{"en": "FC Function Custom Domain HTTPS Check", "zh": "函数计算函数绑定到自定义域名且开启 https"}, Severity: "medium", Description: models.I18nString{"en": "FC custom domains should have HTTPS enabled for secure communication.", "zh": "函数计算函数绑定的自定义域名已开启 HTTPS，视为合规。"}, Reason: models.I18nString{"en": "The FC custom domain does not have HTTPS enabled, which may expose traffic to security risks.", "zh": "函数计算自定义域名未开启 HTTPS，可能导致流量面临安全风险。"}, Recommendation: models.I18nString{"en": "Enable HTTPS for the custom domain in the FC console or API.", "zh": "在函数计算控制台或 API 为自定义域名开启 HTTPS。"}, ResourceTypes: []string{"ALIYUN::FC::CustomDomain"}, FilePath: "aliyun/rules/fc-function-custom-domain-and-https-enable.rego", PackageName: "infraguard.rules.aliyun.fc_function_custom_domain_and_https_enable", Content: "package infraguard.rules.aliyun.fc_function_custom_domain_and_https_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-custom-domain-and-https-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Function Custom Domain HTTPS Check\",\n\t\t\"zh\": \"函数计算函数绑定到自定义域名且开启 https\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC custom domains should have HTTPS enabled for secure communication.\",\n\t\t\"zh\": \"函数计算函数绑定的自定义域名已开启 HTTPS，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC custom domain does not have HTTPS enabled, which may expose traffic to security risks.\",\n\t\t\"zh\": \"函数计算自定义域名未开启 HTTPS，可能导致流量面临安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable HTTPS for the custom domain in the FC console or API.\",\n\t\t\"zh\": \"在函数计算控制台或 API 为自定义域名开启 HTTPS。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::CustomDomain\"],\n}\n\n# Check if custom domain has HTTPS enabled via protocol\nhas_https_enabled(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol == \"HTTPS\"\n}\n\nhas_https_enabled(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol == \"HTTP,HTTPS\"\n}\n\n# Deny rule: Custom domains should have HTTPS enabled\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::CustomDomain\")\n\tnot has_https_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Protocol\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-custom-domain-and-tls-enable", Name: models.I18nString{"en": "FC Function Custom Domain and TLS Enabled", "zh": "FC 函数自定义域名及 TLS 开启"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that custom domains for Function Compute functions have TLS enabled.", "zh": "确保函数计算函数的自定义域名已开启 TLS。"}, Reason: models.I18nString{"en": "TLS encrypts traffic to your function, ensuring data confidentiality and integrity.", "zh": "TLS 对到函数的流量进行加密，确保数据机密性和完整性。"}, Recommendation: models.I18nString{"en": "Configure an SSL certificate and enable TLS for the Function Compute custom domain.", "zh": "为函数计算自定义域名配置 SSL 证书并开启 TLS。"}, ResourceTypes: []string{"ALIYUN::FC::CustomDomain"}, FilePath: "aliyun/rules/fc-function-custom-domain-and-tls-enable.rego", PackageName: "infraguard.rules.aliyun.fc_function_custom_domain_and_tls_enable", Content: "package infraguard.rules.aliyun.fc_function_custom_domain_and_tls_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-custom-domain-and-tls-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Function Custom Domain and TLS Enabled\",\n\t\t\"zh\": \"FC 函数自定义域名及 TLS 开启\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that custom domains for Function Compute functions have TLS enabled.\",\n\t\t\"zh\": \"确保函数计算函数的自定义域名已开启 TLS。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"TLS encrypts traffic to your function, ensuring data confidentiality and integrity.\",\n\t\t\"zh\": \"TLS 对到函数的流量进行加密，确保数据机密性和完整性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure an SSL certificate and enable TLS for the Function Compute custom domain.\",\n\t\t\"zh\": \"为函数计算自定义域名配置 SSL 证书并开启 TLS。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::CustomDomain\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::CustomDomain\")\n\n\t# Conceptual check for TLS\n\tnot helpers.has_property(resource, \"CertConfig\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-internet-and-custom-domain-enable", Name: models.I18nString{"en": "FC Service Internet Access with Custom Domain", "zh": "函数计算服务允许访问公网且绑定到自定义域名"}, Severity: "medium", Description: models.I18nString{"en": "FC services with internet access should be bound to custom domains for proper access control.", "zh": "函数计算服务在允许公网访问时绑定了自定义域名，视为合规。"}, Reason: models.I18nString{"en": "The FC service allows internet access but may not have custom domains configured.", "zh": "函数计算服务允许访问公网，但可能未配置自定义域名。"}, Recommendation: models.I18nString{"en": "Configure custom domains for FC services that need internet access.", "zh": "为需要公网访问的函数计算服务配置自定义域名。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-function-internet-and-custom-domain-enable.rego", PackageName: "infraguard.rules.aliyun.fc_function_internet_and_custom_domain_enable", Content: "package infraguard.rules.aliyun.fc_function_internet_and_custom_domain_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-internet-and-custom-domain-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Service Internet Access with Custom Domain\",\n\t\t\"zh\": \"函数计算服务允许访问公网且绑定到自定义域名\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC services with internet access should be bound to custom domains for proper access control.\",\n\t\t\"zh\": \"函数计算服务在允许公网访问时绑定了自定义域名，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC service allows internet access but may not have custom domains configured.\",\n\t\t\"zh\": \"函数计算服务允许访问公网，但可能未配置自定义域名。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure custom domains for FC services that need internet access.\",\n\t\t\"zh\": \"为需要公网访问的函数计算服务配置自定义域名。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\n# Check if service has internet access\nhas_internet_access(resource) if {\n\thelpers.get_property(resource, \"InternetAccess\", false) == true\n}\n\n# Check if any custom domain exists in the template (regardless of service)\nhas_custom_domain_in_template if {\n\tcount(helpers.resources_by_type(\"ALIYUN::FC::CustomDomain\")) > 0\n}\n\n# Deny rule: FC services with internet access should have custom domains in template\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\thas_internet_access(resource)\n\tnot has_custom_domain_in_template\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetAccess\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-runtime-check", Name: models.I18nString{"en": "FC Function Runtime Check", "zh": "FC 未使用废弃的运行时"}, Severity: "high", Description: models.I18nString{"en": "FC functions should not use deprecated runtimes that may have security vulnerabilities.", "zh": "FC 使用的运行时未废弃，则视为合规。截止 2025-04-20，本规则检测废弃版本清单为：nodejs12,nodejs10,nodejs8,dotnetcore2.1,python2.7,nodejs6,nodejs4.4。"}, Reason: models.I18nString{"en": "The FC function is using a deprecated runtime that may have security vulnerabilities.", "zh": "FC 函数使用了已废弃的运行时，可能存在安全漏洞。"}, Recommendation: models.I18nString{"en": "Migrate the function to a supported runtime version. See FC documentation for supported runtimes.", "zh": "将函数迁移到支持的运行时版本。请参阅 FC 文档了解支持的运行时。"}, ResourceTypes: []string{"ALIYUN::FC::Function"}, FilePath: "aliyun/rules/fc-function-runtime-check.rego", PackageName: "infraguard.rules.aliyun.fc_function_runtime_check", Content: "package infraguard.rules.aliyun.fc_function_runtime_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-runtime-check\",\n\t\"name\": {\n\t\t\"en\": \"FC Function Runtime Check\",\n\t\t\"zh\": \"FC 未使用废弃的运行时\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"FC functions should not use deprecated runtimes that may have security vulnerabilities.\",\n\t\t\"zh\": \"FC 使用的运行时未废弃，则视为合规。截止 2025-04-20，本规则检测废弃版本清单为：nodejs12,nodejs10,nodejs8,dotnetcore2.1,python2.7,nodejs6,nodejs4.4。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC function is using a deprecated runtime that may have security vulnerabilities.\",\n\t\t\"zh\": \"FC 函数使用了已废弃的运行时，可能存在安全漏洞。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Migrate the function to a supported runtime version. See FC documentation for supported runtimes.\",\n\t\t\"zh\": \"将函数迁移到支持的运行时版本。请参阅 FC 文档了解支持的运行时。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Function\"],\n}\n\n# Deprecated runtimes as of the specified date (using Set for string key lookup)\ndeprecated_runtimes := {\n\t\"nodejs12\",\n\t\"nodejs10\",\n\t\"nodejs8\",\n\t\"dotnetcore2.1\",\n\t\"python2.7\",\n\t\"nodejs6\",\n\t\"nodejs4.4\",\n}\n\n# Deny rule: FC functions must not use deprecated runtimes\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Function\")\n\truntime := helpers.get_property(resource, \"Runtime\", \"\")\n\tdeprecated_runtimes[runtime]\n\tresult := {\n\t\t\"id\": \"fc-function-runtime-check\",\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Runtime\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": \"high\",\n\t\t\t\"reason\": \"The FC function is using a deprecated runtime that may have security vulnerabilities.\",\n\t\t\t\"recommendation\": \"Migrate the function to a supported runtime version.\",\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-function-settings-check", Name: models.I18nString{"en": "FC Function Settings Check", "zh": "函数计算中函数设置满足参数指定要求"}, Severity: "medium", Description: models.I18nString{"en": "FC function settings should meet specified requirements for optimal performance and security.", "zh": "函数计算 2.0 中的函数设置满足参数指定的要求，视为合规。"}, Reason: models.I18nString{"en": "The FC function settings may not meet the specified requirements.", "zh": "函数计算中的函数设置可能不满足指定要求。"}, Recommendation: models.I18nString{"en": "Review and update function settings according to your organization's requirements.", "zh": "根据组织要求审查和更新函数设置。"}, ResourceTypes: []string{"ALIYUN::FC::Function"}, FilePath: "aliyun/rules/fc-function-settings-check.rego", PackageName: "infraguard.rules.aliyun.fc_function_settings_check", Content: "package infraguard.rules.aliyun.fc_function_settings_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-function-settings-check\",\n\t\"name\": {\n\t\t\"en\": \"FC Function Settings Check\",\n\t\t\"zh\": \"函数计算中函数设置满足参数指定要求\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC function settings should meet specified requirements for optimal performance and security.\",\n\t\t\"zh\": \"函数计算 2.0 中的函数设置满足参数指定的要求，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC function settings may not meet the specified requirements.\",\n\t\t\"zh\": \"函数计算中的函数设置可能不满足指定要求。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Review and update function settings according to your organization's requirements.\",\n\t\t\"zh\": \"根据组织要求审查和更新函数设置。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Function\"],\n}\n\n# Deny rule: FC functions should have valid settings\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Function\")\n\thandler := helpers.get_property(resource, \"Handler\", \"\")\n\thandler == \"\"\n\tresult := {\n\t\t\"id\": \"fc-function-settings-check\",\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Handler\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": \"medium\",\n\t\t\t\"reason\": \"The function does not have valid settings configured.\",\n\t\t\t\"recommendation\": \"Configure proper Handler for the function.\",\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-service-bind-role", Name: models.I18nString{"en": "FC Service Bound to RAM Role", "zh": "FC 服务绑定角色"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the Function Compute service has a RAM role bound to it.", "zh": "确保函数计算服务绑定了 RAM 角色。"}, Reason: models.I18nString{"en": "Binding a RAM role to an FC service allows the function to securely access other Alibaba Cloud resources.", "zh": "为 FC 服务绑定 RAM 角色允许函数安全地访问其他阿里云资源。"}, Recommendation: models.I18nString{"en": "Bind a RAM role to the Function Compute service.", "zh": "为函数计算服务绑定 RAM 角色。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-service-bind-role.rego", PackageName: "infraguard.rules.aliyun.fc_service_bind_role", Content: "package infraguard.rules.aliyun.fc_service_bind_role\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-service-bind-role\",\n\t\"name\": {\n\t\t\"en\": \"FC Service Bound to RAM Role\",\n\t\t\"zh\": \"FC 服务绑定角色\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the Function Compute service has a RAM role bound to it.\",\n\t\t\"zh\": \"确保函数计算服务绑定了 RAM 角色。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Binding a RAM role to an FC service allows the function to securely access other Alibaba Cloud resources.\",\n\t\t\"zh\": \"为 FC 服务绑定 RAM 角色允许函数安全地访问其他阿里云资源。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Bind a RAM role to the Function Compute service.\",\n\t\t\"zh\": \"为函数计算服务绑定 RAM 角色。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\tnot helpers.has_property(resource, \"Role\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Role\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-service-internet-access-disable", Name: models.I18nString{"en": "FC Service Internet Access Disabled", "zh": "FC 服务禁用公网访问"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the Function Compute service has internet access disabled when it should only access internal resources.", "zh": "确保函数计算服务在仅需访问内网资源时已禁用公网访问。"}, Reason: models.I18nString{"en": "Disabling internet access for FC services reduces the attack surface and potential for data exfiltration.", "zh": "为 FC 服务禁用公网访问可减少攻击面和潜在的数据泄露风险。"}, Recommendation: models.I18nString{"en": "Disable internet access for the Function Compute service.", "zh": "为函数计算服务禁用公网访问。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-service-internet-access-disable.rego", PackageName: "infraguard.rules.aliyun.fc_service_internet_access_disable", Content: "package infraguard.rules.aliyun.fc_service_internet_access_disable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-service-internet-access-disable\",\n\t\"name\": {\n\t\t\"en\": \"FC Service Internet Access Disabled\",\n\t\t\"zh\": \"FC 服务禁用公网访问\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the Function Compute service has internet access disabled when it should only access internal resources.\",\n\t\t\"zh\": \"确保函数计算服务在仅需访问内网资源时已禁用公网访问。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Disabling internet access for FC services reduces the attack surface and potential for data exfiltration.\",\n\t\t\"zh\": \"为 FC 服务禁用公网访问可减少攻击面和潜在的数据泄露风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable internet access for the Function Compute service.\",\n\t\t\"zh\": \"为函数计算服务禁用公网访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\thelpers.get_property(resource, \"InternetAccess\", true)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"InternetAccess\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-service-log-enable", Name: models.I18nString{"en": "FC Service Log Enable", "zh": "函数计算服务启用日志功能"}, Severity: "medium", Description: models.I18nString{"en": "FC services should have logging enabled for monitoring and troubleshooting.", "zh": "函数计算服务启用日志功能，视为合规。"}, Reason: models.I18nString{"en": "The FC service does not have logging enabled, which may affect troubleshooting and auditing.", "zh": "函数计算服务未启用日志功能，可能影响问题排查和审计。"}, Recommendation: models.I18nString{"en": "Enable logging for the FC service by configuring LogConfig with Logstore and Project.", "zh": "通过配置 LogConfig（包含 Logstore 和 Project）为函数计算服务启用日志。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-service-log-enable.rego", PackageName: "infraguard.rules.aliyun.fc_service_log_enable", Content: "package infraguard.rules.aliyun.fc_service_log_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"fc-service-log-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Service Log Enable\",\n\t\t\"zh\": \"函数计算服务启用日志功能\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC services should have logging enabled for monitoring and troubleshooting.\",\n\t\t\"zh\": \"函数计算服务启用日志功能，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC service does not have logging enabled, which may affect troubleshooting and auditing.\",\n\t\t\"zh\": \"函数计算服务未启用日志功能，可能影响问题排查和审计。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable logging for the FC service by configuring LogConfig with Logstore and Project.\",\n\t\t\"zh\": \"通过配置 LogConfig（包含 Logstore 和 Project）为函数计算服务启用日志。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\tlog_config := helpers.get_property(resource, \"LogConfig\", {})\n\tlog_config == {}\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LogConfig\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-service-tracing-enable", Name: models.I18nString{"en": "FC Service Tracing Enable", "zh": "函数计算服务启用链路追踪"}, Severity: "medium", Description: models.I18nString{"en": "FC services should have tracing enabled for performance monitoring and debugging.", "zh": "函数计算服务启用链路追踪功能，视为合规。"}, Reason: models.I18nString{"en": "The FC service does not have tracing enabled, which may affect performance analysis.", "zh": "函数计算服务未启用链路追踪，可能影响性能分析和问题排查。"}, Recommendation: models.I18nString{"en": "Enable tracing for the FC service by configuring TracingConfig.", "zh": "通过配置 TracingConfig 为函数计算服务启用链路追踪。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-service-tracing-enable.rego", PackageName: "infraguard.rules.aliyun.fc_service_tracing_enable", Content: "package infraguard.rules.aliyun.fc_service_tracing_enable\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"fc-service-tracing-enable\",\n\t\"name\": {\n\t\t\"en\": \"FC Service Tracing Enable\",\n\t\t\"zh\": \"函数计算服务启用链路追踪\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"FC services should have tracing enabled for performance monitoring and debugging.\",\n\t\t\"zh\": \"函数计算服务启用链路追踪功能，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC service does not have tracing enabled, which may affect performance analysis.\",\n\t\t\"zh\": \"函数计算服务未启用链路追踪，可能影响性能分析和问题排查。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable tracing for the FC service by configuring TracingConfig.\",\n\t\t\"zh\": \"通过配置 TracingConfig 为函数计算服务启用链路追踪。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\ttracing_config := helpers.get_property(resource, \"TracingConfig\", {})\n\ttracing_config == {}\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TracingConfig\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-service-vpc-binding", Name: models.I18nString{"en": "FC Service VPC Binding Enabled", "zh": "FC 服务绑定 VPC"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the Function Compute service is configured to access resources within a VPC.", "zh": "确保函数计算服务已配置为访问 VPC 内的资源。"}, Reason: models.I18nString{"en": "Binding a VPC to an FC service allows functions to securely access internal resources like databases and internal APIs.", "zh": "为 FC 服务绑定 VPC 允许函数安全地访问内网资源，如数据库和内部 API。"}, Recommendation: models.I18nString{"en": "Configure VPC access for the Function Compute service.", "zh": "为函数计算服务配置 VPC 访问。"}, ResourceTypes: []string{"ALIYUN::FC::Service"}, FilePath: "aliyun/rules/fc-service-vpc-binding.rego", PackageName: "infraguard.rules.aliyun.fc_service_vpc_binding", Content: "package infraguard.rules.aliyun.fc_service_vpc_binding\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-service-vpc-binding\",\n\t\"name\": {\n\t\t\"en\": \"FC Service VPC Binding Enabled\",\n\t\t\"zh\": \"FC 服务绑定 VPC\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the Function Compute service is configured to access resources within a VPC.\",\n\t\t\"zh\": \"确保函数计算服务已配置为访问 VPC 内的资源。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Binding a VPC to an FC service allows functions to securely access internal resources like databases and internal APIs.\",\n\t\t\"zh\": \"为 FC 服务绑定 VPC 允许函数安全地访问内网资源，如数据库和内部 API。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure VPC access for the Function Compute service.\",\n\t\t\"zh\": \"为函数计算服务配置 VPC 访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Service\")\n\tnot helpers.has_property(resource, \"VpcConfig\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcConfig\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:fc-trigger-http-not-anonymous", Name: models.I18nString{"en": "FC HTTP Trigger Authentication Check", "zh": "函数 HTTP 触发器设置为需要身份验证"}, Severity: "high", Description: models.I18nString{"en": "FC HTTP triggers should require authentication to prevent unauthorized access.", "zh": "函数 HTTP 触发器配置为需要身份验证，视为合规。"}, Reason: models.I18nString{"en": "The FC HTTP trigger allows anonymous access, which may expose the function to unauthorized invocations.", "zh": "函数 HTTP 触发器允许匿名访问，可能导致未经授权的函数调用。"}, Recommendation: models.I18nString{"en": "Configure authentication for the HTTP trigger by setting appropriate authorization type.", "zh": "为 HTTP 触发器配置适当的授权类型以启用身份验证。"}, ResourceTypes: []string{"ALIYUN::FC::Trigger"}, FilePath: "aliyun/rules/fc-trigger-http-not-anonymous.rego", PackageName: "infraguard.rules.aliyun.fc_trigger_http_not_anonymous", Content: "package infraguard.rules.aliyun.fc_trigger_http_not_anonymous\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"fc-trigger-http-not-anonymous\",\n\t\"name\": {\n\t\t\"en\": \"FC HTTP Trigger Authentication Check\",\n\t\t\"zh\": \"函数 HTTP 触发器设置为需要身份验证\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"FC HTTP triggers should require authentication to prevent unauthorized access.\",\n\t\t\"zh\": \"函数 HTTP 触发器配置为需要身份验证，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The FC HTTP trigger allows anonymous access, which may expose the function to unauthorized invocations.\",\n\t\t\"zh\": \"函数 HTTP 触发器允许匿名访问，可能导致未经授权的函数调用。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure authentication for the HTTP trigger by setting appropriate authorization type.\",\n\t\t\"zh\": \"为 HTTP 触发器配置适当的授权类型以启用身份验证。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::FC::Trigger\"],\n}\n\n# Check if trigger is HTTP type and allows anonymous access\nis_anonymous_http_trigger(resource) if {\n\ttrigger_type := helpers.get_property(resource, \"TriggerType\", \"\")\n\ttrigger_type == \"http\"\n\ttrigger_config := helpers.get_property(resource, \"TriggerConfig\", {})\n\tauth_type := object.get(trigger_config, \"AuthType\", \"\")\n\tauth_type == \"anonymous\"\n}\n\n# Deny rule: HTTP triggers should not allow anonymous access\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::FC::Trigger\")\n\tis_anonymous_http_trigger(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TriggerConfig\", \"AuthType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:firewall-asset-open-protect", Name: models.I18nString{"en": "Cloud Firewall Asset Protection Enabled", "zh": "云防火墙资产开启保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures assets are protected by Cloud Firewall.", "zh": "确保资产已受云防火墙保护。"}, Reason: models.I18nString{"en": "Unprotected assets are vulnerable to internet-based threats.", "zh": "未受保护的资产容易受到来自互联网的威胁。"}, Recommendation: models.I18nString{"en": "Add ALIYUN::CLOUDFW::FwSwitch resource to enable protection for all public-facing assets in Cloud Firewall.", "zh": "添加 ALIYUN::CLOUDFW::FwSwitch 资源以在云防火墙中为所有面向公网的资产开启保护。"}, ResourceTypes: []string{"ALIYUN::CLOUDFW::FwSwitch"}, FilePath: "aliyun/rules/firewall-asset-open-protect.rego", PackageName: "infraguard.rules.aliyun.firewall_asset_open_protect", Content: "package infraguard.rules.aliyun.firewall_asset_open_protect\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"firewall-asset-open-protect\",\n\t\"name\": {\n\t\t\"en\": \"Cloud Firewall Asset Protection Enabled\",\n\t\t\"zh\": \"云防火墙资产开启保护\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures assets are protected by Cloud Firewall.\",\n\t\t\"zh\": \"确保资产已受云防火墙保护。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Unprotected assets are vulnerable to internet-based threats.\",\n\t\t\"zh\": \"未受保护的资产容易受到来自互联网的威胁。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add ALIYUN::CLOUDFW::FwSwitch resource to enable protection for all public-facing assets in Cloud Firewall.\",\n\t\t\"zh\": \"添加 ALIYUN::CLOUDFW::FwSwitch 资源以在云防火墙中为所有面向公网的资产开启保护。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::CLOUDFW::FwSwitch\"],\n}\n\n# ALIYUN::CLOUDFW::FwSwitch resource existence means protection is enabled\n# This rule only checks if FwSwitch resources exist in the template\n# If no FwSwitch resource exists, we cannot verify protection at template level\n# This is a conceptual check that requires runtime verification\n# We only flag violations if there are other resources that might need protection\n# but no FwSwitch resources exist\n\n# Check if template has any resources that might need firewall protection\n# Exclude dummy resources like ALIYUN::ROS::WaitConditionHandle\nhas_resources_needing_protection if {\n\tsome name, resource in input.Resources\n\tresource.Type != \"ALIYUN::ROS::WaitConditionHandle\"\n}\n\n# Only flag violation if there are resources but no FwSwitch\ndeny contains result if {\n\thas_resources_needing_protection\n\tcount(helpers.resources_by_type(\"ALIYUN::CLOUDFW::FwSwitch\")) == 0\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"\",\n\t\t\"violation_path\": [\"Resources\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:gpdb-instance-disk-encryption-enabled", Name: models.I18nString{"en": "GPDB Disk Encryption Enabled", "zh": "GPDB 开启磁盘加密"}, Severity: "high", Description: models.I18nString{"en": "Ensures GPDB instances have disk encryption enabled.", "zh": "确保 GPDB 实例开启了磁盘加密。"}, Reason: models.I18nString{"en": "Encryption at rest protects sensitive database files from unauthorized access.", "zh": "静态加密保护敏感数据库文件免受未经授权的访问。"}, Recommendation: models.I18nString{"en": "Enable disk encryption using KMS for the GPDB instance.", "zh": "使用 KMS 为 GPDB 实例开启磁盘加密。"}, ResourceTypes: []string{"ALIYUN::GPDB::DBInstance"}, FilePath: "aliyun/rules/gpdb-instance-disk-encryption-enabled.rego", PackageName: "infraguard.rules.aliyun.gpdb_instance_disk_encryption_enabled", Content: "package infraguard.rules.aliyun.gpdb_instance_disk_encryption_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"gpdb-instance-disk-encryption-enabled\",\n\t\"name\": {\n\t\t\"en\": \"GPDB Disk Encryption Enabled\",\n\t\t\"zh\": \"GPDB 开启磁盘加密\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures GPDB instances have disk encryption enabled.\",\n\t\t\"zh\": \"确保 GPDB 实例开启了磁盘加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Encryption at rest protects sensitive database files from unauthorized access.\",\n\t\t\"zh\": \"静态加密保护敏感数据库文件免受未经授权的访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable disk encryption using KMS for the GPDB instance.\",\n\t\t\"zh\": \"使用 KMS 为 GPDB 实例开启磁盘加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::GPDB::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\t# EncryptionKey being set usually indicates encryption is enabled.\n\thelpers.has_property(resource, \"EncryptionKey\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::GPDB::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EncryptionKey\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:gpdb-instance-multi-zone", Name: models.I18nString{"en": "GPDB Instance Multi-Zone Deployment", "zh": "使用多可用区的云原生数据仓库 AnalyticDB 实例"}, Severity: "medium", Description: models.I18nString{"en": "GPDB instances should be deployed with a standby zone for high availability.", "zh": "使用多可用区的云原生数据仓库 AnalyticDB 实例，视为合规。"}, Reason: models.I18nString{"en": "The GPDB instance does not have a standby zone configured, which may affect availability.", "zh": "GPDB 实例未配置备用可用区，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Configure a standby zone by setting the StandbyZoneId property to enable multi-zone deployment.", "zh": "通过设置 StandbyZoneId 属性配置备用可用区，以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::GPDB::DBInstance"}, FilePath: "aliyun/rules/gpdb-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.gpdb_instance_multi_zone", Content: "package infraguard.rules.aliyun.gpdb_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"gpdb-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"GPDB Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的云原生数据仓库 AnalyticDB 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"GPDB instances should be deployed with a standby zone for high availability.\",\n\t\t\"zh\": \"使用多可用区的云原生数据仓库 AnalyticDB 实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The GPDB instance does not have a standby zone configured, which may affect availability.\",\n\t\t\"zh\": \"GPDB 实例未配置备用可用区，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a standby zone by setting the StandbyZoneId property to enable multi-zone deployment.\",\n\t\t\"zh\": \"通过设置 StandbyZoneId 属性配置备用可用区，以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::GPDB::DBInstance\"],\n}\n\n# Check if instance has standby zone\nhas_standby_zone(resource) if {\n\thelpers.has_property(resource, \"StandbyZoneId\")\n\tstandby_zone := resource.Properties.StandbyZoneId\n\tstandby_zone != \"\"\n}\n\n# Deny rule: GPDB instances should have standby zone\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::GPDB::DBInstance\")\n\tnot has_standby_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"StandbyZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:gwlb-loadbalancer-multi-zone", Name: models.I18nString{"en": "GWLB LoadBalancer Multi-Zone Deployment", "zh": "使用多可用区的网关型负载均衡实例"}, Severity: "medium", Description: models.I18nString{"en": "GWLB LoadBalancer instances should be deployed across at least two availability zones for high availability.", "zh": "使用多可用区的网关型负载均衡实例，视为合规。"}, Reason: models.I18nString{"en": "The GWLB LoadBalancer is deployed in fewer than two availability zones, creating a single point of failure risk.", "zh": "网关型负载均衡实例部署在少于两个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure at least two zone mappings in the ZoneMappings property to ensure high availability.", "zh": "在 ZoneMappings 属性中配置至少两个可用区映射，以确保高可用性。"}, ResourceTypes: []string{"ALIYUN::GWLB::LoadBalancer"}, FilePath: "aliyun/rules/gwlb-loadbalancer-multi-zone.rego", PackageName: "infraguard.rules.aliyun.gwlb_loadbalancer_multi_zone", Content: "package infraguard.rules.aliyun.gwlb_loadbalancer_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"gwlb-loadbalancer-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"GWLB LoadBalancer Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的网关型负载均衡实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"GWLB LoadBalancer instances should be deployed across at least two availability zones for high availability.\",\n\t\t\"zh\": \"使用多可用区的网关型负载均衡实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The GWLB LoadBalancer is deployed in fewer than two availability zones, creating a single point of failure risk.\",\n\t\t\"zh\": \"网关型负载均衡实例部署在少于两个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two zone mappings in the ZoneMappings property to ensure high availability.\",\n\t\t\"zh\": \"在 ZoneMappings 属性中配置至少两个可用区映射，以确保高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::GWLB::LoadBalancer\"],\n}\n\n# Check if LoadBalancer has multiple zones\nhas_multiple_zones(resource) if {\n\tzone_mappings := resource.Properties.ZoneMappings\n\tcount(zone_mappings) >= 2\n}\n\n# Deny rule: GWLB LoadBalancers must be deployed in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::GWLB::LoadBalancer\")\n\tnot has_multiple_zones(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneMappings\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-deletion-protection", Name: models.I18nString{"en": "HBase Cluster Deletion Protection Enabled", "zh": "HBase 集群开启删除保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that HBase clusters have deletion protection enabled.", "zh": "确保 HBase 集群开启了删除保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the HBase cluster may be released accidentally, causing data loss.", "zh": "如果未开启删除保护，HBase 集群可能会被意外释放，导致数据丢失。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the HBase cluster.", "zh": "为 HBase 集群开启删除保护功能。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-deletion-protection.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_deletion_protection", Content: "package infraguard.rules.aliyun.hbase_cluster_deletion_protection\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"hbase-cluster-deletion-protection\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster Deletion Protection Enabled\",\n\t\t\"zh\": \"HBase 集群开启删除保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that HBase clusters have deletion protection enabled.\",\n\t\t\"zh\": \"确保 HBase 集群开启了删除保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the HBase cluster may be released accidentally, causing data loss.\",\n\t\t\"zh\": \"如果未开启删除保护，HBase 集群可能会被意外释放，导致数据丢失。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the HBase cluster.\",\n\t\t\"zh\": \"为 HBase 集群开启删除保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::HBase::Cluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-expired-check", Name: models.I18nString{"en": "HBase Cluster Expiration Check", "zh": "HBase 集群到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid HBase clusters should have auto-renewal enabled.", "zh": "预付费 HBase 集群应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid HBase cluster does not have auto-renewal enabled.", "zh": "预付费 HBase 集群未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid HBase cluster by setting AutoRenewPeriod to a value greater than 0.", "zh": "通过将 AutoRenewPeriod 设置为大于 0 的值来开启自动续费。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-expired-check.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_expired_check", Content: "package infraguard.rules.aliyun.hbase_cluster_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"hbase-cluster-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster Expiration Check\",\n\t\t\"zh\": \"HBase 集群到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid HBase clusters should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 HBase 集群应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid HBase cluster does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 HBase 集群未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid HBase cluster by setting AutoRenewPeriod to a value greater than 0.\",\n\t\t\"zh\": \"通过将 AutoRenewPeriod 设置为大于 0 的值来开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\nis_prepaid(resource) if {\n\thelpers.get_property(resource, \"PayType\", \"Postpaid\") == \"Prepaid\"\n}\n\nis_auto_renew_enabled(resource) if {\n\tperiod := helpers.get_property(resource, \"AutoRenewPeriod\", 0)\n\tperiod > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenewPeriod\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-ha-check", Name: models.I18nString{"en": "HBase Cluster HA Enabled", "zh": "HBase 集群强制开启高可用"}, Severity: "high", Description: models.I18nString{"en": "Ensures HBase clusters are configured for High Availability (HA).", "zh": "确保 HBase 集群配置为高可用（HA）模式。"}, Reason: models.I18nString{"en": "Non-HA clusters are single points of failure and may lead to service downtime.", "zh": "非高可用集群存在单点故障风险，可能导致服务中断。"}, Recommendation: models.I18nString{"en": "Ensure NodeCount is sufficient for HA (at least 2 for disk-based, 3 for local disks).", "zh": "确保节点数量满足高可用要求（磁盘型至少 2 个，本地盘型至少 3 个）。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-ha-check.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_ha_check", Content: "package infraguard.rules.aliyun.hbase_cluster_ha_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"hbase-cluster-ha-check\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster HA Enabled\",\n\t\t\"zh\": \"HBase 集群强制开启高可用\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures HBase clusters are configured for High Availability (HA).\",\n\t\t\"zh\": \"确保 HBase 集群配置为高可用（HA）模式。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Non-HA clusters are single points of failure and may lead to service downtime.\",\n\t\t\"zh\": \"非高可用集群存在单点故障风险，可能导致服务中断。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure NodeCount is sufficient for HA (at least 2 for disk-based, 3 for local disks).\",\n\t\t\"zh\": \"确保节点数量满足高可用要求（磁盘型至少 2 个，本地盘型至少 3 个）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\nis_compliant(resource) if {\n\tcount := helpers.get_property(resource, \"NodeCount\", 1)\n\tcount >= 2\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::HBase::Cluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NodeCount\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-in-vpc", Name: models.I18nString{"en": "HBase Cluster in VPC", "zh": "HBase 集群在 VPC 内"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the HBase cluster is deployed within a VPC.", "zh": "确保 HBase 集群部署在 VPC 内。"}, Reason: models.I18nString{"en": "Deploying HBase in a VPC provides better network isolation and security.", "zh": "在 VPC 中部署 HBase 可提供更好的网络隔离和安全性。"}, Recommendation: models.I18nString{"en": "Deploy the HBase cluster within a VPC.", "zh": "将 HBase 集群部署在 VPC 内。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-in-vpc.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_in_vpc", Content: "package infraguard.rules.aliyun.hbase_cluster_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"hbase-cluster-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster in VPC\",\n\t\t\"zh\": \"HBase 集群在 VPC 内\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the HBase cluster is deployed within a VPC.\",\n\t\t\"zh\": \"确保 HBase 集群部署在 VPC 内。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Deploying HBase in a VPC provides better network isolation and security.\",\n\t\t\"zh\": \"在 VPC 中部署 HBase 可提供更好的网络隔离和安全性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy the HBase cluster within a VPC.\",\n\t\t\"zh\": \"将 HBase 集群部署在 VPC 内。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::HBase::Cluster\")\n\tnot helpers.has_property(resource, \"VpcId\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-multi-zone", Name: models.I18nString{"en": "HBase Cluster Multi-Zone Deployment", "zh": "使用多可用区的 HBase 集群"}, Severity: "medium", Description: models.I18nString{"en": "HBase clusters should be deployed in cluster mode with at least 2 nodes for high availability.", "zh": "使用多可用区的 HBase 集群，视为合规。"}, Reason: models.I18nString{"en": "The HBase cluster is deployed in single-node mode, which does not provide high availability.", "zh": "HBase 集群部署在单节点模式，不提供高可用性。"}, Recommendation: models.I18nString{"en": "Deploy HBase cluster in cluster mode by setting NodeCount to at least 2 for high availability.", "zh": "通过将 NodeCount 设置为至少 2 来部署 HBase 集群的集群模式，以实现高可用性。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-multi-zone.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_multi_zone", Content: "package infraguard.rules.aliyun.hbase_cluster_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"hbase-cluster-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 HBase 集群\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"HBase clusters should be deployed in cluster mode with at least 2 nodes for high availability.\",\n\t\t\"zh\": \"使用多可用区的 HBase 集群，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The HBase cluster is deployed in single-node mode, which does not provide high availability.\",\n\t\t\"zh\": \"HBase 集群部署在单节点模式，不提供高可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy HBase cluster in cluster mode by setting NodeCount to at least 2 for high availability.\",\n\t\t\"zh\": \"通过将 NodeCount 设置为至少 2 来部署 HBase 集群的集群模式，以实现高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\n# Check if cluster is in cluster mode (at least 2 nodes)\nis_cluster_mode(resource) if {\n\tnode_count := resource.Properties.NodeCount\n\tnode_count >= 2\n}\n\n# Deny rule: HBase clusters should be in cluster mode\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::HBase::Cluster\")\n\tnot is_cluster_mode(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NodeCount\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:hbase-cluster-type-check", Name: models.I18nString{"en": "HBase Cluster Type Check", "zh": "HBase 集群实例类型检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that the HBase cluster is of a specified or recommended type.", "zh": "确保 HBase 集群是指定的或推荐的类型。"}, Reason: models.I18nString{"en": "Using the correct cluster type ensures optimal performance and support for your workload.", "zh": "使用正确的集群类型可确保您的工作负载获得最佳性能和支持。"}, Recommendation: models.I18nString{"en": "Select a recommended HBase cluster type.", "zh": "选择推荐的 HBase 集群类型。"}, ResourceTypes: []string{"ALIYUN::HBase::Cluster"}, FilePath: "aliyun/rules/hbase-cluster-type-check.rego", PackageName: "infraguard.rules.aliyun.hbase_cluster_type_check", Content: "package infraguard.rules.aliyun.hbase_cluster_type_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"hbase-cluster-type-check\",\n\t\"name\": {\n\t\t\"en\": \"HBase Cluster Type Check\",\n\t\t\"zh\": \"HBase 集群实例类型检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the HBase cluster is of a specified or recommended type.\",\n\t\t\"zh\": \"确保 HBase 集群是指定的或推荐的类型。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using the correct cluster type ensures optimal performance and support for your workload.\",\n\t\t\"zh\": \"使用正确的集群类型可确保您的工作负载获得最佳性能和支持。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Select a recommended HBase cluster type.\",\n\t\t\"zh\": \"选择推荐的 HBase 集群类型。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::HBase::Cluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::HBase::Cluster\")\n\thelpers.get_property(resource, \"ClusterType\", \"\") == \"deprecated\"\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ClusterType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:internet-nat-gateway-in-specified-vpc", Name: models.I18nString{"en": "Internet NAT Gateway in Specified VPC", "zh": "公网 NAT 网关创建在指定专有网络内"}, Severity: "medium", Description: models.I18nString{"en": "Internet-facing NAT gateways should be created in specified VPCs according to network security requirements.", "zh": "公网 NAT 网关所属专有网络在参数指定的专有网络列表中，视为合规。"}, Reason: models.I18nString{"en": "Internet-facing NAT gateways in non-specified VPCs may violate network segmentation and security policies.", "zh": "不在指定 VPC 中的公网 NAT 网关可能违反网络分段和安全策略。"}, Recommendation: models.I18nString{"en": "Ensure internet-facing NAT gateways are deployed only in the specified VPCs.", "zh": "确保公网 NAT 网关仅部署在指定的 VPC 中。"}, ResourceTypes: []string{"ALIYUN::NAT::NatGateway"}, FilePath: "aliyun/rules/internet-nat-gateway-in-specified-vpc.rego", PackageName: "infraguard.rules.aliyun.internet_nat_gateway_in_specified_vpc", Content: "package infraguard.rules.aliyun.internet_nat_gateway_in_specified_vpc\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"internet-nat-gateway-in-specified-vpc\",\n\t\"name\": {\n\t\t\"en\": \"Internet NAT Gateway in Specified VPC\",\n\t\t\"zh\": \"公网 NAT 网关创建在指定专有网络内\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Internet-facing NAT gateways should be created in specified VPCs according to network security requirements.\",\n\t\t\"zh\": \"公网 NAT 网关所属专有网络在参数指定的专有网络列表中，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Internet-facing NAT gateways in non-specified VPCs may violate network segmentation and security policies.\",\n\t\t\"zh\": \"不在指定 VPC 中的公网 NAT 网关可能违反网络分段和安全策略。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure internet-facing NAT gateways are deployed only in the specified VPCs.\",\n\t\t\"zh\": \"确保公网 NAT 网关仅部署在指定的 VPC 中。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAT::NatGateway\"],\n}\n\nis_internet_nat_gateway(resource) if {\n\tnetwork_type := helpers.get_property(resource, \"NetworkType\", \"\")\n\tnetwork_type == \"internet\"\n}\n\nis_in_specified_vpc(resource) if {\n\t# Parameter-based check - in production would use input parameter\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvpc_id != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAT::NatGateway\")\n\tis_internet_nat_gateway(resource)\n\tnot is_in_specified_vpc(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:intranet-nat-gateway-in-specified-vpc", Name: models.I18nString{"en": "Intranet NAT Gateway in Specified VPC", "zh": "私网 NAT 网关创建在指定专有网络内"}, Severity: "medium", Description: models.I18nString{"en": "Intranet-facing NAT gateways should be created in specified VPCs according to network security requirements.", "zh": "VPC NAT 网关所属专有网络在参数指定的专有网络列表中，视为合规。"}, Reason: models.I18nString{"en": "Intranet-facing NAT gateways in non-specified VPCs may violate network segmentation and security policies.", "zh": "不在指定 VPC 中的私网 NAT 网关可能违反网络分段和安全策略。"}, Recommendation: models.I18nString{"en": "Ensure intranet-facing NAT gateways are deployed only in the specified VPCs.", "zh": "确保私网 NAT 网关仅部署在指定的 VPC 中。"}, ResourceTypes: []string{"ALIYUN::NAT::NatGateway"}, FilePath: "aliyun/rules/intranet-nat-gateway-in-specified-vpc.rego", PackageName: "infraguard.rules.aliyun.intranet_nat_gateway_in_specified_vpc", Content: "package infraguard.rules.aliyun.intranet_nat_gateway_in_specified_vpc\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"intranet-nat-gateway-in-specified-vpc\",\n\t\"name\": {\n\t\t\"en\": \"Intranet NAT Gateway in Specified VPC\",\n\t\t\"zh\": \"私网 NAT 网关创建在指定专有网络内\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Intranet-facing NAT gateways should be created in specified VPCs according to network security requirements.\",\n\t\t\"zh\": \"VPC NAT 网关所属专有网络在参数指定的专有网络列表中，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Intranet-facing NAT gateways in non-specified VPCs may violate network segmentation and security policies.\",\n\t\t\"zh\": \"不在指定 VPC 中的私网 NAT 网关可能违反网络分段和安全策略。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure intranet-facing NAT gateways are deployed only in the specified VPCs.\",\n\t\t\"zh\": \"确保私网 NAT 网关仅部署在指定的 VPC 中。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAT::NatGateway\"],\n}\n\nis_intranet_nat_gateway(resource) if {\n\tnetwork_type := helpers.get_property(resource, \"NetworkType\", \"\")\n\tnetwork_type == \"intranet\"\n}\n\nis_in_specified_vpc(resource) if {\n\t# Parameter-based check - in production would use input parameter\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvpc_id != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAT::NatGateway\")\n\tis_intranet_nat_gateway(resource)\n\tnot is_in_specified_vpc(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kafka-instance-disk-encrypted", Name: models.I18nString{"en": "Kafka Instance Disk Encrypted", "zh": "Kafka 实例部署时启用了云盘加密"}, Severity: "high", Description: models.I18nString{"en": "Kafka instance should have disk encryption enabled during deployment for data protection.", "zh": "Kafka 实例部署时启用了云盘加密，视为合规。Serverless 或非服务中的实例视为不适用。"}, Reason: models.I18nString{"en": "Kafka instance does not have disk encryption enabled, which may expose data to security risks.", "zh": "Kafka 实例未启用云盘加密，可能导致数据面临安全风险。"}, Recommendation: models.I18nString{"en": "Enable disk encryption by configuring KMSKeyId in DeployOption when deploying the Kafka instance.", "zh": "在部署 Kafka 实例时，通过在 DeployOption 中配置 KMSKeyId 来启用云盘加密。"}, ResourceTypes: []string{"ALIYUN::KAFKA::Instance"}, FilePath: "aliyun/rules/kafka-instance-disk-encrypted.rego", PackageName: "infraguard.rules.aliyun.kafka_instance_disk_encrypted", Content: "package infraguard.rules.aliyun.kafka_instance_disk_encrypted\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"kafka-instance-disk-encrypted\",\n\t\"name\": {\n\t\t\"en\": \"Kafka Instance Disk Encrypted\",\n\t\t\"zh\": \"Kafka 实例部署时启用了云盘加密\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Kafka instance should have disk encryption enabled during deployment for data protection.\",\n\t\t\"zh\": \"Kafka 实例部署时启用了云盘加密，视为合规。Serverless 或非服务中的实例视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Kafka instance does not have disk encryption enabled, which may expose data to security risks.\",\n\t\t\"zh\": \"Kafka 实例未启用云盘加密，可能导致数据面临安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable disk encryption by configuring KMSKeyId in DeployOption when deploying the Kafka instance.\",\n\t\t\"zh\": \"在部署 Kafka 实例时，通过在 DeployOption 中配置 KMSKeyId 来启用云盘加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::KAFKA::Instance\"],\n}\n\n# Check if the instance is serverless (not applicable)\nis_serverless(resource) if {\n\tresource.Properties.PayType == \"Serverless\"\n}\n\n# Check if disk encryption is enabled via KMSKeyId in DeployOption\nis_disk_encrypted(resource) if {\n\tresource.Properties.DeployOption.KMSKeyId != null\n}\n\n# Generate deny for non-compliant resources\n# Skip serverless instances as they are not applicable\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KAFKA::Instance\")\n\tnot is_serverless(resource)\n\tnot is_disk_encrypted(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeployOption\", \"KMSKeyId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kafka-instance-multi-zone", Name: models.I18nString{"en": "Kafka Instance Multi-Zone Deployment", "zh": "使用多可用区的消息队列 Kafka 版实例"}, Severity: "medium", Description: models.I18nString{"en": "Kafka instances should be deployed across multiple availability zones for high availability.", "zh": "使用多可用区的消息队列 Kafka 版实例，视为合规。"}, Reason: models.I18nString{"en": "The Kafka instance is not configured for cross-zone deployment or multiple selected zones.", "zh": "Kafka 实例未配置跨可用区部署或未选择多个可用区。"}, Recommendation: models.I18nString{"en": "Enable CrossZone or specify at least 2 zones in SelectedZones.", "zh": "启用 CrossZone 或在 SelectedZones 中指定至少 2 个可用区。"}, ResourceTypes: []string{"ALIYUN::KAFKA::Instance"}, FilePath: "aliyun/rules/kafka-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.kafka_instance_multi_zone", Content: "package infraguard.rules.aliyun.kafka_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"kafka-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"Kafka Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的消息队列 Kafka 版实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Kafka instances should be deployed across multiple availability zones for high availability.\",\n\t\t\"zh\": \"使用多可用区的消息队列 Kafka 版实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Kafka instance is not configured for cross-zone deployment or multiple selected zones.\",\n\t\t\"zh\": \"Kafka 实例未配置跨可用区部署或未选择多个可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable CrossZone or specify at least 2 zones in SelectedZones.\",\n\t\t\"zh\": \"启用 CrossZone 或在 SelectedZones 中指定至少 2 个可用区。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::KAFKA::Instance\"],\n}\n\n# Check if instance is multi-zone\nis_multi_zone(resource) if {\n\t# Method 1: DeployOption.CrossZone is set to true\n\tdeploy_option := object.get(resource.Properties, \"DeployOption\", {})\n\tobject.get(deploy_option, \"CrossZone\", false) == true\n}\n\nis_multi_zone(resource) if {\n\t# Method 2: DeployOption.SelectedZones count >= 2\n\tdeploy_option := object.get(resource.Properties, \"DeployOption\", {})\n\tselected_zones := object.get(deploy_option, \"SelectedZones\", [])\n\tcount(selected_zones) >= 2\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"CrossZone\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kafka-instance-public-access-check", Name: models.I18nString{"en": "Kafka Public Access Disabled", "zh": "Kafka 实例禁用公网访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures Kafka instances do not have public network access.", "zh": "确保 Kafka 实例未开启公网访问。"}, Reason: models.I18nString{"en": "Exposing Kafka to the public internet is a significant security risk.", "zh": "将 Kafka 暴露在公网会带来重大的安全风险。"}, Recommendation: models.I18nString{"en": "Disable the public endpoint for the Kafka instance.", "zh": "禁用 Kafka 实例的公网端点。"}, ResourceTypes: []string{"ALIYUN::KAFKA::Instance"}, FilePath: "aliyun/rules/kafka-instance-public-access-check.rego", PackageName: "infraguard.rules.aliyun.kafka_instance_public_access_check", Content: "package infraguard.rules.aliyun.kafka_instance_public_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"kafka-instance-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"Kafka Public Access Disabled\",\n\t\t\"zh\": \"Kafka 实例禁用公网访问\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Kafka instances do not have public network access.\",\n\t\t\"zh\": \"确保 Kafka 实例未开启公网访问。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Exposing Kafka to the public internet is a significant security risk.\",\n\t\t\"zh\": \"将 Kafka 暴露在公网会带来重大的安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable the public endpoint for the Kafka instance.\",\n\t\t\"zh\": \"禁用 Kafka 实例的公网端点。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::KAFKA::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# In ROS, check DeployType or similar properties\n\t# 4: VPC, 5: Public\n\ttype := helpers.get_property(resource, \"DeployType\", 4)\n\ttype != 5\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KAFKA::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeployType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kms-instance-multi-zone", Name: models.I18nString{"en": "KMS Instance Multi-Zone Deployment", "zh": "使用多可用区的 KMS 实例"}, Severity: "medium", Description: models.I18nString{"en": "KMS instances should be deployed across at least two availability zones for high availability and disaster recovery.", "zh": "使用多可用区的 KMS 实例，视为合规。"}, Reason: models.I18nString{"en": "The KMS instance is not configured with multiple availability zones, which may affect availability.", "zh": "KMS 实例未配置多个可用区，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Configure at least two availability zones in the Connection.ZoneIds property to enable multi-zone deployment.", "zh": "在 Connection.ZoneIds 属性中配置至少两个可用区，以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::KMS::Instance"}, FilePath: "aliyun/rules/kms-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.kms_instance_multi_zone", Content: "package infraguard.rules.aliyun.kms_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"kms-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"KMS Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 KMS 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"KMS instances should be deployed across at least two availability zones for high availability and disaster recovery.\",\n\t\t\"zh\": \"使用多可用区的 KMS 实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The KMS instance is not configured with multiple availability zones, which may affect availability.\",\n\t\t\"zh\": \"KMS 实例未配置多个可用区，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two availability zones in the Connection.ZoneIds property to enable multi-zone deployment.\",\n\t\t\"zh\": \"在 Connection.ZoneIds 属性中配置至少两个可用区，以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::KMS::Instance\"],\n}\n\n# Check if instance has multiple zones configured\nhas_multiple_zones(resource) if {\n\thelpers.has_property(resource, \"Connection\")\n\tconnection := resource.Properties.Connection\n\tzone_ids := connection.ZoneIds\n\tcount(zone_ids) >= 2\n}\n\n# Deny rule: KMS instances must be deployed in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KMS::Instance\")\n\tnot has_multiple_zones(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Connection\", \"ZoneIds\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kms-key-delete-protection-enabled", Name: models.I18nString{"en": "KMS key deletion protection enabled", "zh": "KMS 主密钥开启删除保护"}, Severity: "medium", Description: models.I18nString{"en": "KMS master key has deletion protection enabled, considered compliant. Keys not in enabled status and service keys (which cannot be deleted) are not applicable.", "zh": "KMS 主密钥开启删除保护,视为合规。如果密钥状态非启用中,视为不适用,如果密钥为服务密钥,由于本身不可删除,视为不适用。"}, Reason: models.I18nString{"en": "KMS key does not have deletion protection enabled", "zh": "KMS 主密钥未开启删除保护"}, Recommendation: models.I18nString{"en": "Enable deletion protection for KMS key to prevent accidental deletion of critical encryption keys", "zh": "为 KMS 主密钥启用删除保护以防止意外删除关键加密密钥"}, ResourceTypes: []string{"ALIYUN::KMS::Key"}, FilePath: "aliyun/rules/kms-key-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.kms_key_delete_protection_enabled", Content: "package infraguard.rules.aliyun.kms_key_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"kms-key-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"KMS key deletion protection enabled\",\n\t\t\"zh\": \"KMS 主密钥开启删除保护\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"KMS master key has deletion protection enabled, considered compliant. Keys not in enabled status and service keys (which cannot be deleted) are not applicable.\",\n\t\t\"zh\": \"KMS 主密钥开启删除保护,视为合规。如果密钥状态非启用中,视为不适用,如果密钥为服务密钥,由于本身不可删除,视为不适用。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::KMS::Key\"],\n\t\"reason\": {\n\t\t\"en\": \"KMS key does not have deletion protection enabled\",\n\t\t\"zh\": \"KMS 主密钥未开启删除保护\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for KMS key to prevent accidental deletion of critical encryption keys\",\n\t\t\"zh\": \"为 KMS 主密钥启用删除保护以防止意外删除关键加密密钥\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KMS::Key\")\n\n\t# Check if DeletionProtection is enabled\n\tdeletion_protection := helpers.get_property(resource, \"DeletionProtection\", false)\n\tnot helpers.is_true(deletion_protection)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kms-key-rotation-enabled", Name: models.I18nString{"en": "KMS key automatic rotation enabled", "zh": "密钥管理服务设置主密钥自动轮转"}, Severity: "medium", Description: models.I18nString{"en": "KMS user master key has automatic rotation enabled, considered compliant. Service keys and externally imported keys are not applicable.", "zh": "对密钥管理服务中的用户主密钥设置自动轮转,视为合规。如果是服务密钥,视为不适用。如果来源是用户自带密钥,视为不适用。"}, Reason: models.I18nString{"en": "KMS key does not have automatic rotation enabled", "zh": "KMS 主密钥未开启自动轮转"}, Recommendation: models.I18nString{"en": "Enable automatic rotation for KMS key to enhance security by regularly rotating encryption keys", "zh": "为 KMS 主密钥启用自动轮转以通过定期轮换加密密钥来增强安全性"}, ResourceTypes: []string{"ALIYUN::KMS::Key"}, FilePath: "aliyun/rules/kms-key-rotation-enabled.rego", PackageName: "infraguard.rules.aliyun.kms_key_rotation_enabled", Content: "package infraguard.rules.aliyun.kms_key_rotation_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"kms-key-rotation-enabled\",\n\t\"name\": {\n\t\t\"en\": \"KMS key automatic rotation enabled\",\n\t\t\"zh\": \"密钥管理服务设置主密钥自动轮转\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"KMS user master key has automatic rotation enabled, considered compliant. Service keys and externally imported keys are not applicable.\",\n\t\t\"zh\": \"对密钥管理服务中的用户主密钥设置自动轮转,视为合规。如果是服务密钥,视为不适用。如果来源是用户自带密钥,视为不适用。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::KMS::Key\"],\n\t\"reason\": {\n\t\t\"en\": \"KMS key does not have automatic rotation enabled\",\n\t\t\"zh\": \"KMS 主密钥未开启自动轮转\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable automatic rotation for KMS key to enhance security by regularly rotating encryption keys\",\n\t\t\"zh\": \"为 KMS 主密钥启用自动轮转以通过定期轮换加密密钥来增强安全性\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KMS::Key\")\n\n\t# Check if EnableAutomaticRotation is enabled\n\trotation_enabled := helpers.get_property(resource, \"EnableAutomaticRotation\", false)\n\tnot helpers.is_true(rotation_enabled)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:kms-secret-rotation-enabled", Name: models.I18nString{"en": "KMS secret automatic rotation enabled", "zh": "密钥管理服务设置凭据自动轮转"}, Severity: "medium", Description: models.I18nString{"en": "KMS secret has automatic rotation enabled, considered compliant. Generic secrets are not applicable.", "zh": "密钥管理服务中的凭据设置自动轮转,视为合规。如果密钥类型为普通密钥,视为不适用。"}, Reason: models.I18nString{"en": "KMS secret does not have automatic rotation enabled", "zh": "KMS 凭据未开启自动轮转"}, Recommendation: models.I18nString{"en": "Enable automatic rotation for KMS secret to enhance security by regularly rotating credentials", "zh": "为 KMS 凭据启用自动轮转以通过定期轮换凭据来增强安全性"}, ResourceTypes: []string{"ALIYUN::KMS::Secret"}, FilePath: "aliyun/rules/kms-secret-rotation-enabled.rego", PackageName: "infraguard.rules.aliyun.kms_secret_rotation_enabled", Content: "package infraguard.rules.aliyun.kms_secret_rotation_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"kms-secret-rotation-enabled\",\n\t\"name\": {\n\t\t\"en\": \"KMS secret automatic rotation enabled\",\n\t\t\"zh\": \"密钥管理服务设置凭据自动轮转\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"KMS secret has automatic rotation enabled, considered compliant. Generic secrets are not applicable.\",\n\t\t\"zh\": \"密钥管理服务中的凭据设置自动轮转,视为合规。如果密钥类型为普通密钥,视为不适用。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::KMS::Secret\"],\n\t\"reason\": {\n\t\t\"en\": \"KMS secret does not have automatic rotation enabled\",\n\t\t\"zh\": \"KMS 凭据未开启自动轮转\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable automatic rotation for KMS secret to enhance security by regularly rotating credentials\",\n\t\t\"zh\": \"为 KMS 凭据启用自动轮转以通过定期轮换凭据来增强安全性\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::KMS::Secret\")\n\n\t# Check if EnableAutomaticRotation is enabled\n\trotation_enabled := helpers.get_property(resource, \"EnableAutomaticRotation\", false)\n\tnot helpers.is_true(rotation_enabled)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:lindorm-instance-in-vpc", Name: models.I18nString{"en": "Lindorm in VPC Check", "zh": "Lindorm 实例强制 VPC 部署"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Lindorm instances are deployed within a VPC.", "zh": "确保 Lindorm 实例部署在 VPC 内。"}, Reason: models.I18nString{"en": "Deploying in a VPC provides better network isolation and security.", "zh": "在 VPC 中部署可提供更好的网络隔离和安全性。"}, Recommendation: models.I18nString{"en": "Create Lindorm instances within a VPC.", "zh": "在 VPC 内创建 Lindorm 实例。"}, ResourceTypes: []string{"ALIYUN::Lindorm::Instance"}, FilePath: "aliyun/rules/lindorm-instance-in-vpc.rego", PackageName: "infraguard.rules.aliyun.lindorm_instance_in_vpc", Content: "package infraguard.rules.aliyun.lindorm_instance_in_vpc\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"lindorm-instance-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"Lindorm in VPC Check\",\n\t\t\"zh\": \"Lindorm 实例强制 VPC 部署\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Lindorm instances are deployed within a VPC.\",\n\t\t\"zh\": \"确保 Lindorm 实例部署在 VPC 内。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Deploying in a VPC provides better network isolation and security.\",\n\t\t\"zh\": \"在 VPC 中部署可提供更好的网络隔离和安全性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Create Lindorm instances within a VPC.\",\n\t\t\"zh\": \"在 VPC 内创建 Lindorm 实例。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::Lindorm::Instance\"],\n}\n\nis_compliant(resource) if {\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvpc_id != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Lindorm::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:lindorm-instance-multi-zone", Name: models.I18nString{"en": "Lindorm Instance Multi-Zone Deployment", "zh": "使用多可用区的云原生多模数据库 Lindorm 实例"}, Severity: "medium", Description: models.I18nString{"en": "Lindorm instances should be configured for multi-zone deployment with at least 4 LindormTable nodes for high availability.", "zh": "使用多可用区的云原生多模数据库 Lindorm 实例，视为合规。"}, Reason: models.I18nString{"en": "The Lindorm instance does not meet the multi-zone deployment requirements (LindormNum < 4).", "zh": "Lindorm 实例不满足多可用区部署要求（LindormNum < 4）。"}, Recommendation: models.I18nString{"en": "Configure at least 4 LindormTable nodes by setting LindormNum to 4 or more to enable multi-zone deployment.", "zh": "通过将 LindormNum 设置为 4 或更多来配置至少 4 个 LindormTable 节点，以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::Lindorm::Instance"}, FilePath: "aliyun/rules/lindorm-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.lindorm_instance_multi_zone", Content: "package infraguard.rules.aliyun.lindorm_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"lindorm-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"Lindorm Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的云原生多模数据库 Lindorm 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Lindorm instances should be configured for multi-zone deployment with at least 4 LindormTable nodes for high availability.\",\n\t\t\"zh\": \"使用多可用区的云原生多模数据库 Lindorm 实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Lindorm instance does not meet the multi-zone deployment requirements (LindormNum < 4).\",\n\t\t\"zh\": \"Lindorm 实例不满足多可用区部署要求（LindormNum < 4）。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least 4 LindormTable nodes by setting LindormNum to 4 or more to enable multi-zone deployment.\",\n\t\t\"zh\": \"通过将 LindormNum 设置为 4 或更多来配置至少 4 个 LindormTable 节点，以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::Lindorm::Instance\"],\n}\n\n# Check if instance is multi-zone (requires LindormNum >= 4)\nis_multi_zone(resource) if {\n\thelpers.has_property(resource, \"LindormNum\")\n\tlindorm_num := resource.Properties.LindormNum\n\tlindorm_num >= 4\n}\n\n# Deny rule: Lindorm instances should be multi-zone\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Lindorm::Instance\")\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LindormNum\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:maxcompute-project-encryption-enabled", Name: models.I18nString{"en": "MaxCompute Project Encryption Enabled", "zh": "MaxCompute 项目开启加密"}, Severity: "high", Description: models.I18nString{"en": "Ensures MaxCompute projects have encryption enabled to protect stored data.", "zh": "确保 MaxCompute 项目启用了加密以保护存储的数据。"}, Reason: models.I18nString{"en": "Encryption protects sensitive data stored in MaxCompute projects from unauthorized access.", "zh": "加密可以保护 MaxCompute 项目中存储的敏感数据免受非授权访问。"}, Recommendation: models.I18nString{"en": "Enable encryption for the MaxCompute project.", "zh": "为 MaxCompute 项目启用加密。"}, ResourceTypes: []string{"ALIYUN::MaxCompute::Project"}, FilePath: "aliyun/rules/maxcompute-project-encryption-enabled.rego", PackageName: "infraguard.rules.aliyun.maxcompute_project_encryption_enabled", Content: "package infraguard.rules.aliyun.maxcompute_project_encryption_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"maxcompute-project-encryption-enabled\",\n\t\"name\": {\n\t\t\"en\": \"MaxCompute Project Encryption Enabled\",\n\t\t\"zh\": \"MaxCompute 项目开启加密\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MaxCompute projects have encryption enabled to protect stored data.\",\n\t\t\"zh\": \"确保 MaxCompute 项目启用了加密以保护存储的数据。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Encryption protects sensitive data stored in MaxCompute projects from unauthorized access.\",\n\t\t\"zh\": \"加密可以保护 MaxCompute 项目中存储的敏感数据免受非授权访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for the MaxCompute project.\",\n\t\t\"zh\": \"为 MaxCompute 项目启用加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::MaxCompute::Project\"],\n}\n\n# Check if encryption is enabled\nis_compliant(resource) if {\n\t# Direct access to nested properties\n\tprops := resource.Properties.Properties\n\tprops != null\n\tencryption := props.Encryption\n\tencryption != null\n\tencryption.Enable == true\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MaxCompute::Project\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Encryption\", \"Enable\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:maxcompute-project-ip-whitelist-enabled", Name: models.I18nString{"en": "MaxCompute Project IP Whitelist Enabled", "zh": "MaxCompute 项目开启 IP 白名单"}, Severity: "high", Description: models.I18nString{"en": "Ensures MaxCompute projects have an IP whitelist configured to restrict access.", "zh": "确保 MaxCompute 项目配置了 IP 白名单以限制访问。"}, Reason: models.I18nString{"en": "Restricting access to trusted IPs prevents unauthorized data access over the network.", "zh": "限制可信 IP 访问可防止网络上的非授权数据访问。"}, Recommendation: models.I18nString{"en": "Configure the IP whitelist for the MaxCompute project.", "zh": "为 MaxCompute 项目配置 IP 白名单。"}, ResourceTypes: []string{"ALIYUN::MaxCompute::Project"}, FilePath: "aliyun/rules/maxcompute-project-ip-whitelist-enabled.rego", PackageName: "infraguard.rules.aliyun.maxcompute_project_ip_whitelist_enabled", Content: "package infraguard.rules.aliyun.maxcompute_project_ip_whitelist_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"maxcompute-project-ip-whitelist-enabled\",\n\t\"name\": {\n\t\t\"en\": \"MaxCompute Project IP Whitelist Enabled\",\n\t\t\"zh\": \"MaxCompute 项目开启 IP 白名单\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MaxCompute projects have an IP whitelist configured to restrict access.\",\n\t\t\"zh\": \"确保 MaxCompute 项目配置了 IP 白名单以限制访问。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Restricting access to trusted IPs prevents unauthorized data access over the network.\",\n\t\t\"zh\": \"限制可信 IP 访问可防止网络上的非授权数据访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the IP whitelist for the MaxCompute project.\",\n\t\t\"zh\": \"为 MaxCompute 项目配置 IP 白名单。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::MaxCompute::Project\"],\n}\n\nis_compliant(resource) if {\n\t# Check for a property like 'IpWhiteList' in ROS\n\thelpers.has_property(resource, \"IpWhiteList\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MaxCompute::Project\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:metadata-ros-composer-check", Name: models.I18nString{"en": "Template Metadata ALIYUN::ROS::Composer Check", "zh": "模板 Metadata ALIYUN::ROS::Composer 检查"}, Severity: "low", Description: models.I18nString{"en": "Template must have Metadata.ALIYUN::ROS::Composer configured. The value must be a dictionary (object).", "zh": "模板必须配置 Metadata.ALIYUN::ROS::Composer。该值必须是字典（对象）类型。"}, Reason: models.I18nString{"en": "ALIYUN::ROS::Composer is missing or invalid. It must be configured as a dictionary.", "zh": "ALIYUN::ROS::Composer 缺失或格式无效。必须配置为字典类型。"}, Recommendation: models.I18nString{"en": "Use ROS Composer (https://ros.console.aliyun.com/composer) to import your template, configure the architecture diagram, and the composer metadata will be automatically generated.", "zh": "使用 ROS 架构编辑器（https://ros.console.aliyun.com/composer）导入模板并配置架构图，系统将自动生成 composer 元数据信息。"}, ResourceTypes: []string{}, FilePath: "aliyun/rules/metadata-ros-composer-check.rego", PackageName: "infraguard.rules.aliyun.metadata_ros_composer_check", Content: "package infraguard.rules.aliyun.metadata_ros_composer_check\n\nimport rego.v1\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"metadata-ros-composer-check\",\n\t\"name\": {\n\t\t\"en\": \"Template Metadata ALIYUN::ROS::Composer Check\",\n\t\t\"zh\": \"模板 Metadata ALIYUN::ROS::Composer 检查\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Template must have Metadata.ALIYUN::ROS::Composer configured. The value must be a dictionary (object).\",\n\t\t\"zh\": \"模板必须配置 Metadata.ALIYUN::ROS::Composer。该值必须是字典（对象）类型。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"ALIYUN::ROS::Composer is missing or invalid. It must be configured as a dictionary.\",\n\t\t\"zh\": \"ALIYUN::ROS::Composer 缺失或格式无效。必须配置为字典类型。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use ROS Composer (https://ros.console.aliyun.com/composer) to import your template, configure the architecture diagram, and the composer metadata will be automatically generated.\",\n\t\t\"zh\": \"使用 ROS 架构编辑器（https://ros.console.aliyun.com/composer）导入模板并配置架构图，系统将自动生成 composer 元数据信息。\",\n\t},\n\t\"resource_types\": [],\n}\n\n# Check if ALIYUN::ROS::Composer exists and is valid\nhas_valid_composer if {\n\t# Check if Metadata exists\n\tinput.Metadata != null\n\n\t# Check if ALIYUN::ROS::Composer exists in Metadata\n\tcomposer := object.get(input.Metadata, \"ALIYUN::ROS::Composer\", null)\n\tcomposer != null\n\n\t# Must be an object (dictionary)\n\tis_object(composer)\n}\n\n# Check template Metadata\ndeny contains result if {\n\t# Check if Metadata exists\n\tinput.Metadata == null\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"\",\n\t\t\"violation_path\": [\"Metadata\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\t# Check if Metadata exists\n\tinput.Metadata != null\n\n\t# Check if ALIYUN::ROS::Composer is missing\n\tobject.get(input.Metadata, \"ALIYUN::ROS::Composer\", null) == null\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"\",\n\t\t\"violation_path\": [\"Metadata\", \"ALIYUN::ROS::Composer\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\t# Check if Metadata exists\n\tinput.Metadata != null\n\n\t# Check if ALIYUN::ROS::Composer exists\n\tcomposer := object.get(input.Metadata, \"ALIYUN::ROS::Composer\", null)\n\tcomposer != null\n\n\t# Check if ALIYUN::ROS::Composer is not an object\n\tnot is_object(composer)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"\",\n\t\t\"violation_path\": [\"Metadata\", \"ALIYUN::ROS::Composer\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-cluster-expired-check", Name: models.I18nString{"en": "MongoDB Instance Expiration Check", "zh": "MongoDB 实例到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid MongoDB instances should have auto-renewal enabled.", "zh": "预付费 MongoDB 实例应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid MongoDB instance does not have auto-renewal enabled.", "zh": "预付费 MongoDB 实例未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid MongoDB instance by setting AutoRenew to true.", "zh": "通过将 AutoRenew 设置为 true 为预付费 MongoDB 实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-cluster-expired-check.rego", PackageName: "infraguard.rules.aliyun.mongodb_cluster_expired_check", Content: "package infraguard.rules.aliyun.mongodb_cluster_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-cluster-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Expiration Check\",\n\t\t\"zh\": \"MongoDB 实例到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid MongoDB instances should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 MongoDB 实例应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid MongoDB instance does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 MongoDB 实例未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid MongoDB instance by setting AutoRenew to true.\",\n\t\t\"zh\": \"通过将 AutoRenew 设置为 true 为预付费 MongoDB 实例开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_prepaid(resource) if {\n\thelpers.get_property(resource, \"ChargeType\", \"PostPaid\") == \"PrePaid\"\n}\n\nis_auto_renew_enabled(resource) if {\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", false)\n\thelpers.is_true(auto_renew)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-class-not-shared", Name: models.I18nString{"en": "MongoDB Instance Uses Dedicated Class", "zh": "MongoDB 使用独享型或专属型规格实例"}, Severity: "high", Description: models.I18nString{"en": "Ensures MongoDB instances use dedicated or exclusive instance classes, not shared instances.", "zh": "确保 MongoDB 实例使用独享型或专属型规格实例，而非共享型实例。"}, Reason: models.I18nString{"en": "Shared instance classes may have resource contention issues, affecting database performance and stability.", "zh": "共享型实例规格可能存在资源争用问题，影响数据库性能和稳定性。"}, Recommendation: models.I18nString{"en": "Use dedicated or exclusive instance classes for MongoDB instances.", "zh": "为 MongoDB 实例使用独享型或专属型规格实例。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-class-not-shared.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_class_not_shared", Content: "package infraguard.rules.aliyun.mongodb_instance_class_not_shared\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-class-not-shared\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Uses Dedicated Class\",\n\t\t\"zh\": \"MongoDB 使用独享型或专属型规格实例\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances use dedicated or exclusive instance classes, not shared instances.\",\n\t\t\"zh\": \"确保 MongoDB 实例使用独享型或专属型规格实例，而非共享型实例。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Shared instance classes may have resource contention issues, affecting database performance and stability.\",\n\t\t\"zh\": \"共享型实例规格可能存在资源争用问题，影响数据库性能和稳定性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use dedicated or exclusive instance classes for MongoDB instances.\",\n\t\t\"zh\": \"为 MongoDB 实例使用独享型或专属型规格实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Shared instance class patterns (these are typically shared types)\nshared_classes := {\n\t\"dds.mongo.sharding\",\n\t\"dds.mongo.logic\",\n\t\"dds.mongo.shared\",\n}\n\n# Check if instance class is not shared\nis_compliant(resource) if {\n\tinstance_class := helpers.get_property(resource, \"DBInstanceClass\", \"\")\n\tnot contains_shared_class(lower(instance_class))\n}\n\ncontains_shared_class(instance_class) if {\n\tsome shared_class in shared_classes\n\tcontains(instance_class, shared_class)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DBInstanceClass\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-enabled-ssl", Name: models.I18nString{"en": "MongoDB Instance SSL Enabled", "zh": "MongoDB 实例开启 SSL 加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures MongoDB instances have SSL encryption enabled.", "zh": "确保 MongoDB 实例开启了 SSL 加密。"}, Reason: models.I18nString{"en": "SSL protects data in transit between the client and the database.", "zh": "SSL 保护客户端与数据库之间传输的数据。"}, Recommendation: models.I18nString{"en": "Enable SSL for the MongoDB instance.", "zh": "为 MongoDB 实例开启 SSL 加密。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-enabled-ssl.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_enabled_ssl", Content: "package infraguard.rules.aliyun.mongodb_instance_enabled_ssl\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-enabled-ssl\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance SSL Enabled\",\n\t\t\"zh\": \"MongoDB 实例开启 SSL 加密\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances have SSL encryption enabled.\",\n\t\t\"zh\": \"确保 MongoDB 实例开启了 SSL 加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL protects data in transit between the client and the database.\",\n\t\t\"zh\": \"SSL 保护客户端与数据库之间传输的数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SSL for the MongoDB instance.\",\n\t\t\"zh\": \"为 MongoDB 实例开启 SSL 加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_compliant(resource) if {\n\tssl_options := helpers.get_property(resource, \"SSLOptions\", {})\n\taction := object.get(ssl_options, \"SSLAction\", \"Close\")\n\taction == \"Open\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MONGODB::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SSLOptions\", \"SSLAction\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-encryption-byok-check", Name: models.I18nString{"en": "MongoDB Instance Uses Custom Key for TDE", "zh": "使用自定义密钥为 MongoDB 设置透明数据加密 TDE"}, Severity: "medium", Description: models.I18nString{"en": "Ensures MongoDB instances use custom KMS keys for Transparent Data Encryption (TDE).", "zh": "确保 MongoDB 实例使用自定义 KMS 密钥进行透明数据加密（TDE）。"}, Reason: models.I18nString{"en": "Using customer-managed keys for TDE provides better control over encryption and enhances data security.", "zh": "使用客户管理密钥进行 TDE 可以更好地控制加密并增强数据安全性。"}, Recommendation: models.I18nString{"en": "Enable TDE with a custom KMS key for the MongoDB instance.", "zh": "为 MongoDB 实例启用 TDE 并使用自定义 KMS 密钥。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-encryption-byok-check.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_encryption_byok_check", Content: "package infraguard.rules.aliyun.mongodb_instance_encryption_byok_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-encryption-byok-check\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Uses Custom Key for TDE\",\n\t\t\"zh\": \"使用自定义密钥为 MongoDB 设置透明数据加密 TDE\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances use custom KMS keys for Transparent Data Encryption (TDE).\",\n\t\t\"zh\": \"确保 MongoDB 实例使用自定义 KMS 密钥进行透明数据加密（TDE）。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using customer-managed keys for TDE provides better control over encryption and enhances data security.\",\n\t\t\"zh\": \"使用客户管理密钥进行 TDE 可以更好地控制加密并增强数据安全性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable TDE with a custom KMS key for the MongoDB instance.\",\n\t\t\"zh\": \"为 MongoDB 实例启用 TDE 并使用自定义 KMS 密钥。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Check if instance is Serverless type (not applicable)\nis_serverless(resource) if {\n\ttags := helpers.get_property(resource, \"Tags\", [])\n\tsome tag in tags\n\ttag.Key == \"InstanceType\"\n\ttag.Value == \"Serverless\"\n}\n\nis_serverless(resource) if {\n\tinstance_class := helpers.get_property(resource, \"DBInstanceClass\", \"\")\n\tcontains(lower(instance_class), \"serverless\")\n}\n\n# Check if TDE is enabled with custom key\nis_compliant(resource) if {\n\tnot is_serverless(resource)\n\ttde_enabled := helpers.get_property(resource, \"TDEStatus\", false)\n\ttde_enabled == true\n\tkms_key_id := helpers.get_property(resource, \"EncryptionKey\", \"\")\n\tkms_key_id != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_serverless(resource)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TDEStatus\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-in-vpc", Name: models.I18nString{"en": "MongoDB Instance Uses VPC Network", "zh": "使用专有网络类型的 MongoDB 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures MongoDB instances are deployed in a Virtual Private Cloud (VPC) network.", "zh": "确保 MongoDB 实例部署在专有网络（VPC）中。"}, Reason: models.I18nString{"en": "VPC provides network isolation and better security compared to the classic network.", "zh": "与经典网络相比，VPC 提供网络隔离和更好的安全性。"}, Recommendation: models.I18nString{"en": "Deploy the MongoDB instance in a VPC network.", "zh": "将 MongoDB 实例部署在专有网络中。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-in-vpc.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_in_vpc", Content: "package infraguard.rules.aliyun.mongodb_instance_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Uses VPC Network\",\n\t\t\"zh\": \"使用专有网络类型的 MongoDB 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances are deployed in a Virtual Private Cloud (VPC) network.\",\n\t\t\"zh\": \"确保 MongoDB 实例部署在专有网络（VPC）中。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"VPC provides network isolation and better security compared to the classic network.\",\n\t\t\"zh\": \"与经典网络相比，VPC 提供网络隔离和更好的安全性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy the MongoDB instance in a VPC network.\",\n\t\t\"zh\": \"将 MongoDB 实例部署在专有网络中。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Check if instance is in VPC\nis_compliant(resource) if {\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvpc_id != \"\"\n}\n\nis_compliant(resource) if {\n\tnetwork_type := helpers.get_property(resource, \"NetworkType\", \"\")\n\tnetwork_type == \"VPC\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-log-audit", Name: models.I18nString{"en": "MongoDB Instance Log Audit Enabled", "zh": "MongoDB 实例开启操作日志审计"}, Severity: "medium", Description: models.I18nString{"en": "Ensures MongoDB instances have audit logging enabled.", "zh": "确保 MongoDB 实例开启了操作日志审计。"}, Reason: models.I18nString{"en": "Audit logs are critical for security monitoring and compliance auditing.", "zh": "审计日志对于安全监控和合规审计至关重要。"}, Recommendation: models.I18nString{"en": "Enable audit logging for the MongoDB instance.", "zh": "为 MongoDB 实例开启操作日志审计。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-log-audit.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_log_audit", Content: "package infraguard.rules.aliyun.mongodb_instance_log_audit\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-log-audit\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Log Audit Enabled\",\n\t\t\"zh\": \"MongoDB 实例开启操作日志审计\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances have audit logging enabled.\",\n\t\t\"zh\": \"确保 MongoDB 实例开启了操作日志审计。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Audit logs are critical for security monitoring and compliance auditing.\",\n\t\t\"zh\": \"审计日志对于安全监控和合规审计至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable audit logging for the MongoDB instance.\",\n\t\t\"zh\": \"为 MongoDB 实例开启操作日志审计。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_compliant(resource) if {\n\taudit_options := helpers.get_property(resource, \"AuditPolicyOptions\", {})\n\tstatus := object.get(audit_options, \"AuditStatus\", \"disabled\")\n\tstatus == \"enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MONGODB::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AuditPolicyOptions\", \"AuditStatus\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-multi-node", Name: models.I18nString{"en": "MongoDB Instance Uses Multiple Nodes", "zh": "使用多节点的 MongoDB 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures MongoDB instances are deployed with multiple nodes for high availability.", "zh": "确保 MongoDB 实例部署了多个节点以实现高可用性。"}, Reason: models.I18nString{"en": "Single-node instances have no redundancy and are at risk of data loss or service interruption.", "zh": "单节点实例没有冗余，存在数据丢失或服务中断的风险。"}, Recommendation: models.I18nString{"en": "Deploy MongoDB instances with multiple replica set nodes.", "zh": "部署具有多个副本集节点的 MongoDB 实例。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-multi-node.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_multi_node", Content: "package infraguard.rules.aliyun.mongodb_instance_multi_node\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-multi-node\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Uses Multiple Nodes\",\n\t\t\"zh\": \"使用多节点的 MongoDB 实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances are deployed with multiple nodes for high availability.\",\n\t\t\"zh\": \"确保 MongoDB 实例部署了多个节点以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Single-node instances have no redundancy and are at risk of data loss or service interruption.\",\n\t\t\"zh\": \"单节点实例没有冗余，存在数据丢失或服务中断的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy MongoDB instances with multiple replica set nodes.\",\n\t\t\"zh\": \"部署具有多个副本集节点的 MongoDB 实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Check if instance has multiple nodes\nis_compliant(resource) if {\n\treplication_factor := helpers.get_property(resource, \"ReplicationFactor\", 0)\n\treplication_factor >= 3\n}\n\nis_compliant(resource) if {\n\tinstance_class := helpers.get_property(resource, \"DBInstanceClass\", \"\")\n\n\t# Check if it's a replica set class (typically contains 'replica' or has specific patterns)\n\tcontains(lower(instance_class), \"replica\")\n}\n\nis_compliant(resource) if {\n\tinstance_class := helpers.get_property(resource, \"DBInstanceClass\", \"\")\n\tcontains(lower(instance_class), \"sharding\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ReplicationFactor\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-multi-zone", Name: models.I18nString{"en": "MongoDB Instance Multi-Zone Deployment", "zh": "MongoDB 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "MongoDB instances should be deployed across multiple availability zones for high availability.", "zh": "MongoDB 实例应部署在多个可用区。"}, Reason: models.I18nString{"en": "The MongoDB instance is not configured with a secondary or hidden zone.", "zh": "MongoDB 实例未配置备用可用区或隐藏可用区。"}, Recommendation: models.I18nString{"en": "Configure SecondaryZoneId or HiddenZoneId to enable multi-zone deployment.", "zh": "配置 SecondaryZoneId 或 HiddenZoneId 以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_multi_zone", Content: "package infraguard.rules.aliyun.mongodb_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"mongodb-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"MongoDB 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"MongoDB instances should be deployed across multiple availability zones for high availability.\",\n\t\t\"zh\": \"MongoDB 实例应部署在多个可用区。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The MongoDB instance is not configured with a secondary or hidden zone.\",\n\t\t\"zh\": \"MongoDB 实例未配置备用可用区或隐藏可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure SecondaryZoneId or HiddenZoneId to enable multi-zone deployment.\",\n\t\t\"zh\": \"配置 SecondaryZoneId 或 HiddenZoneId 以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Check if instance is multi-zone\nis_multi_zone(resource) if {\n\t# Check if SecondaryZoneId is present\n\tobject.get(resource.Properties, \"SecondaryZoneId\", \"\") != \"\"\n}\n\nis_multi_zone(resource) if {\n\t# Check if HiddenZoneId is present\n\tobject.get(resource.Properties, \"HiddenZoneId\", \"\") != \"\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-instance-release-protection", Name: models.I18nString{"en": "MongoDB Instance Release Protection Enabled", "zh": "MongoDB 实例开启释放保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that MongoDB instances have release protection enabled.", "zh": "确保 MongoDB 实例开启了释放保护。"}, Reason: models.I18nString{"en": "If release protection is not enabled, the MongoDB instance may be released accidentally, causing data loss.", "zh": "如果未开启释放保护，MongoDB 实例可能会被意外释放，导致数据丢失。"}, Recommendation: models.I18nString{"en": "Enable release protection for the MongoDB instance.", "zh": "为 MongoDB 实例开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-instance-release-protection.rego", PackageName: "infraguard.rules.aliyun.mongodb_instance_release_protection", Content: "package infraguard.rules.aliyun.mongodb_instance_release_protection\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-instance-release-protection\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Instance Release Protection Enabled\",\n\t\t\"zh\": \"MongoDB 实例开启释放保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MongoDB instances have release protection enabled.\",\n\t\t\"zh\": \"确保 MongoDB 实例开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If release protection is not enabled, the MongoDB instance may be released accidentally, causing data loss.\",\n\t\t\"zh\": \"如果未开启释放保护，MongoDB 实例可能会被意外释放，导致数据丢失。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable release protection for the MongoDB instance.\",\n\t\t\"zh\": \"为 MongoDB 实例开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DBInstanceReleaseProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MONGODB::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DBInstanceReleaseProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-min-maxconnections-limit", Name: models.I18nString{"en": "MongoDB Meets Minimum Connection Requirements", "zh": "MongoDB 满足指定连接数要求"}, Severity: "high", Description: models.I18nString{"en": "Ensures MongoDB instances provide at least the minimum required number of connections.", "zh": "确保 MongoDB 实例提供至少所需的最少连接数。"}, Reason: models.I18nString{"en": "Insufficient connection limits may cause application failures when under load.", "zh": "连接数不足可能在负载下导致应用程序故障。"}, Recommendation: models.I18nString{"en": "Select an instance class that provides sufficient connection limits.", "zh": "选择提供足够连接数限制的实例规格。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-min-maxconnections-limit.rego", PackageName: "infraguard.rules.aliyun.mongodb_min_maxconnections_limit", Content: "package infraguard.rules.aliyun.mongodb_min_maxconnections_limit\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-min-maxconnections-limit\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Meets Minimum Connection Requirements\",\n\t\t\"zh\": \"MongoDB 满足指定连接数要求\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances provide at least the minimum required number of connections.\",\n\t\t\"zh\": \"确保 MongoDB 实例提供至少所需的最少连接数。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Insufficient connection limits may cause application failures when under load.\",\n\t\t\"zh\": \"连接数不足可能在负载下导致应用程序故障。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Select an instance class that provides sufficient connection limits.\",\n\t\t\"zh\": \"选择提供足够连接数限制的实例规格。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Default minimum connections\ndefault_min_connections := 500\n\n# Get min connections from parameter or use default\nget_min_connections := num if {\n\tnum := input.parameters.minConnections\n\tis_number(num)\n}\n\nget_min_connections := default_min_connections\n\n# Get max connections for the instance\nget_max_connections(resource) := conn if {\n\tconn := object.get(resource.Properties, \"MaxConnections\", 0)\n\tis_number(conn)\n}\n\n# Check if instance meets connection requirements\nis_compliant(resource) if {\n\tmax_conn := get_max_connections(resource)\n\tmin_required := get_min_connections()\n\tmax_conn >= min_required\n}\n\n# Also check based on instance class capability\nis_compliant(resource) if {\n\tinstance_class := object.get(resource.Properties, \"DBInstanceClass\", \"\")\n\n\t# Map instance class to expected max connections (simplified)\n\tclass_conn_map := {\n\t\t\"dds.mongo.stand-alone\": 200,\n\t\t\"dds.mongo.replica_set\": 1000,\n\t\t\"dds.mongo.sharding\": 2000,\n\t}\n\texpected_conn := class_conn_map[lower(instance_class)]\n\texpected_conn != null\n\texpected_conn >= get_min_connections()\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MaxConnections\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-min-maxiops-limit", Name: models.I18nString{"en": "MongoDB Meets Minimum IOPS Requirements", "zh": "MongoDB 实例满足指定读写次数要求"}, Severity: "high", Description: models.I18nString{"en": "Ensures MongoDB instances provide at least the minimum required IOPS.", "zh": "确保 MongoDB 实例提供至少所需的最少 IOPS。"}, Reason: models.I18nString{"en": "Insufficient IOPS may cause performance issues under load.", "zh": "IOPS 不足可能在负载下导致性能问题。"}, Recommendation: models.I18nString{"en": "Select an instance class or storage that provides sufficient IOPS.", "zh": "选择提供足够 IOPS 的实例规格或存储。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-min-maxiops-limit.rego", PackageName: "infraguard.rules.aliyun.mongodb_min_maxiops_limit", Content: "package infraguard.rules.aliyun.mongodb_min_maxiops_limit\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-min-maxiops-limit\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Meets Minimum IOPS Requirements\",\n\t\t\"zh\": \"MongoDB 实例满足指定读写次数要求\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB instances provide at least the minimum required IOPS.\",\n\t\t\"zh\": \"确保 MongoDB 实例提供至少所需的最少 IOPS。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Insufficient IOPS may cause performance issues under load.\",\n\t\t\"zh\": \"IOPS 不足可能在负载下导致性能问题。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Select an instance class or storage that provides sufficient IOPS.\",\n\t\t\"zh\": \"选择提供足够 IOPS 的实例规格或存储。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\n# Default minimum IOPS\ndefault_min_iops := 1000\n\n# Get min IOPS from parameter or use default\nget_min_iops := iops if {\n\tiops := input.parameters.minIOPS\n\tis_number(iops)\n} else := default_min_iops\n\n# Get max IOPS for the instance\nget_max_iops(resource) := iops if {\n\tiops := helpers.get_property(resource, \"MaxIOPS\", 0)\n\tis_number(iops)\n}\n\n# Check if instance meets IOPS requirements\nis_compliant(resource) if {\n\tmax_iops := get_max_iops(resource)\n\tmin_required := get_min_iops()\n\tmax_iops >= min_required\n}\n\n# Also check based on instance class and storage\nis_compliant(resource) if {\n\tinstance_class := helpers.get_property(resource, \"DBInstanceClass\", \"\")\n\tinstance_storage := helpers.get_property(resource, \"DBInstanceStorage\", 0)\n\tstorage_type := helpers.get_property(resource, \"StorageType\", \"cloud_ssd\")\n\n\tinstance_storage >= 100\n\tcontains(lower(storage_type), \"ssd\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MaxIOPS\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-public-access-check", Name: models.I18nString{"en": "MongoDB Whitelist Internet Restriction", "zh": "MongoDB 白名单禁用公网开放"}, Severity: "high", Description: models.I18nString{"en": "Ensures MongoDB security IP whitelists do not contain 0.0.0.0/0.", "zh": "确保 MongoDB 安全 IP 白名单中不包含 0.0.0.0/0。"}, Reason: models.I18nString{"en": "An open MongoDB whitelist allows unrestricted access to sensitive data over the internet.", "zh": "开放的 MongoDB 白名单允许通过互联网无限制地访问敏感数据。"}, Recommendation: models.I18nString{"en": "Restrict the MongoDB whitelist to trusted IP ranges.", "zh": "将 MongoDB 白名单限制在可信 IP 范围内。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-public-access-check.rego", PackageName: "infraguard.rules.aliyun.mongodb_public_access_check", Content: "package infraguard.rules.aliyun.mongodb_public_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"mongodb-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Whitelist Internet Restriction\",\n\t\t\"zh\": \"MongoDB 白名单禁用公网开放\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures MongoDB security IP whitelists do not contain 0.0.0.0/0.\",\n\t\t\"zh\": \"确保 MongoDB 安全 IP 白名单中不包含 0.0.0.0/0。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"An open MongoDB whitelist allows unrestricted access to sensitive data over the internet.\",\n\t\t\"zh\": \"开放的 MongoDB 白名单允许通过互联网无限制地访问敏感数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict the MongoDB whitelist to trusted IP ranges.\",\n\t\t\"zh\": \"将 MongoDB 白名单限制在可信 IP 范围内。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_compliant(resource) if {\n\twhitelist_str := helpers.get_property(resource, \"SecurityIPArray\", \"\")\n\twhitelist := split(whitelist_str, \",\")\n\tnot has_public_ip(whitelist)\n}\n\nhas_public_ip(whitelist) if {\n\tsome ip in whitelist\n\thelpers.is_public_cidr(trim_space(ip))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MONGODB::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPArray\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mongodb-public-and-any-ip-access-check", Name: models.I18nString{"en": "MongoDB Public and Any IP Access Check", "zh": "MongoDB 实例不开启公网或安全白名单不设置为允许任意来源访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that MongoDB instances do not have an open whitelist (0.0.0.0/0).", "zh": "确保 MongoDB 实例未设置开放白名单（0.0.0.0/0）。"}, Reason: models.I18nString{"en": "Setting the whitelist to 0.0.0.0/0 allows any IP to attempt connection, significantly increasing the risk of data breaches or brute force attacks.", "zh": "将白名单设置为 0.0.0.0/0 允许任何 IP 尝试连接，大大增加了数据泄露或暴力破解的风险。"}, Recommendation: models.I18nString{"en": "Restrict the IP whitelist for the MongoDB instance to specific trusted IP ranges.", "zh": "将 MongoDB 实例的 IP 白名单限制为特定的可信 IP 范围。"}, ResourceTypes: []string{"ALIYUN::MONGODB::Instance"}, FilePath: "aliyun/rules/mongodb-public-and-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.mongodb_public_and_any_ip_access_check", Content: "package infraguard.rules.aliyun.mongodb_public_and_any_ip_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mongodb-public-and-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"MongoDB Public and Any IP Access Check\",\n\t\t\"zh\": \"MongoDB 实例不开启公网或安全白名单不设置为允许任意来源访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MongoDB instances do not have an open whitelist (0.0.0.0/0).\",\n\t\t\"zh\": \"确保 MongoDB 实例未设置开放白名单（0.0.0.0/0）。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Setting the whitelist to 0.0.0.0/0 allows any IP to attempt connection, significantly increasing the risk of data breaches or brute force attacks.\",\n\t\t\"zh\": \"将白名单设置为 0.0.0.0/0 允许任何 IP 尝试连接，大大增加了数据泄露或暴力破解的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict the IP whitelist for the MongoDB instance to specific trusted IP ranges.\",\n\t\t\"zh\": \"将 MongoDB 实例的 IP 白名单限制为特定的可信 IP 范围。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MONGODB::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# Check SecurityIPArray property (string)\n\twhitelist_str := helpers.get_property(resource, \"SecurityIPArray\", \"\")\n\twhitelist := split(whitelist_str, \",\")\n\tnot has_open_cidr(whitelist)\n}\n\nhas_open_cidr(whitelist) if {\n\tsome cidr in whitelist\n\thelpers.is_public_cidr(trim_space(cidr))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MONGODB::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPArray\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-cluster-architecture-check", Name: models.I18nString{"en": "MSE Cluster Has Multiple Nodes", "zh": "MSE 注册配置中心多节点检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that MSE (Microservice Engine) clusters have more than 3 nodes for high availability.", "zh": "确保 MSE（微服务引擎）集群具有超过 3 个节点以实现高可用性。"}, Reason: models.I18nString{"en": "Clusters with 3 or fewer nodes may not provide adequate high availability.", "zh": "3 个或更少节点的集群可能无法提供足够的高可用性。"}, Recommendation: models.I18nString{"en": "Configure the MSE cluster with more than 3 nodes.", "zh": "将 MSE 集群配置为超过 3 个节点。"}, ResourceTypes: []string{"ALIYUN::MSE::Cluster"}, FilePath: "aliyun/rules/mse-cluster-architecture-check.rego", PackageName: "infraguard.rules.aliyun.mse_cluster_architecture_check", Content: "package infraguard.rules.aliyun.mse_cluster_architecture_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mse-cluster-architecture-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Cluster Has Multiple Nodes\",\n\t\t\"zh\": \"MSE 注册配置中心多节点检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MSE (Microservice Engine) clusters have more than 3 nodes for high availability.\",\n\t\t\"zh\": \"确保 MSE（微服务引擎）集群具有超过 3 个节点以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Clusters with 3 or fewer nodes may not provide adequate high availability.\",\n\t\t\"zh\": \"3 个或更少节点的集群可能无法提供足够的高可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the MSE cluster with more than 3 nodes.\",\n\t\t\"zh\": \"将 MSE 集群配置为超过 3 个节点。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Cluster\"],\n}\n\n# Get node count from cluster\nget_node_count(resource) := node_count if {\n\t# Try Nodes array first\n\tnodes := helpers.get_property(resource, \"Nodes\", [])\n\tcount(nodes) > 0\n\tnode_count := count(nodes)\n} else := node_count if {\n\t# Fall back to InstanceCount\n\tinstance_count := helpers.get_property(resource, \"InstanceCount\", 0)\n\tnode_count := instance_count\n}\n\n# Check if cluster has more than 3 nodes\nhas_multi_nodes(resource) if {\n\tget_node_count(resource) > 3\n}\n\nis_compliant(resource) if {\n\thas_multi_nodes(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Cluster\")\n\tnot has_multi_nodes(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Nodes\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-cluster-config-auth-enabled", Name: models.I18nString{"en": "MSE Cluster Config Auth Enabled", "zh": "MSE 集群配置中心开启鉴权"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the Microservices Engine (MSE) cluster configuration center has authentication enabled.", "zh": "确保微服务引擎(MSE)集群配置中心已开启鉴权。"}, Reason: models.I18nString{"en": "Enabling authentication prevents unauthorized access to service configurations.", "zh": "开启鉴权可防止对服务配置的未经授权访问。"}, Recommendation: models.I18nString{"en": "Enable authentication for the MSE cluster configuration center.", "zh": "为 MSE 集群配置中心开启鉴权。"}, ResourceTypes: []string{"ALIYUN::MSE::Cluster"}, FilePath: "aliyun/rules/mse-cluster-config-auth-enabled.rego", PackageName: "infraguard.rules.aliyun.mse_cluster_config_auth_enabled", Content: "package infraguard.rules.aliyun.mse_cluster_config_auth_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"mse-cluster-config-auth-enabled\",\n\t\"name\": {\n\t\t\"en\": \"MSE Cluster Config Auth Enabled\",\n\t\t\"zh\": \"MSE 集群配置中心开启鉴权\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the Microservices Engine (MSE) cluster configuration center has authentication enabled.\",\n\t\t\"zh\": \"确保微服务引擎(MSE)集群配置中心已开启鉴权。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Enabling authentication prevents unauthorized access to service configurations.\",\n\t\t\"zh\": \"开启鉴权可防止对服务配置的未经授权访问。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable authentication for the MSE cluster configuration center.\",\n\t\t\"zh\": \"为 MSE 集群配置中心开启鉴权。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Cluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Cluster\")\n\n\t# Conceptual check for auth\n\tnot helpers.has_property(resource, \"ConfigAuthEnabled\") # Simplified\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-cluster-internet-check", Name: models.I18nString{"en": "MSE Cluster Has No Public Internet Access", "zh": "MSE 集群公网检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that MSE clusters do not have public internet access enabled.", "zh": "确保 MSE 集群未开放公网访问。"}, Reason: models.I18nString{"en": "Public internet access increases the attack surface and security risks for the cluster.", "zh": "公网访问增加了集群的攻击面和安全风险。"}, Recommendation: models.I18nString{"en": "Configure the MSE cluster to use private network access only.", "zh": "配置 MSE 集群仅使用内网访问。"}, ResourceTypes: []string{"ALIYUN::MSE::Cluster"}, FilePath: "aliyun/rules/mse-cluster-internet-check.rego", PackageName: "infraguard.rules.aliyun.mse_cluster_internet_check", Content: "package infraguard.rules.aliyun.mse_cluster_internet_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mse-cluster-internet-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Cluster Has No Public Internet Access\",\n\t\t\"zh\": \"MSE 集群公网检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MSE clusters do not have public internet access enabled.\",\n\t\t\"zh\": \"确保 MSE 集群未开放公网访问。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public internet access increases the attack surface and security risks for the cluster.\",\n\t\t\"zh\": \"公网访问增加了集群的攻击面和安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the MSE cluster to use private network access only.\",\n\t\t\"zh\": \"配置 MSE 集群仅使用内网访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Cluster\"],\n}\n\n# Check if cluster has public internet access\nhas_public_internet(resource) if {\n\tnet_type := helpers.get_property(resource, \"NetType\", \"privatenet\")\n\tnet_type == \"pubnet\"\n}\n\nhas_public_internet(resource) if {\n\tpub_network_flow := helpers.get_property(resource, \"PubNetworkFlow\", 0)\n\tpub_network_flow > 0\n}\n\nhas_public_internet(resource) if {\n\tconnection_type := helpers.get_property(resource, \"ConnectionType\", \"\")\n\tconnection_type == \"single_eni\"\n\teip_enabled := helpers.get_property(resource, \"EipEnabled\", false)\n\thelpers.is_true(eip_enabled)\n}\n\nis_compliant(resource) if {\n\tnot has_public_internet(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Cluster\")\n\thas_public_internet(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NetType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-cluster-multi-availability-area-architecture-check", Name: models.I18nString{"en": "MSE Cluster High-Availability Configuration", "zh": "使用高可用版本的 MSE 注册配置中心"}, Severity: "medium", Description: models.I18nString{"en": "MSE clusters should use the Professional Edition with at least 3 instances (odd number) for high availability.", "zh": "使用高可用版本的 MSE 注册配置中心，视为合规。"}, Reason: models.I18nString{"en": "The MSE cluster does not meet high-availability requirements (Professional Edition requires InstanceCount >= 3 and odd number).", "zh": "MSE 集群不满足高可用性要求（专业版要求 InstanceCount >= 3 且为奇数）。"}, Recommendation: models.I18nString{"en": "Use Professional Edition (MseVersion: mse_pro) and set InstanceCount to at least 3 (odd number) for high availability.", "zh": "使用专业版（MseVersion: mse_pro）并将 InstanceCount 设置为至少 3（奇数）以实现高可用性。"}, ResourceTypes: []string{"ALIYUN::MSE::Cluster"}, FilePath: "aliyun/rules/mse-cluster-multi-availability-area-architecture-check.rego", PackageName: "infraguard.rules.aliyun.mse_cluster_multi_availability_area_architecture_check", Content: "package infraguard.rules.aliyun.mse_cluster_multi_availability_area_architecture_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"mse-cluster-multi-availability-area-architecture-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Cluster High-Availability Configuration\",\n\t\t\"zh\": \"使用高可用版本的 MSE 注册配置中心\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"MSE clusters should use the Professional Edition with at least 3 instances (odd number) for high availability.\",\n\t\t\"zh\": \"使用高可用版本的 MSE 注册配置中心，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The MSE cluster does not meet high-availability requirements (Professional Edition requires InstanceCount >= 3 and odd number).\",\n\t\t\"zh\": \"MSE 集群不满足高可用性要求（专业版要求 InstanceCount >= 3 且为奇数）。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use Professional Edition (MseVersion: mse_pro) and set InstanceCount to at least 3 (odd number) for high availability.\",\n\t\t\"zh\": \"使用专业版（MseVersion: mse_pro）并将 InstanceCount 设置为至少 3（奇数）以实现高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Cluster\"],\n}\n\n# Check if cluster is Professional Edition\nis_professional_edition(resource) if {\n\thelpers.has_property(resource, \"MseVersion\")\n\tmse_version := resource.Properties.MseVersion\n\tmse_version == \"mse_pro\"\n}\n\n# Check if instance count meets HA requirements (>= 3 and odd)\nhas_ha_instance_count(resource) if {\n\tinstance_count := resource.Properties.InstanceCount\n\tinstance_count >= 3\n\tinstance_count % 2 == 1\n}\n\n# Check if cluster is high availability\nis_high_availability(resource) if {\n\tis_professional_edition(resource)\n\thas_ha_instance_count(resource)\n}\n\n# Deny rule: MSE clusters should be high availability\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Cluster\")\n\tnot is_high_availability(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-cluster-stable-version-check", Name: models.I18nString{"en": "MSE Cluster Uses Stable Version", "zh": "MSE 注册配置中心引擎版本检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that MSE cluster engine version is greater than the minimum stable version.", "zh": "确保 MSE 集群引擎版本大于最小稳定版本。"}, Reason: models.I18nString{"en": "Older versions may have security vulnerabilities and lack latest features.", "zh": "旧版本可能存在安全漏洞且缺少最新功能。"}, Recommendation: models.I18nString{"en": "Upgrade the MSE cluster to a stable version.", "zh": "将 MSE 集群升级到稳定版本。"}, ResourceTypes: []string{"ALIYUN::MSE::Cluster"}, FilePath: "aliyun/rules/mse-cluster-stable-version-check.rego", PackageName: "infraguard.rules.aliyun.mse_cluster_stable_version_check", Content: "package infraguard.rules.aliyun.mse_cluster_stable_version_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mse-cluster-stable-version-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Cluster Uses Stable Version\",\n\t\t\"zh\": \"MSE 注册配置中心引擎版本检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MSE cluster engine version is greater than the minimum stable version.\",\n\t\t\"zh\": \"确保 MSE 集群引擎版本大于最小稳定版本。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Older versions may have security vulnerabilities and lack latest features.\",\n\t\t\"zh\": \"旧版本可能存在安全漏洞且缺少最新功能。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade the MSE cluster to a stable version.\",\n\t\t\"zh\": \"将 MSE 集群升级到稳定版本。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Cluster\"],\n}\n\n# Default minimum stable version\ndefault_min_version := \"3.5.0\"\n\n# Get minimum version from parameter or use default\nget_min_version := version if {\n\tversion := input.parameters.minVersion\n\tis_string(version)\n} else := default_min_version\n\n# Compare version strings (simple implementation)\nversion_greater(v1, v2) if {\n\tv1_parts := split(v1, \".\")\n\tv2_parts := split(v2, \".\")\n\n\t# Compare major version\n\tto_number(v1_parts[0]) > to_number(v2_parts[0])\n}\n\nversion_greater(v1, v2) if {\n\tv1_parts := split(v1, \".\")\n\tv2_parts := split(v2, \".\")\n\n\t# Major versions equal, compare minor\n\tto_number(v1_parts[0]) == to_number(v2_parts[0])\n\tto_number(v1_parts[1]) > to_number(v2_parts[1])\n}\n\n# Check if cluster version is stable\nis_stable_version(resource) if {\n\tcluster_version := helpers.get_property(resource, \"ClusterVersion\", \"\")\n\tcluster_version != \"\"\n\n\t# Extract version number from ClusterVersion (e.g., \"ZooKeeper_3_8_0\" -> \"3.8.0\")\n\tversion_parts := split(cluster_version, \"_\")\n\tcount(version_parts) >= 4\n\n\t# For \"ZooKeeper_3_8_0\", parts are [\"ZooKeeper\", \"3\", \"8\", \"0\"]\n\tmajor := version_parts[1]\n\tminor := version_parts[2]\n\tpatch := version_parts[3]\n\tversion := sprintf(\"%s.%s.%s\", [major, minor, patch])\n\tversion_greater(version, get_min_version())\n}\n\nis_compliant(resource) if {\n\tis_stable_version(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Cluster\")\n\tnot is_stable_version(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ClusterVersion\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-gateway-architecture-check", Name: models.I18nString{"en": "MSE Gateway Has Multiple Nodes", "zh": "MSE 云原生网关多节点检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that MSE (Microservice Engine) gateways have more than 1 node for high availability.", "zh": "确保 MSE（微服务引擎）网关具有超过 1 个节点以实现高可用性。"}, Reason: models.I18nString{"en": "Single-node gateways create a single point of failure and may cause service interruption.", "zh": "单节点网关存在单点故障，可能导致服务中断。"}, Recommendation: models.I18nString{"en": "Configure the MSE gateway with at least 2 nodes.", "zh": "将 MSE 网关配置为至少 2 个节点。"}, ResourceTypes: []string{"ALIYUN::MSE::Gateway"}, FilePath: "aliyun/rules/mse-gateway-architecture-check.rego", PackageName: "infraguard.rules.aliyun.mse_gateway_architecture_check", Content: "package infraguard.rules.aliyun.mse_gateway_architecture_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"mse-gateway-architecture-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Gateway Has Multiple Nodes\",\n\t\t\"zh\": \"MSE 云原生网关多节点检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that MSE (Microservice Engine) gateways have more than 1 node for high availability.\",\n\t\t\"zh\": \"确保 MSE（微服务引擎）网关具有超过 1 个节点以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Single-node gateways create a single point of failure and may cause service interruption.\",\n\t\t\"zh\": \"单节点网关存在单点故障，可能导致服务中断。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the MSE gateway with at least 2 nodes.\",\n\t\t\"zh\": \"将 MSE 网关配置为至少 2 个节点。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Gateway\"],\n}\n\n# Get node count from gateway\nget_node_count(resource) := node_count if {\n\t# Use Replica property\n\treplica := helpers.get_property(resource, \"Replica\", 0)\n\treplica > 0\n\tnode_count := replica\n} else := node_count if {\n\t# Fall back to Nodes array\n\tnodes := helpers.get_property(resource, \"Nodes\", [])\n\tnode_count := count(nodes)\n}\n\n# Check if gateway has more than 1 node\nhas_multi_nodes(resource) if {\n\tget_node_count(resource) > 1\n}\n\nis_compliant(resource) if {\n\thas_multi_nodes(resource)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Gateway\")\n\tnot has_multi_nodes(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Replica\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:mse-gateway-multi-availability-area-architecture-check", Name: models.I18nString{"en": "MSE Gateway Multi-Availability Zone Deployment", "zh": "MSE 云原生网关部署在多可用区"}, Severity: "medium", Description: models.I18nString{"en": "MSE gateways should be deployed across multiple availability zones by configuring a backup VSwitch.", "zh": "MSE 云原生网关部署在多可用区，视为合规。"}, Reason: models.I18nString{"en": "The MSE gateway does not have a backup VSwitch configured, which may affect availability.", "zh": "MSE 网关未配置备用交换机，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Configure a backup VSwitch by setting the BackupVSwitchId property to enable multi-zone deployment.", "zh": "通过设置 BackupVSwitchId 属性配置备用交换机，以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::MSE::Gateway"}, FilePath: "aliyun/rules/mse-gateway-multi-availability-area-architecture-check.rego", PackageName: "infraguard.rules.aliyun.mse_gateway_multi_availability_area_architecture_check", Content: "package infraguard.rules.aliyun.mse_gateway_multi_availability_area_architecture_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"mse-gateway-multi-availability-area-architecture-check\",\n\t\"name\": {\n\t\t\"en\": \"MSE Gateway Multi-Availability Zone Deployment\",\n\t\t\"zh\": \"MSE 云原生网关部署在多可用区\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"MSE gateways should be deployed across multiple availability zones by configuring a backup VSwitch.\",\n\t\t\"zh\": \"MSE 云原生网关部署在多可用区，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The MSE gateway does not have a backup VSwitch configured, which may affect availability.\",\n\t\t\"zh\": \"MSE 网关未配置备用交换机，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a backup VSwitch by setting the BackupVSwitchId property to enable multi-zone deployment.\",\n\t\t\"zh\": \"通过设置 BackupVSwitchId 属性配置备用交换机，以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::MSE::Gateway\"],\n}\n\n# Check if gateway has backup VSwitch\nhas_backup_vswitch(resource) if {\n\thelpers.has_property(resource, \"BackupVSwitchId\")\n\tbackup_vswitch := resource.Properties.BackupVSwitchId\n\tbackup_vswitch != \"\"\n}\n\n# Deny rule: MSE gateways should have backup VSwitch\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::MSE::Gateway\")\n\tnot has_backup_vswitch(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"BackupVSwitchId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nas-access-group-public-access-check", Name: models.I18nString{"en": "NAS Access Group IP Restriction", "zh": "NAS 权限组禁用公网授权"}, Severity: "high", Description: models.I18nString{"en": "Ensures NAS access rules do not allow 0.0.0.0/0.", "zh": "确保 NAS 权限规则不允许 0.0.0.0/0。"}, Reason: models.I18nString{"en": "An open NAS access rule can lead to unauthorized data access over the internet.", "zh": "开放的 NAS 权限规则可能导致互联网上的非授权数据访问。"}, Recommendation: models.I18nString{"en": "Restrict NAS access rules to specific trusted VPC IP ranges.", "zh": "将 NAS 权限规则限制在特定的可信 VPC IP 范围内。"}, ResourceTypes: []string{"ALIYUN::NAS::AccessRule"}, FilePath: "aliyun/rules/nas-access-group-public-access-check.rego", PackageName: "infraguard.rules.aliyun.nas_access_group_public_access_check", Content: "package infraguard.rules.aliyun.nas_access_group_public_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"nas-access-group-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"NAS Access Group IP Restriction\",\n\t\t\"zh\": \"NAS 权限组禁用公网授权\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures NAS access rules do not allow 0.0.0.0/0.\",\n\t\t\"zh\": \"确保 NAS 权限规则不允许 0.0.0.0/0。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"An open NAS access rule can lead to unauthorized data access over the internet.\",\n\t\t\"zh\": \"开放的 NAS 权限规则可能导致互联网上的非授权数据访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict NAS access rules to specific trusted VPC IP ranges.\",\n\t\t\"zh\": \"将 NAS 权限规则限制在特定的可信 VPC IP 范围内。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAS::AccessRule\"],\n}\n\nis_compliant(resource) if {\n\tip := helpers.get_property(resource, \"SourceCidrIp\", \"\")\n\tnot helpers.is_public_cidr(ip)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAS::AccessRule\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SourceCidrIp\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nas-filesystem-encrypt-type-check", Name: models.I18nString{"en": "NAS file system encryption configured", "zh": "NAS 文件系统设置了加密"}, Severity: "low", Description: models.I18nString{"en": "NAS file system has encryption configured, considered compliant.", "zh": "NAS 文件系统设置了加密,视为合规。"}, Reason: models.I18nString{"en": "NAS file system does not have encryption configured", "zh": "NAS 文件系统未设置加密"}, Recommendation: models.I18nString{"en": "Configure encryption for NAS file system to protect data at rest using KMS keys", "zh": "为 NAS 文件系统配置加密以使用 KMS 密钥保护静态数据"}, ResourceTypes: []string{"ALIYUN::NAS::FileSystem"}, FilePath: "aliyun/rules/nas-filesystem-encrypt-type-check.rego", PackageName: "infraguard.rules.aliyun.nas_filesystem_encrypt_type_check", Content: "package infraguard.rules.aliyun.nas_filesystem_encrypt_type_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"nas-filesystem-encrypt-type-check\",\n\t\"name\": {\n\t\t\"en\": \"NAS file system encryption configured\",\n\t\t\"zh\": \"NAS 文件系统设置了加密\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"NAS file system has encryption configured, considered compliant.\",\n\t\t\"zh\": \"NAS 文件系统设置了加密,视为合规。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::NAS::FileSystem\"],\n\t\"reason\": {\n\t\t\"en\": \"NAS file system does not have encryption configured\",\n\t\t\"zh\": \"NAS 文件系统未设置加密\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure encryption for NAS file system to protect data at rest using KMS keys\",\n\t\t\"zh\": \"为 NAS 文件系统配置加密以使用 KMS 密钥保护静态数据\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAS::FileSystem\")\n\n\t# Check if EncryptType is set to 1 (encrypted)\n\tencrypt_type := helpers.get_property(resource, \"EncryptType\", 0)\n\tencrypt_type != 1\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nas-filesystem-mount-target-access-group-check", Name: models.I18nString{"en": "NAS Mount Target Access Group Check", "zh": "NAS 挂载点禁用默认权限组"}, Severity: "medium", Description: models.I18nString{"en": "Ensures NAS mount targets do not use the 'DEFAULT_VPC_GROUP_NAME'.", "zh": "确保 NAS 挂载点未使用'DEFAULT_VPC_GROUP_NAME'。"}, Reason: models.I18nString{"en": "The default access group may have overly permissive rules.", "zh": "默认权限组可能拥有过于宽松的规则。"}, Recommendation: models.I18nString{"en": "Use a custom access group with restricted rules for NAS mount targets.", "zh": "为 NAS 挂载点使用规则受限的自定义权限组。"}, ResourceTypes: []string{"ALIYUN::NAS::MountTarget"}, FilePath: "aliyun/rules/nas-filesystem-mount-target-access-group-check.rego", PackageName: "infraguard.rules.aliyun.nas_filesystem_mount_target_access_group_check", Content: "package infraguard.rules.aliyun.nas_filesystem_mount_target_access_group_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"nas-filesystem-mount-target-access-group-check\",\n\t\"name\": {\n\t\t\"en\": \"NAS Mount Target Access Group Check\",\n\t\t\"zh\": \"NAS 挂载点禁用默认权限组\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures NAS mount targets do not use the 'DEFAULT_VPC_GROUP_NAME'.\",\n\t\t\"zh\": \"确保 NAS 挂载点未使用'DEFAULT_VPC_GROUP_NAME'。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The default access group may have overly permissive rules.\",\n\t\t\"zh\": \"默认权限组可能拥有过于宽松的规则。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use a custom access group with restricted rules for NAS mount targets.\",\n\t\t\"zh\": \"为 NAS 挂载点使用规则受限的自定义权限组。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAS::MountTarget\"],\n}\n\nis_compliant(resource) if {\n\tgroup := helpers.get_property(resource, \"AccessGroupName\", \"DEFAULT_VPC_GROUP_NAME\")\n\tgroup != \"DEFAULT_VPC_GROUP_NAME\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAS::MountTarget\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AccessGroupName\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nat-risk-ports-check", Name: models.I18nString{"en": "NAT Gateway Risk Ports Check", "zh": "NAT 网关不允许映射指定的风险端口"}, Severity: "high", Description: models.I18nString{"en": "NAT gateway DNAT mappings should not expose risky ports to the internet to prevent security vulnerabilities.", "zh": "NAT 网关 DNAT 映射端口不包含指定的风险端口，视为合规。"}, Reason: models.I18nString{"en": "Exposing risky ports through DNAT can lead to security vulnerabilities and potential attacks.", "zh": "通过 DNAT 暴露风险端口可能导致安全漏洞和潜在攻击。"}, Recommendation: models.I18nString{"en": "Avoid mapping well-known risky ports (e.g., 22, 3389, 445) through DNAT.", "zh": "避免通过 DNAT 映射已知的风险端口（如 22、3389、445 等）。"}, ResourceTypes: []string{"ALIYUN::NAT::NatGateway"}, FilePath: "aliyun/rules/nat-risk-ports-check.rego", PackageName: "infraguard.rules.aliyun.nat_risk_ports_check", Content: "package infraguard.rules.aliyun.nat_risk_ports_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"nat-risk-ports-check\",\n\t\"name\": {\n\t\t\"en\": \"NAT Gateway Risk Ports Check\",\n\t\t\"zh\": \"NAT 网关不允许映射指定的风险端口\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"NAT gateway DNAT mappings should not expose risky ports to the internet to prevent security vulnerabilities.\",\n\t\t\"zh\": \"NAT 网关 DNAT 映射端口不包含指定的风险端口，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Exposing risky ports through DNAT can lead to security vulnerabilities and potential attacks.\",\n\t\t\"zh\": \"通过 DNAT 暴露风险端口可能导致安全漏洞和潜在攻击。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Avoid mapping well-known risky ports (e.g., 22, 3389, 445) through DNAT.\",\n\t\t\"zh\": \"避免通过 DNAT 映射已知的风险端口（如 22、3389、445 等）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAT::NatGateway\"],\n}\n\n# Common risky ports that should not be exposed\nrisky_ports := {\"22\", \"23\", \"445\", \"3389\", \"1433\", \"3306\", \"5432\", \"6379\", \"8080\", \"8443\"}\n\ncontains_risky_port(resource) if {\n\t# Simplified check - in production would check ForwardTable entries\n\tforward_table := helpers.get_property(resource, \"ForwardTableId\", \"\")\n\tforward_table != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAT::NatGateway\")\n\n\t# This is a placeholder - actual implementation would check DNAT entries\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ForwardTableId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:natgateway-delete-protection-enabled", Name: models.I18nString{"en": "NAT Gateway Deletion Protection Enabled", "zh": "NAT 网关启用释放保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that NAT Gateways have deletion protection enabled.", "zh": "确保 NAT 网关开启了释放保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the NAT Gateway may be released accidentally, causing loss of internet connectivity for resources in the VPC.", "zh": "如果未开启释放保护，NAT 网关可能会被意外释放，导致 VPC 内资源失去互联网连接。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the NAT Gateway.", "zh": "为 NAT 网关开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::VPC::NatGateway"}, FilePath: "aliyun/rules/natgateway-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.natgateway_delete_protection_enabled", Content: "package infraguard.rules.aliyun.natgateway_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"natgateway-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"NAT Gateway Deletion Protection Enabled\",\n\t\t\"zh\": \"NAT 网关启用释放保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that NAT Gateways have deletion protection enabled.\",\n\t\t\"zh\": \"确保 NAT 网关开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the NAT Gateway may be released accidentally, causing loss of internet connectivity for resources in the VPC.\",\n\t\t\"zh\": \"如果未开启释放保护，NAT 网关可能会被意外释放，导致 VPC 内资源失去互联网连接。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the NAT Gateway.\",\n\t\t\"zh\": \"为 NAT 网关开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::NatGateway\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::NatGateway\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:natgateway-eip-used-check", Name: models.I18nString{"en": "NAT Gateway EIP Usage Check", "zh": "NAT 网关中 SNAT 和 DNAT 未使用同一个 EIP"}, Severity: "medium", Description: models.I18nString{"en": "SNAT and DNAT should not use the same EIP to avoid potential conflicts and improve network segmentation.", "zh": "NAT 网关的 SNAT 和 DNAT 未同时使用同一个 EIP，视为合规。"}, Reason: models.I18nString{"en": "Using the same EIP for both SNAT and DNAT can lead to routing conflicts and security issues.", "zh": "SNAT 和 DNAT 使用同一个 EIP 可能导致路由冲突和安全问题。"}, Recommendation: models.I18nString{"en": "Configure different EIPs for SNAT and DNAT entries.", "zh": "为 SNAT 和 DNAT 条目配置不同的 EIP。"}, ResourceTypes: []string{"ALIYUN::NAT::NatGateway"}, FilePath: "aliyun/rules/natgateway-eip-used-check.rego", PackageName: "infraguard.rules.aliyun.natgateway_eip_used_check", Content: "package infraguard.rules.aliyun.natgateway_eip_used_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"natgateway-eip-used-check\",\n\t\"name\": {\n\t\t\"en\": \"NAT Gateway EIP Usage Check\",\n\t\t\"zh\": \"NAT 网关中 SNAT 和 DNAT 未使用同一个 EIP\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"SNAT and DNAT should not use the same EIP to avoid potential conflicts and improve network segmentation.\",\n\t\t\"zh\": \"NAT 网关的 SNAT 和 DNAT 未同时使用同一个 EIP，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using the same EIP for both SNAT and DNAT can lead to routing conflicts and security issues.\",\n\t\t\"zh\": \"SNAT 和 DNAT 使用同一个 EIP 可能导致路由冲突和安全问题。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure different EIPs for SNAT and DNAT entries.\",\n\t\t\"zh\": \"为 SNAT 和 DNAT 条目配置不同的 EIP。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::NAT::NatGateway\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NAT::NatGateway\")\n\n\t# Simplified check - in practice would check ForwardTableId and SNatTableId\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:natgateway-snat-eip-bandwidth-check", Name: models.I18nString{"en": "NAT Gateway SNAT EIP Bandwidth Consistency", "zh": "NAT 网关 SNAT 条目绑定多个 EIP 时带宽峰值设置一致"}, Severity: "medium", Description: models.I18nString{"en": "When SNAT entries are bound to multiple EIPs, the bandwidth peak settings should be consistent or they should be added to a shared bandwidth package.", "zh": "NAT 网关中 SNAT 条目绑定的多个 EIP，加入共享带宽包或者所绑定的 EIP 带宽峰值设置一致，视为合规。"}, Reason: models.I18nString{"en": "Inconsistent bandwidth settings can lead to unpredictable network performance and potential traffic distribution issues.", "zh": "不一致的带宽设置可能导致不可预测的网络性能和潜在的流量分配问题。"}, Recommendation: models.I18nString{"en": "Ensure all EIPs bound to SNAT entries have consistent bandwidth settings or use a shared bandwidth package.", "zh": "确保绑定到 SNAT 条目的所有 EIP 具有一致的带宽设置，或使用共享带宽包。"}, ResourceTypes: []string{"ALIYUN::VPC::NatGateway"}, FilePath: "aliyun/rules/natgateway-snat-eip-bandwidth-check.rego", PackageName: "infraguard.rules.aliyun.natgateway_snat_eip_bandwidth_check", Content: "package infraguard.rules.aliyun.natgateway_snat_eip_bandwidth_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"natgateway-snat-eip-bandwidth-check\",\n\t\"name\": {\n\t\t\"en\": \"NAT Gateway SNAT EIP Bandwidth Consistency\",\n\t\t\"zh\": \"NAT 网关 SNAT 条目绑定多个 EIP 时带宽峰值设置一致\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"When SNAT entries are bound to multiple EIPs, the bandwidth peak settings should be consistent or they should be added to a shared bandwidth package.\",\n\t\t\"zh\": \"NAT 网关中 SNAT 条目绑定的多个 EIP，加入共享带宽包或者所绑定的 EIP 带宽峰值设置一致，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Inconsistent bandwidth settings can lead to unpredictable network performance and potential traffic distribution issues.\",\n\t\t\"zh\": \"不一致的带宽设置可能导致不可预测的网络性能和潜在的流量分配问题。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure all EIPs bound to SNAT entries have consistent bandwidth settings or use a shared bandwidth package.\",\n\t\t\"zh\": \"确保绑定到 SNAT 条目的所有 EIP 具有一致的带宽设置，或使用共享带宽包。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::NatGateway\"],\n}\n\nis_vpc_nat_gateway(resource) if {\n\tnetwork_type := helpers.get_property(resource, \"NetworkType\", \"\")\n\tnetwork_type == \"intranet\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::NatGateway\")\n\tnot is_vpc_nat_gateway(resource)\n\n\t# Simplified check: assumes proper configuration is present\n\tnot helpers.has_property(resource, \"EipBindMode\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EipBindMode\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nlb-loadbalancer-multi-zone", Name: models.I18nString{"en": "NLB LoadBalancer Multi-Zone Deployment", "zh": "使用多可用区的网络负载均衡实例"}, Severity: "medium", Description: models.I18nString{"en": "NLB LoadBalancer instances should be deployed across at least two availability zones for high availability.", "zh": "使用多可用区的网络负载均衡实例，视为合规。"}, Reason: models.I18nString{"en": "The NLB LoadBalancer is deployed in fewer than two availability zones, creating a single point of failure risk.", "zh": "网络负载均衡实例部署在少于两个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure at least two zone mappings in the ZoneMappings property to ensure high availability.", "zh": "在 ZoneMappings 属性中配置至少两个可用区映射，以确保高可用性。"}, ResourceTypes: []string{"ALIYUN::NLB::LoadBalancer"}, FilePath: "aliyun/rules/nlb-loadbalancer-multi-zone.rego", PackageName: "infraguard.rules.aliyun.nlb_loadbalancer_multi_zone", Content: "package infraguard.rules.aliyun.nlb_loadbalancer_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"nlb-loadbalancer-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"NLB LoadBalancer Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的网络负载均衡实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"NLB LoadBalancer instances should be deployed across at least two availability zones for high availability.\",\n\t\t\"zh\": \"使用多可用区的网络负载均衡实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The NLB LoadBalancer is deployed in fewer than two availability zones, creating a single point of failure risk.\",\n\t\t\"zh\": \"网络负载均衡实例部署在少于两个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two zone mappings in the ZoneMappings property to ensure high availability.\",\n\t\t\"zh\": \"在 ZoneMappings 属性中配置至少两个可用区映射，以确保高可用性。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::NLB::LoadBalancer\"],\n}\n\n# Check if LoadBalancer has multiple zones\nhas_multiple_zones(resource) if {\n\tzone_mappings := resource.Properties.ZoneMappings\n\tcount(zone_mappings) >= 2\n}\n\n# Deny rule: NLB LoadBalancers must be deployed in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NLB::LoadBalancer\")\n\tnot has_multiple_zones(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneMappings\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:nlb-server-group-multi-zone", Name: models.I18nString{"en": "NLB Server Group Multi-Zone Distribution", "zh": "NLB 负载均衡服务器组添加多个可用区资源"}, Severity: "medium", Description: models.I18nString{"en": "NLB server groups should have backend servers distributed across multiple availability zones for high availability. This rule does not apply to server groups with no attached servers, or to IP type server groups.", "zh": "网络负载均衡的服务器组中资源分布在多个可用区，视为合规。服务器组中无资源或者资源类型为 IP 时，视为不适用。"}, Reason: models.I18nString{"en": "The NLB server group has backend servers in only one availability zone, creating a single point of failure.", "zh": "NLB 服务器组的后端服务器仅分布在一个可用区，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Add backend servers from at least two different availability zones to the server group using ALIYUN::NLB::BackendServerAttachment resources.", "zh": "使用 ALIYUN::NLB::BackendServerAttachment 资源，向服务器组添加来自至少两个不同可用区的后端服务器。"}, ResourceTypes: []string{"ALIYUN::NLB::ServerGroup"}, FilePath: "aliyun/rules/nlb-server-group-multi-zone.rego", PackageName: "infraguard.rules.aliyun.nlb_server_group_multi_zone", Content: "package infraguard.rules.aliyun.nlb_server_group_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"nlb-server-group-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"NLB Server Group Multi-Zone Distribution\",\n\t\t\"zh\": \"NLB 负载均衡服务器组添加多个可用区资源\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"NLB server groups should have backend servers distributed across multiple availability zones for high availability. This rule does not apply to server groups with no attached servers, or to IP type server groups.\",\n\t\t\"zh\": \"网络负载均衡的服务器组中资源分布在多个可用区，视为合规。服务器组中无资源或者资源类型为 IP 时，视为不适用。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The NLB server group has backend servers in only one availability zone, creating a single point of failure.\",\n\t\t\"zh\": \"NLB 服务器组的后端服务器仅分布在一个可用区，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add backend servers from at least two different availability zones to the server group using ALIYUN::NLB::BackendServerAttachment resources.\",\n\t\t\"zh\": \"使用 ALIYUN::NLB::BackendServerAttachment 资源，向服务器组添加来自至少两个不同可用区的后端服务器。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::NLB::ServerGroup\"],\n}\n\n# Check if server group type is applicable (Instance)\nis_applicable_type(resource) if {\n\tserver_group_type := helpers.get_property(resource, \"ServerGroupType\", \"Instance\")\n\tserver_group_type == \"Instance\"\n}\n\n# Get server group ID from reference or direct value\nget_server_group_id(value) := value if {\n\tis_string(value)\n}\n\nget_server_group_id(value) := value.Ref if {\n\tis_object(value)\n\tvalue.Ref\n}\n\n# Get server ID from reference or direct value\nget_server_id(value) := value if {\n\tis_string(value)\n}\n\nget_server_id(value) := value.Ref if {\n\tis_object(value)\n\tvalue.Ref\n}\n\n# Check if attachment belongs to this server group\nattachment_belongs_to_group(attachment, server_group_id) if {\n\tgroup_id := get_server_group_id(attachment.Properties.ServerGroupId)\n\tgroup_id == server_group_id\n}\n\n# Get all zones from backend servers for a server group\nzones_for_server_group(server_group_id) := zones if {\n\t# Find all attachments for this server group\n\tattachments := [attachment |\n\t\tsome _, attachment in helpers.resources_by_type(\"ALIYUN::NLB::BackendServerAttachment\")\n\t\tattachment_belongs_to_group(attachment, server_group_id)\n\t]\n\n\t# Get all zones from servers in these attachments\n\tzones := {zone |\n\t\tsome attachment in attachments\n\t\tsome server in attachment.Properties.Servers\n\t\tserver_id := get_server_id(server.ServerId)\n\n\t\t# Look up the server resource\n\t\tsome name, resource in input.Resources\n\t\tname == server_id\n\t\tresource.Type in {\"ALIYUN::ECS::Instance\", \"ALIYUN::ECS::InstanceGroup\"}\n\t\tzone := resource.Properties.ZoneId\n\t}\n}\n\n# Check if server group has attachments\nhas_attachments(server_group_id) if {\n\tsome _, attachment in helpers.resources_by_type(\"ALIYUN::NLB::BackendServerAttachment\")\n\tattachment_belongs_to_group(attachment, server_group_id)\n}\n\n# Check if servers are distributed across multiple zones\nis_multi_zone_distributed(server_group_id) if {\n\tzones := zones_for_server_group(server_group_id)\n\tcount(zones) >= 2\n}\n\n# Deny rule: NLB server groups must have servers in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::NLB::ServerGroup\")\n\n\t# Only check Instance type server groups\n\tis_applicable_type(resource)\n\n\t# Only check if there are attachments\n\thas_attachments(name)\n\n\t# Check if not multi-zone\n\tnot is_multi_zone_distributed(name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-anonymous-prohibited", Name: models.I18nString{"en": "OSS Bucket Anonymous Access Prohibited", "zh": "OSS 存储桶禁用匿名访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that anonymous access is prohibited for the OSS bucket.", "zh": "确保 OSS 存储桶禁用了匿名访问。"}, Reason: models.I18nString{"en": "Anonymous access to an OSS bucket increases the risk of unauthorized data exposure.", "zh": "对 OSS 存储桶的匿名访问增加了数据未经授权泄露的风险。"}, Recommendation: models.I18nString{"en": "Configure the OSS bucket ACL to 'private' and ensure no public read/write permissions are granted to anonymous users.", "zh": "将 OSS 存储桶 ACL 配置为'private'，并确保未向匿名用户授予公开读写权限。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-anonymous-prohibited.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_anonymous_prohibited", Content: "package infraguard.rules.aliyun.oss_bucket_anonymous_prohibited\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"oss-bucket-anonymous-prohibited\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Anonymous Access Prohibited\",\n\t\t\"zh\": \"OSS 存储桶禁用匿名访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that anonymous access is prohibited for the OSS bucket.\",\n\t\t\"zh\": \"确保 OSS 存储桶禁用了匿名访问。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Anonymous access to an OSS bucket increases the risk of unauthorized data exposure.\",\n\t\t\"zh\": \"对 OSS 存储桶的匿名访问增加了数据未经授权泄露的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the OSS bucket ACL to 'private' and ensure no public read/write permissions are granted to anonymous users.\",\n\t\t\"zh\": \"将 OSS 存储桶 ACL 配置为'private'，并确保未向匿名用户授予公开读写权限。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Conceptual check for public access\n\tacl := helpers.get_property(resource, \"AccessControlList\", \"private\")\n\tacl != \"private\"\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AccessControlList\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-authorize-specified-ip", Name: models.I18nString{"en": "OSS Bucket Authorize Specified IP", "zh": "OSS 存储桶策略授权特定 IP"}, Severity: "medium", Description: models.I18nString{"en": "Ensures OSS bucket policies restrict access to specified IP ranges.", "zh": "确保 OSS 存储桶策略限制了特定 IP 范围的访问。"}, Reason: models.I18nString{"en": "Restricting access by IP helps prevent unauthorized access even if credentials are compromised.", "zh": "通过 IP 限制访问有助于防止在凭据泄露时发生未经授权的访问。"}, Recommendation: models.I18nString{"en": "Add IP restriction conditions (acs:SourceIp) to the OSS bucket policy.", "zh": "在 OSS 存储桶策略中添加 IP 限制条件（acs:SourceIp）。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-authorize-specified-ip.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_authorize_specified_ip", Content: "package infraguard.rules.aliyun.oss_bucket_authorize_specified_ip\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"oss-bucket-authorize-specified-ip\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Authorize Specified IP\",\n\t\t\"zh\": \"OSS 存储桶策略授权特定 IP\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures OSS bucket policies restrict access to specified IP ranges.\",\n\t\t\"zh\": \"确保 OSS 存储桶策略限制了特定 IP 范围的访问。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Restricting access by IP helps prevent unauthorized access even if credentials are compromised.\",\n\t\t\"zh\": \"通过 IP 限制访问有助于防止在凭据泄露时发生未经授权的访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add IP restriction conditions (acs:SourceIp) to the OSS bucket policy.\",\n\t\t\"zh\": \"在 OSS 存储桶策略中添加 IP 限制条件（acs:SourceIp）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\nis_compliant(resource) if {\n\tpolicy := helpers.get_property(resource, \"Policy\", {})\n\tstatements := object.get(policy, \"Statement\", [])\n\tsome statement in statements\n\tcondition := object.get(statement, \"Condition\", {})\n\tip_address := object.get(condition, \"IpAddress\", {})\n\n\t# Check for acs:SourceIp in the IpAddress condition\n\tobject.get(ip_address, \"acs:SourceIp\", null) != null\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Policy\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-backup-enable", Name: models.I18nString{"en": "OSS Backup Enabled", "zh": "OSS 开启备份"}, Severity: "medium", Description: models.I18nString{"en": "Ensures OSS buckets have backup or versioning enabled.", "zh": "确保 OSS 存储桶开启了备份或版本控制。"}, Reason: models.I18nString{"en": "Backups and versioning prevent data loss from accidental deletion or modification.", "zh": "备份和版本控制可防止因意外删除或修改导致的数据丢失。"}, Recommendation: models.I18nString{"en": "Enable versioning or cross-region replication for the OSS bucket.", "zh": "为 OSS 存储桶开启版本控制或跨区域复制。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-backup-enable.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_backup_enable", Content: "package infraguard.rules.aliyun.oss_bucket_backup_enable\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"oss-bucket-backup-enable\",\n\t\"name\": {\n\t\t\"en\": \"OSS Backup Enabled\",\n\t\t\"zh\": \"OSS 开启备份\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures OSS buckets have backup or versioning enabled.\",\n\t\t\"zh\": \"确保 OSS 存储桶开启了备份或版本控制。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Backups and versioning prevent data loss from accidental deletion or modification.\",\n\t\t\"zh\": \"备份和版本控制可防止因意外删除或修改导致的数据丢失。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable versioning or cross-region replication for the OSS bucket.\",\n\t\t\"zh\": \"为 OSS 存储桶开启版本控制或跨区域复制。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\nis_compliant(resource) if {\n\t# Versioning check\n\tv := helpers.get_property(resource, \"VersioningConfiguration\", {})\n\tv.Status == \"Enabled\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VersioningConfiguration\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-logging-enabled", Name: models.I18nString{"en": "OSS Bucket Logging Enabled", "zh": "OSS 存储空间开启日志转存"}, Severity: "medium", Description: models.I18nString{"en": "OSS buckets should have logging enabled to track access and operations. Logging helps with security auditing, troubleshooting, and compliance requirements.", "zh": "OSS 存储空间应开启日志转存以跟踪访问和操作。日志记录有助于安全审计、故障排查和合规要求。"}, Reason: models.I18nString{"en": "The OSS bucket does not have logging enabled, which makes it difficult to track access and operations for security and compliance purposes.", "zh": "OSS 存储空间未开启日志转存，难以跟踪访问和操作以满足安全和合规要求。"}, Recommendation: models.I18nString{"en": "Enable logging for the OSS bucket by configuring the LoggingConfiguration property with TargetBucket and optionally TargetPrefix.", "zh": "通过配置 LoggingConfiguration 属性并设置 TargetBucket 和可选的 TargetPrefix，为 OSS 存储空间启用日志转存。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-logging-enabled.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_logging_enabled", Content: "package infraguard.rules.aliyun.oss_bucket_logging_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-logging-enabled\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Logging Enabled\",\n\t\t\"zh\": \"OSS 存储空间开启日志转存\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should have logging enabled to track access and operations. Logging helps with security auditing, troubleshooting, and compliance requirements.\",\n\t\t\"zh\": \"OSS 存储空间应开启日志转存以跟踪访问和操作。日志记录有助于安全审计、故障排查和合规要求。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket does not have logging enabled, which makes it difficult to track access and operations for security and compliance purposes.\",\n\t\t\"zh\": \"OSS 存储空间未开启日志转存，难以跟踪访问和操作以满足安全和合规要求。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable logging for the OSS bucket by configuring the LoggingConfiguration property with TargetBucket and optionally TargetPrefix.\",\n\t\t\"zh\": \"通过配置 LoggingConfiguration 属性并设置 TargetBucket 和可选的 TargetPrefix，为 OSS 存储空间启用日志转存。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot has_logging_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoggingConfiguration\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nhas_logging_enabled(resource) if {\n\thelpers.has_property(resource, \"LoggingConfiguration\")\n\tlogging_config := resource.Properties.LoggingConfiguration\n\tlogging_config.TargetBucket != null\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-only-https-enabled", Name: models.I18nString{"en": "OSS Bucket Only HTTPS Enabled", "zh": "OSS 存储桶开启仅允许 HTTPS 访问"}, Severity: "high", Description: models.I18nString{"en": "OSS bucket should have a policy that denies non-HTTPS requests to ensure data transport security.", "zh": "OSS 存储桶应配置仅允许 HTTPS 访问的策略，以确保数据传输安全。"}, Reason: models.I18nString{"en": "The OSS bucket allows non-HTTPS requests, which may lead to data interception or tampering during transport.", "zh": "OSS 存储桶允许非 HTTPS 请求，可能导致数据在传输过程中被窃听或篡改。"}, Recommendation: models.I18nString{"en": "Configure a bucket policy that denies requests where 'acs:SecureTransport' is false.", "zh": "配置存储桶策略，拒绝 'acs:SecureTransport' 为 false 的请求。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-only-https-enabled.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_only_https_enabled", Content: "package infraguard.rules.aliyun.oss_bucket_only_https_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-only-https-enabled\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Only HTTPS Enabled\",\n\t\t\"zh\": \"OSS 存储桶开启仅允许 HTTPS 访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"OSS bucket should have a policy that denies non-HTTPS requests to ensure data transport security.\",\n\t\t\"zh\": \"OSS 存储桶应配置仅允许 HTTPS 访问的策略，以确保数据传输安全。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket allows non-HTTPS requests, which may lead to data interception or tampering during transport.\",\n\t\t\"zh\": \"OSS 存储桶允许非 HTTPS 请求，可能导致数据在传输过程中被窃听或篡改。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a bucket policy that denies requests where 'acs:SecureTransport' is false.\",\n\t\t\"zh\": \"配置存储桶策略，拒绝 'acs:SecureTransport' 为 false 的请求。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\n# Check if the bucket has a policy that enforces HTTPS\nis_only_https_enabled(resource) if {\n\tpolicy := helpers.get_property(resource, \"Policy\", {})\n\tstatements := object.get(policy, \"Statement\", [])\n\tsome statement in statements\n\tstatement.Effect == \"Deny\"\n\n\t# Check for SecureTransport condition\n\tcondition := object.get(statement, \"Condition\", {})\n\tbool_cond := object.get(condition, \"Bool\", {})\n\tsecure_transport := object.get(bool_cond, \"acs:SecureTransport\", null)\n\thas_false_value(secure_transport)\n}\n\nhas_false_value(val) if {\n\tval == \"false\"\n}\n\nhas_false_value(val) if {\n\tval == false\n}\n\nhas_false_value(val) if {\n\tis_array(val)\n\tsome item in val\n\titem_is_false(item)\n}\n\nitem_is_false(v) if {\n\tv == \"false\"\n}\n\nitem_is_false(v) if {\n\tv == false\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_only_https_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Policy\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-policy-no-any-anonymous", Name: models.I18nString{"en": "OSS bucket policy does not grant permissions to anonymous users", "zh": "OSS 存储空间不能为匿名账号授予任何权限"}, Severity: "high", Description: models.I18nString{"en": "OSS bucket policy does not grant any read or write permissions to anonymous users.", "zh": "OSS Bucket 授权策略中未授予匿名账号任何读写权限。"}, Reason: models.I18nString{"en": "OSS bucket policy grants permissions to anonymous users, which may expose sensitive data.", "zh": "OSS Bucket 授权策略授予匿名账号权限,可能导致敏感数据泄露。"}, Recommendation: models.I18nString{"en": "Remove anonymous user permissions from OSS bucket policy. Ensure Principal does not contain '*' for anonymous access.", "zh": "从 OSS Bucket 授权策略中移除匿名用户权限。确保 Principal 不包含'*'以避免匿名访问。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-policy-no-any-anonymous.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_policy_no_any_anonymous", Content: "package infraguard.rules.aliyun.oss_bucket_policy_no_any_anonymous\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-policy-no-any-anonymous\",\n\t\"name\": {\n\t\t\"en\": \"OSS bucket policy does not grant permissions to anonymous users\",\n\t\t\"zh\": \"OSS 存储空间不能为匿名账号授予任何权限\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"OSS bucket policy does not grant any read or write permissions to anonymous users.\",\n\t\t\"zh\": \"OSS Bucket 授权策略中未授予匿名账号任何读写权限。\",\n\t},\n\t\"severity\": \"high\",\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n\t\"reason\": {\n\t\t\"en\": \"OSS bucket policy grants permissions to anonymous users, which may expose sensitive data.\",\n\t\t\"zh\": \"OSS Bucket 授权策略授予匿名账号权限,可能导致敏感数据泄露。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove anonymous user permissions from OSS bucket policy. Ensure Principal does not contain '*' for anonymous access.\",\n\t\t\"zh\": \"从 OSS Bucket 授权策略中移除匿名用户权限。确保 Principal 不包含'*'以避免匿名访问。\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Check if bucket has a policy\n\tpolicy := helpers.get_property(resource, \"Policy\", {})\n\n\t# If no policy is set, it's compliant (no anonymous access granted)\n\tcount(policy) > 0\n\n\t# Check if policy contains statements\n\tstatement := policy.Statement[_]\n\n\t# Check if statement grants access to anonymous users (Principal: \"*\")\n\tprincipal := object.get(statement, \"Principal\", \"\")\n\tprincipal == \"*\"\n\tstatement.Effect == \"Allow\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Policy\", \"Statement\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-policy-outside-organization-check", Name: models.I18nString{"en": "OSS Bucket Policy No Outside Organization Access", "zh": "OSS 存储桶策略未给组织外授权"}, Severity: "high", Description: models.I18nString{"en": "Ensures OSS bucket policies do not grant access to principals outside of the organization.", "zh": "确保 OSS 存储桶策略未授予组织外部的主体访问权限。"}, Reason: models.I18nString{"en": "Granting access to external principals can lead to data leaks outside the organization's control.", "zh": "授予外部主体访问权限可能导致数据在组织控制之外泄露。"}, Recommendation: models.I18nString{"en": "Ensure all principals in the bucket policy are within the authorized organization.", "zh": "确保存储桶策略中的所有主体均属于获得授权的组织。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-policy-outside-organization-check.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_policy_outside_organization_check", Content: "package infraguard.rules.aliyun.oss_bucket_policy_outside_organization_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"oss-bucket-policy-outside-organization-check\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Policy No Outside Organization Access\",\n\t\t\"zh\": \"OSS 存储桶策略未给组织外授权\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures OSS bucket policies do not grant access to principals outside of the organization.\",\n\t\t\"zh\": \"确保 OSS 存储桶策略未授予组织外部的主体访问权限。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Granting access to external principals can lead to data leaks outside the organization's control.\",\n\t\t\"zh\": \"授予外部主体访问权限可能导致数据在组织控制之外泄露。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure all principals in the bucket policy are within the authorized organization.\",\n\t\t\"zh\": \"确保存储桶策略中的所有主体均属于获得授权的组织。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\n# Simplified implementation for IaC: Check if any Principal is '*' without a restrictive Condition\n# or if Principal is an external account ID (not easily detectable in pure IaC without context).\n# Here we check for '*' in Allow statements.\nis_compliant(resource) if {\n\tpolicy := helpers.get_property(resource, \"Policy\", {})\n\tstatements := object.get(policy, \"Statement\", [])\n\tnot has_external_allow(statements)\n}\n\nhas_external_allow(statements) if {\n\tsome statement in statements\n\tstatement.Effect == \"Allow\"\n\tprincipal := object.get(statement, \"Principal\", [])\n\tis_public_principal(principal)\n}\n\nis_public_principal(\"*\") := true\n\nis_public_principal(p) if {\n\tis_array(p)\n\tsome item in p\n\titem == \"*\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Policy\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-public-read-prohibited", Name: models.I18nString{"en": "OSS Bucket Public Read Prohibited", "zh": "OSS 存储空间 ACL 不开启公共读"}, Severity: "high", Description: models.I18nString{"en": "OSS buckets should not allow public read access unless specifically required. Public read access allows anyone to access and download objects in the bucket.", "zh": "除非特别需要，OSS 存储空间不应允许公共读取访问。公共读取访问允许任何人访问和下载存储空间中的对象。"}, Reason: models.I18nString{"en": "The OSS bucket has public read access enabled, which may expose sensitive data to unauthorized access.", "zh": "OSS 存储空间启用了公共读取访问，可能导致敏感数据暴露给未授权访问。"}, Recommendation: models.I18nString{"en": "Change the bucket ACL to private by setting the AccessControl property to 'private'.", "zh": "通过将 AccessControl 属性设置为'private'，将存储空间 ACL 更改为私有。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-public-read-prohibited.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_public_read_prohibited", Content: "package infraguard.rules.aliyun.oss_bucket_public_read_prohibited\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-public-read-prohibited\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Public Read Prohibited\",\n\t\t\"zh\": \"OSS 存储空间 ACL 不开启公共读\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should not allow public read access unless specifically required. Public read access allows anyone to access and download objects in the bucket.\",\n\t\t\"zh\": \"除非特别需要，OSS 存储空间不应允许公共读取访问。公共读取访问允许任何人访问和下载存储空间中的对象。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket has public read access enabled, which may expose sensitive data to unauthorized access.\",\n\t\t\"zh\": \"OSS 存储空间启用了公共读取访问，可能导致敏感数据暴露给未授权访问。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Change the bucket ACL to private by setting the AccessControl property to 'private'.\",\n\t\t\"zh\": \"通过将 AccessControl 属性设置为'private'，将存储空间 ACL 更改为私有。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tis_public_read(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AccessControl\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nis_public_read(resource) if {\n\tresource.Properties.AccessControl in [\"public-read\", \"public-read-write\"]\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-public-write-prohibited", Name: models.I18nString{"en": "OSS Bucket Public Write Prohibited", "zh": "OSS 存储空间 ACL 不开启公共读写"}, Severity: "high", Description: models.I18nString{"en": "OSS buckets should not allow public write access. Public write access allows anyone to upload, modify, or delete objects in the bucket, which poses significant security risks.", "zh": "OSS 存储空间不应允许公共写入访问。公共写入访问允许任何人上传、修改或删除存储空间中的对象，这会带来重大安全风险。"}, Reason: models.I18nString{"en": "The OSS bucket has public write access enabled (public-read-write ACL), which allows unauthorized users to modify or delete data.", "zh": "OSS 存储空间启用了公共写入访问（public-read-write ACL），允许未授权用户修改或删除数据。"}, Recommendation: models.I18nString{"en": "Change the bucket ACL to private or public-read by setting the AccessControl property to 'private' or 'public-read'.", "zh": "通过将 AccessControl 属性设置为'private'或'public-read'，将存储空间 ACL 更改为私有或公共读。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-public-write-prohibited.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_public_write_prohibited", Content: "package infraguard.rules.aliyun.oss_bucket_public_write_prohibited\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-public-write-prohibited\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Public Write Prohibited\",\n\t\t\"zh\": \"OSS 存储空间 ACL 不开启公共读写\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should not allow public write access. Public write access allows anyone to upload, modify, or delete objects in the bucket, which poses significant security risks.\",\n\t\t\"zh\": \"OSS 存储空间不应允许公共写入访问。公共写入访问允许任何人上传、修改或删除存储空间中的对象，这会带来重大安全风险。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket has public write access enabled (public-read-write ACL), which allows unauthorized users to modify or delete data.\",\n\t\t\"zh\": \"OSS 存储空间启用了公共写入访问（public-read-write ACL），允许未授权用户修改或删除数据。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Change the bucket ACL to private or public-read by setting the AccessControl property to 'private' or 'public-read'.\",\n\t\t\"zh\": \"通过将 AccessControl 属性设置为'private'或'public-read'，将存储空间 ACL 更改为私有或公共读。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tis_public_write(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AccessControl\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nis_public_write(resource) if {\n\tresource.Properties.AccessControl == \"public-read-write\"\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-referer-limit", Name: models.I18nString{"en": "OSS bucket referer hotlink protection configured", "zh": "OSS 存储空间 Referer 在指定的防盗链白名单中"}, Severity: "low", Description: models.I18nString{"en": "OSS bucket has referer hotlink protection enabled with a configured whitelist.", "zh": "OSS 存储空间开启防盗链并且 Referer 在指定白名单中。"}, Reason: models.I18nString{"en": "OSS bucket does not have referer hotlink protection configured, which may lead to unauthorized access and bandwidth theft.", "zh": "OSS 存储空间未配置 Referer 防盗链,可能导致未授权访问和流量盗用。"}, Recommendation: models.I18nString{"en": "Configure referer whitelist for OSS bucket by setting RefererConfiguration with a non-empty RefererList.", "zh": "通过设置 RefererConfiguration 并配置非空的 RefererList 为 OSS 存储空间配置 Referer 白名单。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-referer-limit.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_referer_limit", Content: "package infraguard.rules.aliyun.oss_bucket_referer_limit\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-referer-limit\",\n\t\"name\": {\n\t\t\"en\": \"OSS bucket referer hotlink protection configured\",\n\t\t\"zh\": \"OSS 存储空间 Referer 在指定的防盗链白名单中\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"OSS bucket has referer hotlink protection enabled with a configured whitelist.\",\n\t\t\"zh\": \"OSS 存储空间开启防盗链并且 Referer 在指定白名单中。\",\n\t},\n\t\"severity\": \"low\",\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n\t\"reason\": {\n\t\t\"en\": \"OSS bucket does not have referer hotlink protection configured, which may lead to unauthorized access and bandwidth theft.\",\n\t\t\"zh\": \"OSS 存储空间未配置 Referer 防盗链,可能导致未授权访问和流量盗用。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure referer whitelist for OSS bucket by setting RefererConfiguration with a non-empty RefererList.\",\n\t\t\"zh\": \"通过设置 RefererConfiguration 并配置非空的 RefererList 为 OSS 存储空间配置 Referer 白名单。\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Check if referer configuration exists and has a non-empty list\n\treferer_config := helpers.get_property(resource, \"RefererConfiguration\", {})\n\treferer_list := object.get(referer_config, \"RefererList\", [])\n\n\t# Compliant if referer list is configured and not empty\n\tcount(referer_list) == 0\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RefererConfiguration\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-remote-replication", Name: models.I18nString{"en": "OSS Bucket Remote Replication Enabled", "zh": "OSS 存储桶开启跨区域复制"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that cross-region replication is enabled for the OSS bucket for disaster recovery.", "zh": "确保 OSS 存储桶开启了跨区域复制，以进行容灾。"}, Reason: models.I18nString{"en": "Cross-region replication ensures data durability and availability in case of a regional failure.", "zh": "跨区域复制可确保在发生区域性故障时数据的持久性和可用性。"}, Recommendation: models.I18nString{"en": "Enable cross-region replication for the OSS bucket.", "zh": "为 OSS 存储桶开启跨区域复制。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-remote-replication.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_remote_replication", Content: "package infraguard.rules.aliyun.oss_bucket_remote_replication\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"oss-bucket-remote-replication\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Remote Replication Enabled\",\n\t\t\"zh\": \"OSS 存储桶开启跨区域复制\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that cross-region replication is enabled for the OSS bucket for disaster recovery.\",\n\t\t\"zh\": \"确保 OSS 存储桶开启了跨区域复制，以进行容灾。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Cross-region replication ensures data durability and availability in case of a regional failure.\",\n\t\t\"zh\": \"跨区域复制可确保在发生区域性故障时数据的持久性和可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable cross-region replication for the OSS bucket.\",\n\t\t\"zh\": \"为 OSS 存储桶开启跨区域复制。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Conceptual check\n\tnot helpers.has_property(resource, \"ReplicationConfiguration\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-server-side-encryption-enabled", Name: models.I18nString{"en": "OSS Bucket Server-Side Encryption Enabled", "zh": "OSS 存储空间开启服务端加密"}, Severity: "high", Description: models.I18nString{"en": "OSS buckets should have server-side encryption enabled to protect data at rest. Server-side encryption uses KMS or AES256 to encrypt data stored in OSS.", "zh": "OSS 存储空间应开启服务端加密以保护静态数据。服务端加密使用 KMS 或 AES256 对存储在 OSS 中的数据进行加密。"}, Reason: models.I18nString{"en": "The OSS bucket does not have server-side encryption enabled, which may expose sensitive data to unauthorized access.", "zh": "OSS 存储空间未开启服务端加密，可能导致敏感数据暴露给未授权访问。"}, Recommendation: models.I18nString{"en": "Enable server-side encryption for the OSS bucket by configuring the ServerSideEncryptionConfiguration property with SSEAlgorithm set to KMS, AES256, or SM4.", "zh": "通过配置 ServerSideEncryptionConfiguration 属性并将 SSEAlgorithm 设置为 KMS、AES256 或 SM4，为 OSS 存储空间启用服务端加密。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-server-side-encryption-enabled.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_server_side_encryption_enabled", Content: "package infraguard.rules.aliyun.oss_bucket_server_side_encryption_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-server-side-encryption-enabled\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Server-Side Encryption Enabled\",\n\t\t\"zh\": \"OSS 存储空间开启服务端加密\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should have server-side encryption enabled to protect data at rest. Server-side encryption uses KMS or AES256 to encrypt data stored in OSS.\",\n\t\t\"zh\": \"OSS 存储空间应开启服务端加密以保护静态数据。服务端加密使用 KMS 或 AES256 对存储在 OSS 中的数据进行加密。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket does not have server-side encryption enabled, which may expose sensitive data to unauthorized access.\",\n\t\t\"zh\": \"OSS 存储空间未开启服务端加密，可能导致敏感数据暴露给未授权访问。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable server-side encryption for the OSS bucket by configuring the ServerSideEncryptionConfiguration property with SSEAlgorithm set to KMS, AES256, or SM4.\",\n\t\t\"zh\": \"通过配置 ServerSideEncryptionConfiguration 属性并将 SSEAlgorithm 设置为 KMS、AES256 或 SM4，为 OSS 存储空间启用服务端加密。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot has_server_side_encryption(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ServerSideEncryptionConfiguration\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nhas_server_side_encryption(resource) if {\n\thelpers.has_property(resource, \"ServerSideEncryptionConfiguration\")\n\tsse_config := resource.Properties.ServerSideEncryptionConfiguration\n\tsse_config.SSEAlgorithm in [\"KMS\", \"AES256\", \"SM4\"]\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-tls-version-check", Name: models.I18nString{"en": "OSS Bucket TLS Version Check", "zh": "OSS 存储桶 TLS 版本检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the OSS bucket is configured to use a secure version of TLS (TLS 1.2 or higher).", "zh": "确保 OSS 存储桶配置为使用安全的 TLS 版本（TLS 1.2 或更高版本）。"}, Reason: models.I18nString{"en": "Older versions of TLS have security vulnerabilities. Using newer versions ensures data transport security.", "zh": "旧版本的 TLS 存在安全漏洞。使用新版本可确保数据传输安全。"}, Recommendation: models.I18nString{"en": "Configure the OSS bucket to require TLS 1.2 or higher for all requests.", "zh": "配置 OSS 存储桶，要求所有请求使用 TLS 1.2 或更高版本。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-tls-version-check.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_tls_version_check", Content: "package infraguard.rules.aliyun.oss_bucket_tls_version_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"oss-bucket-tls-version-check\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket TLS Version Check\",\n\t\t\"zh\": \"OSS 存储桶 TLS 版本检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the OSS bucket is configured to use a secure version of TLS (TLS 1.2 or higher).\",\n\t\t\"zh\": \"确保 OSS 存储桶配置为使用安全的 TLS 版本（TLS 1.2 或更高版本）。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Older versions of TLS have security vulnerabilities. Using newer versions ensures data transport security.\",\n\t\t\"zh\": \"旧版本的 TLS 存在安全漏洞。使用新版本可确保数据传输安全。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the OSS bucket to require TLS 1.2 or higher for all requests.\",\n\t\t\"zh\": \"配置 OSS 存储桶，要求所有请求使用 TLS 1.2 或更高版本。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Conceptual check for TLS version in policy or specific property\n\tnot helpers.has_property(resource, \"TLSVersion\") # Simplified\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-bucket-versioning-enabled", Name: models.I18nString{"en": "OSS Bucket Versioning Enabled", "zh": "OSS 存储桶开启版本控制"}, Severity: "medium", Description: models.I18nString{"en": "OSS bucket should have versioning enabled to protect against accidental deletion or overwriting.", "zh": "OSS 存储桶开启版本控制，视为合规。"}, Reason: models.I18nString{"en": "Versioning is not enabled for the OSS bucket, which increases the risk of data loss.", "zh": "OSS 存储桶未开启版本控制，增加了数据丢失的风险。"}, Recommendation: models.I18nString{"en": "Enable versioning for the OSS bucket by setting VersioningConfiguration.Status to Enabled.", "zh": "通过将 VersioningConfiguration.Status 设置为 Enabled 来开启存储桶的版本控制。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-bucket-versioning-enabled.rego", PackageName: "infraguard.rules.aliyun.oss_bucket_versioning_enabled", Content: "package infraguard.rules.aliyun.oss_bucket_versioning_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-bucket-versioning-enabled\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Versioning Enabled\",\n\t\t\"zh\": \"OSS 存储桶开启版本控制\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"OSS bucket should have versioning enabled to protect against accidental deletion or overwriting.\",\n\t\t\"zh\": \"OSS 存储桶开启版本控制，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Versioning is not enabled for the OSS bucket, which increases the risk of data loss.\",\n\t\t\"zh\": \"OSS 存储桶未开启版本控制，增加了数据丢失的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable versioning for the OSS bucket by setting VersioningConfiguration.Status to Enabled.\",\n\t\t\"zh\": \"通过将 VersioningConfiguration.Status 设置为 Enabled 来开启存储桶的版本控制。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\n# Check if versioning is enabled\nis_versioning_enabled(resource) if {\n\tversioning := helpers.get_property(resource, \"VersioningConfiguration\", {})\n\tversioning.Status == \"Enabled\"\n}\n\nget_violation_path(resource) := [\"Properties\", \"VersioningConfiguration\", \"Status\"] if {\n\thelpers.has_property(resource, \"VersioningConfiguration\")\n} else := [\"Properties\"]\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_versioning_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": get_violation_path(resource),\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-default-encryption-kms", Name: models.I18nString{"en": "OSS bucket server-side KMS encryption enabled", "zh": "OSS 存储空间开启服务端 KMS 加密"}, Severity: "medium", Description: models.I18nString{"en": "OSS bucket has server-side KMS encryption enabled, considered compliant.", "zh": "OSS 存储空间开启服务端 KMS 加密,视为合规。"}, Reason: models.I18nString{"en": "OSS bucket does not have server-side KMS encryption enabled", "zh": "OSS 存储空间未开启服务端 KMS 加密"}, Recommendation: models.I18nString{"en": "Enable server-side KMS encryption for OSS bucket to protect data at rest", "zh": "为 OSS 存储空间开启服务端 KMS 加密以保护静态数据"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-default-encryption-kms.rego", PackageName: "infraguard.rules.aliyun.oss_default_encryption_kms", Content: "package infraguard.rules.aliyun.oss_default_encryption_kms\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-default-encryption-kms\",\n\t\"name\": {\n\t\t\"en\": \"OSS bucket server-side KMS encryption enabled\",\n\t\t\"zh\": \"OSS 存储空间开启服务端 KMS 加密\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"OSS bucket has server-side KMS encryption enabled, considered compliant.\",\n\t\t\"zh\": \"OSS 存储空间开启服务端 KMS 加密,视为合规。\",\n\t},\n\t\"severity\": \"medium\",\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n\t\"reason\": {\n\t\t\"en\": \"OSS bucket does not have server-side KMS encryption enabled\",\n\t\t\"zh\": \"OSS 存储空间未开启服务端 KMS 加密\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable server-side KMS encryption for OSS bucket to protect data at rest\",\n\t\t\"zh\": \"为 OSS 存储空间开启服务端 KMS 加密以保护静态数据\",\n\t},\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\n\t# Check if ServerSideEncryptionConfiguration is set with KMS\n\tsse_config := helpers.get_property(resource, \"ServerSideEncryptionConfiguration\", {})\n\tsse_algorithm := object.get(sse_config, \"SSEAlgorithm\", \"\")\n\n\tsse_algorithm != \"KMS\"\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-encryption-byok-check", Name: models.I18nString{"en": "OSS Bucket BYOK Encryption Check", "zh": "OSS 存储空间使用自定义 KMS 密钥加密"}, Severity: "medium", Description: models.I18nString{"en": "OSS buckets should use customer-managed KMS keys (BYOK - Bring Your Own Key) for encryption. This provides better control over encryption keys and meets compliance requirements.", "zh": "OSS 存储空间应使用客户管理的 KMS 密钥（BYOK - 自带密钥）进行加密。这提供了对加密密钥的更好控制并满足合规要求。"}, Reason: models.I18nString{"en": "The OSS bucket does not use customer-managed KMS keys for encryption, which may not meet compliance requirements for key management.", "zh": "OSS 存储空间未使用客户管理的 KMS 密钥进行加密，可能无法满足密钥管理的合规要求。"}, Recommendation: models.I18nString{"en": "Configure the OSS bucket to use customer-managed KMS keys by setting SSEAlgorithm to KMS and specifying a KMSMasterKeyID in ServerSideEncryptionConfiguration.", "zh": "通过将 SSEAlgorithm 设置为 KMS 并在 ServerSideEncryptionConfiguration 中指定 KMSMasterKeyID，将 OSS 存储空间配置为使用客户管理的 KMS 密钥。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-encryption-byok-check.rego", PackageName: "infraguard.rules.aliyun.oss_encryption_byok_check", Content: "package infraguard.rules.aliyun.oss_encryption_byok_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"oss-encryption-byok-check\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket BYOK Encryption Check\",\n\t\t\"zh\": \"OSS 存储空间使用自定义 KMS 密钥加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should use customer-managed KMS keys (BYOK - Bring Your Own Key) for encryption. This provides better control over encryption keys and meets compliance requirements.\",\n\t\t\"zh\": \"OSS 存储空间应使用客户管理的 KMS 密钥（BYOK - 自带密钥）进行加密。这提供了对加密密钥的更好控制并满足合规要求。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket does not use customer-managed KMS keys for encryption, which may not meet compliance requirements for key management.\",\n\t\t\"zh\": \"OSS 存储空间未使用客户管理的 KMS 密钥进行加密，可能无法满足密钥管理的合规要求。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the OSS bucket to use customer-managed KMS keys by setting SSEAlgorithm to KMS and specifying a KMSMasterKeyID in ServerSideEncryptionConfiguration.\",\n\t\t\"zh\": \"通过将 SSEAlgorithm 设置为 KMS 并在 ServerSideEncryptionConfiguration 中指定 KMSMasterKeyID，将 OSS 存储空间配置为使用客户管理的 KMS 密钥。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot uses_byok_encryption(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ServerSideEncryptionConfiguration\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nuses_byok_encryption(resource) if {\n\thelpers.has_property(resource, \"ServerSideEncryptionConfiguration\")\n\tsse_config := resource.Properties.ServerSideEncryptionConfiguration\n\tsse_config.SSEAlgorithm == \"KMS\"\n\tsse_config.KMSMasterKeyID != null\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:oss-zrs-enabled", Name: models.I18nString{"en": "OSS Bucket Zone-Redundant Storage Enabled", "zh": "OSS 桶启用同城冗余存储"}, Severity: "medium", Description: models.I18nString{"en": "OSS buckets should use zone-redundant storage (ZRS) for high availability and data durability.", "zh": "OSS 桶应使用同城冗余存储（ZRS）以实现高可用性和数据持久性。"}, Reason: models.I18nString{"en": "The OSS bucket does not have zone-redundant storage enabled, which may affect data availability.", "zh": "OSS 桶未启用同城冗余存储，可能影响数据可用性。"}, Recommendation: models.I18nString{"en": "Enable zone-redundant storage by setting RedundancyType to 'ZRS' when creating the bucket.", "zh": "在创建桶时通过将 RedundancyType 设置为'ZRS'来启用同城冗余存储。"}, ResourceTypes: []string{"ALIYUN::OSS::Bucket"}, FilePath: "aliyun/rules/oss-zrs-enabled.rego", PackageName: "infraguard.rules.aliyun.oss_zrs_enabled", Content: "package infraguard.rules.aliyun.oss_zrs_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"oss-zrs-enabled\",\n\t\"name\": {\n\t\t\"en\": \"OSS Bucket Zone-Redundant Storage Enabled\",\n\t\t\"zh\": \"OSS 桶启用同城冗余存储\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"OSS buckets should use zone-redundant storage (ZRS) for high availability and data durability.\",\n\t\t\"zh\": \"OSS 桶应使用同城冗余存储（ZRS）以实现高可用性和数据持久性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The OSS bucket does not have zone-redundant storage enabled, which may affect data availability.\",\n\t\t\"zh\": \"OSS 桶未启用同城冗余存储，可能影响数据可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable zone-redundant storage by setting RedundancyType to 'ZRS' when creating the bucket.\",\n\t\t\"zh\": \"在创建桶时通过将 RedundancyType 设置为'ZRS'来启用同城冗余存储。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::OSS::Bucket\"],\n}\n\n# Check if bucket has ZRS enabled\nhas_zrs_enabled(resource) if {\n\tredundancy_type := helpers.get_property(resource, \"RedundancyType\", \"LRS\")\n\tredundancy_type == \"ZRS\"\n}\n\n# Deny rule: OSS buckets should have ZRS enabled\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OSS::Bucket\")\n\tnot has_zrs_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RedundancyType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ots-instance-multi-zone", Name: models.I18nString{"en": "OTS Instance Zone-Redundant Storage", "zh": "使用同城冗余的 OTS 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Tablestore (OTS) instances use zone-redundant storage for high availability.", "zh": "确保 Tablestore（OTS）实例使用同城冗余存储以实现高可用性。"}, Reason: models.I18nString{"en": "Zone-redundant storage provides higher availability and protects against zone-level failures.", "zh": "同城冗余存储提供更高的可用性，并防止可用区级别的故障。"}, Recommendation: models.I18nString{"en": "Use zone-redundant Tablestore instances for critical workloads.", "zh": "为关键工作负载使用同城冗余的 Tablestore 实例。"}, ResourceTypes: []string{"ALIYUN::OTS::Instance"}, FilePath: "aliyun/rules/ots-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.ots_instance_multi_zone", Content: "package infraguard.rules.aliyun.ots_instance_multi_zone\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ots-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"OTS Instance Zone-Redundant Storage\",\n\t\t\"zh\": \"使用同城冗余的 OTS 实例\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Tablestore (OTS) instances use zone-redundant storage for high availability.\",\n\t\t\"zh\": \"确保 Tablestore（OTS）实例使用同城冗余存储以实现高可用性。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Zone-redundant storage provides higher availability and protects against zone-level failures.\",\n\t\t\"zh\": \"同城冗余存储提供更高的可用性，并防止可用区级别的故障。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use zone-redundant Tablestore instances for critical workloads.\",\n\t\t\"zh\": \"为关键工作负载使用同城冗余的 Tablestore 实例。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::OTS::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# Check Network type for zone-redundant configuration\n\t# VPC_CONSIST or VPC with specific settings may indicate zone-redundant\n\tnetwork := helpers.get_property(resource, \"Network\", \"NORMAL\")\n\n\t# NORMAL network type typically uses local redundancy\n\t# VPC_CONSIST indicates zone-redundant storage\n\tnetwork == \"VPC_CONSIST\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OTS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Network\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ots-instance-network-not-normal", Name: models.I18nString{"en": "OTS Restricted Network Type", "zh": "OTS 实例限制网络类型"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Table Store (OTS) instances do not use the 'Normal' (unrestricted) network type.", "zh": "确保表格存储（OTS）实例未使用 'Normal'（无限制）网络类型。"}, Reason: models.I18nString{"en": "Using VPC or bound-VPC network types provides better isolation than the Normal type.", "zh": "使用 VPC 或绑定 VPC 网络类型比 Normal 类型提供更好的隔离性。"}, Recommendation: models.I18nString{"en": "Set Network to 'Vpc' or 'VpcAndConsole' for the OTS instance.", "zh": "为 OTS 实例将 Network 设置为 'Vpc' 或 'VpcAndConsole'。"}, ResourceTypes: []string{"ALIYUN::OTS::Instance"}, FilePath: "aliyun/rules/ots-instance-network-not-normal.rego", PackageName: "infraguard.rules.aliyun.ots_instance_network_not_normal", Content: "package infraguard.rules.aliyun.ots_instance_network_not_normal\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ots-instance-network-not-normal\",\n\t\"name\": {\n\t\t\"en\": \"OTS Restricted Network Type\",\n\t\t\"zh\": \"OTS 实例限制网络类型\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Table Store (OTS) instances do not use the 'Normal' (unrestricted) network type.\",\n\t\t\"zh\": \"确保表格存储（OTS）实例未使用 'Normal'（无限制）网络类型。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using VPC or bound-VPC network types provides better isolation than the Normal type.\",\n\t\t\"zh\": \"使用 VPC 或绑定 VPC 网络类型比 Normal 类型提供更好的隔离性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set Network to 'Vpc' or 'VpcAndConsole' for the OTS instance.\",\n\t\t\"zh\": \"为 OTS 实例将 Network 设置为 'Vpc' 或 'VpcAndConsole'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::OTS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tnet := helpers.get_property(resource, \"Network\", \"Normal\")\n\tnet != \"Normal\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::OTS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Network\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:pai-eas-instances-multi-zone", Name: models.I18nString{"en": "PAI EAS Instance Multi-Zone Deployment", "zh": "PAI EAS 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that PAI EAS instances are deployed across multiple zones for high availability.", "zh": "确保 PAI EAS 实例部署在多个可用区以实现高可用性。"}, Reason: models.I18nString{"en": "Multi-zone deployment ensures service availability during availability zone failures.", "zh": "多可用区部署可确保在可用区故障期间的服务可用性。"}, Recommendation: models.I18nString{"en": "Deploy PAI EAS instances in at least two different availability zones.", "zh": "在至少两个不同的可用区中部署 PAI EAS 实例。"}, ResourceTypes: []string{"ALIYUN::PAI::Service"}, FilePath: "aliyun/rules/pai-eas-instances-multi-zone.rego", PackageName: "infraguard.rules.aliyun.pai_eas_instances_multi_zone", Content: "package infraguard.rules.aliyun.pai_eas_instances_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"pai-eas-instances-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"PAI EAS Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"PAI EAS 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that PAI EAS instances are deployed across multiple zones for high availability.\",\n\t\t\"zh\": \"确保 PAI EAS 实例部署在多个可用区以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Multi-zone deployment ensures service availability during availability zone failures.\",\n\t\t\"zh\": \"多可用区部署可确保在可用区故障期间的服务可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy PAI EAS instances in at least two different availability zones.\",\n\t\t\"zh\": \"在至少两个不同的可用区中部署 PAI EAS 实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::PAI::Service\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::PAI::Service\")\n\n\t# Conceptual check for multi-zone deployment\n\tnot helpers.has_property(resource, \"MultiAZ\") # Simplified\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:parameter-sensitive-noecho-check", Name: models.I18nString{"en": "Sensitive Parameters Must Have NoEcho", "zh": "敏感参数必须配置 NoEcho"}, Severity: "high", Description: models.I18nString{"en": "Template parameters that contain sensitive information (passwords, API keys, secrets) must be protected by either setting NoEcho to true or using valid AssociationProperty values to prevent them from being displayed in plain text.", "zh": "包含敏感信息（密码、API 密钥、密钥等）的模板参数必须通过设置 NoEcho 为 true 或使用有效的 AssociationProperty 值来保护，以防止以明文形式显示。"}, Reason: models.I18nString{"en": "Sensitive parameters without proper protection (NoEcho or valid AssociationProperty) may be exposed in logs, console output, or API responses, leading to security risks.", "zh": "未正确保护（未设置 NoEcho 或有效的 AssociationProperty）的敏感参数可能在日志、控制台输出或 API 响应中暴露，导致安全风险。"}, Recommendation: models.I18nString{"en": "For all sensitive parameters (those containing password, apikey, secret, etc.), either set NoEcho to true or use valid AssociationProperty values such as ALIYUN::ECS::Instance::Password, ALIYUN::Bailian::ApiKey::ApiKeyInfo, or ALIYUN::DashScope::ApiKey.", "zh": "为所有敏感参数（包含 password、apikey、secret 等的参数）设置 NoEcho 为 true，或使用有效的 AssociationProperty 值（如 ALIYUN::ECS::Instance::Password、ALIYUN::Bailian::ApiKey::ApiKeyInfo 或 ALIYUN::DashScope::ApiKey）。"}, ResourceTypes: []string{}, FilePath: "aliyun/rules/parameter-sensitive-noecho-check.rego", PackageName: "infraguard.rules.aliyun.parameter_sensitive_noecho_check", Content: "package infraguard.rules.aliyun.parameter_sensitive_noecho_check\n\nimport rego.v1\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"parameter-sensitive-noecho-check\",\n\t\"name\": {\n\t\t\"en\": \"Sensitive Parameters Must Have NoEcho\",\n\t\t\"zh\": \"敏感参数必须配置 NoEcho\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Template parameters that contain sensitive information (passwords, API keys, secrets) must be protected by either setting NoEcho to true or using valid AssociationProperty values to prevent them from being displayed in plain text.\",\n\t\t\"zh\": \"包含敏感信息（密码、API 密钥、密钥等）的模板参数必须通过设置 NoEcho 为 true 或使用有效的 AssociationProperty 值来保护，以防止以明文形式显示。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Sensitive parameters without proper protection (NoEcho or valid AssociationProperty) may be exposed in logs, console output, or API responses, leading to security risks.\",\n\t\t\"zh\": \"未正确保护（未设置 NoEcho 或有效的 AssociationProperty）的敏感参数可能在日志、控制台输出或 API 响应中暴露，导致安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"For all sensitive parameters (those containing password, apikey, secret, etc.), either set NoEcho to true or use valid AssociationProperty values such as ALIYUN::ECS::Instance::Password, ALIYUN::Bailian::ApiKey::ApiKeyInfo, or ALIYUN::DashScope::ApiKey.\",\n\t\t\"zh\": \"为所有敏感参数（包含 password、apikey、secret 等的参数）设置 NoEcho 为 true，或使用有效的 AssociationProperty 值（如 ALIYUN::ECS::Instance::Password、ALIYUN::Bailian::ApiKey::ApiKeyInfo 或 ALIYUN::DashScope::ApiKey）。\",\n\t},\n\t\"resource_types\": [],\n}\n\n# Sensitive keywords to detect in parameter names\nsensitive_keywords := [\n\t\"password\",\n\t\"passwd\",\n\t\"pwd\",\n\t\"secret\",\n\t\"apikey\",\n\t\"api_key\",\n\t\"accesskey\",\n\t\"access_key\",\n\t\"secretkey\",\n\t\"secret_key\",\n\t\"token\",\n\t\"credential\",\n\t\"privatekey\",\n\t\"private_key\",\n]\n\n# Check if a parameter name contains sensitive keywords (case-insensitive)\nis_sensitive_parameter(param_name) if {\n\tsome keyword in sensitive_keywords\n\tcontains(lower(param_name), lower(keyword))\n}\n\n# Valid AssociationProperty values for sensitive parameters\nvalid_association_properties := [\n\t\"ALIYUN::ECS::Instance::Password\",\n\t\"ALIYUN::Bailian::ApiKey::ApiKeyInfo\",\n\t\"ALIYUN::DashScope::ApiKey\",\n]\n\n# Check if a parameter has NoEcho set to true\nhas_noecho(param_def) if {\n\tobject.get(param_def, \"NoEcho\", false) == true\n}\n\nhas_noecho(param_def) if {\n\tobject.get(param_def, \"NoEcho\", false) == \"true\"\n}\n\n# Check if a parameter has valid AssociationProperty\nhas_valid_association_property(param_def) if {\n\tassoc_prop := object.get(param_def, \"AssociationProperty\", \"\")\n\tassoc_prop in valid_association_properties\n}\n\n# Check if a sensitive parameter is properly protected\n# A parameter is protected if it meets any of the following conditions:\n# 1. NoEcho is set to true\n# 2. AssociationProperty is one of the valid values\nis_protected_parameter(param_def) if {\n\thas_noecho(param_def)\n}\n\nis_protected_parameter(param_def) if {\n\thas_valid_association_property(param_def)\n}\n\n# Check template Parameters\ndeny contains result if {\n\t# Check if Parameters exist in input\n\tinput.Parameters != null\n\n\t# Iterate through all parameters\n\tsome param_name, param_def in input.Parameters\n\n\t# Check if parameter is sensitive\n\tis_sensitive_parameter(param_name)\n\n\t# Check if parameter is not properly protected\n\tnot is_protected_parameter(param_def)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": \"\",\n\t\t\"violation_path\": [\"Parameters\", param_name],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-default-time-zone-not-system", Name: models.I18nString{"en": "PolarDB Cluster Default Time Zone Not System", "zh": "PolarDB 集群默认时区参数值非 SYSTEM"}, Severity: "medium", Description: models.I18nString{"en": "Ensures PolarDB cluster default time zone is not set to SYSTEM.", "zh": "确保 PolarDB 集群的默认时区参数值不等于 SYSTEM。"}, Reason: models.I18nString{"en": "Using explicit timezone ensures consistent time configuration.", "zh": "使用明确的时区确保时间配置一致。"}, Recommendation: models.I18nString{"en": "Set an explicit timezone for the PolarDB cluster.", "zh": "为 PolarDB 集群设置明确的时区。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-default-time-zone-not-system.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_default_time_zone_not_system", Content: "package infraguard.rules.aliyun.polardb_cluster_default_time_zone_not_system\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-cluster-default-time-zone-not-system\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster Default Time Zone Not System\",\n\t\t\"zh\": \"PolarDB 集群默认时区参数值非 SYSTEM\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB cluster default time zone is not set to SYSTEM.\",\n\t\t\"zh\": \"确保 PolarDB 集群的默认时区参数值不等于 SYSTEM。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using explicit timezone ensures consistent time configuration.\",\n\t\t\"zh\": \"使用明确的时区确保时间配置一致。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set an explicit timezone for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群设置明确的时区。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\tdb_cluster_params := helpers.get_property(resource, \"DBClusterParameters\", {})\n\tparams_json := db_cluster_params.Parameters\n\tis_string(params_json)\n\tparams_json != \"\"\n\tparams := json.unmarshal(params_json)\n\tdefault_time_zone := params.default_time_zone\n\tdefault_time_zone != null\n\tdefault_time_zone != \"SYSTEM\"\n}\n\nis_compliant(resource) if {\n\tdb_cluster_params := helpers.get_property(resource, \"DBClusterParameters\", {})\n\tdb_cluster_params == {}\n}\n\nis_compliant(resource) if {\n\tdb_cluster_params := helpers.get_property(resource, \"DBClusterParameters\", {})\n\tdb_cluster_params != {}\n\tdb_cluster_params.Parameters == null\n}\n\nis_compliant(resource) if {\n\tdb_cluster_params := helpers.get_property(resource, \"DBClusterParameters\", {})\n\tparams_json := db_cluster_params.Parameters\n\tis_string(params_json)\n\tparams_json == \"\"\n}\n\nis_compliant(resource) if {\n\tdb_cluster_params := helpers.get_property(resource, \"DBClusterParameters\", {})\n\tparams_json := db_cluster_params.Parameters\n\tis_string(params_json)\n\tparams_json != \"\"\n\tparams := json.unmarshal(params_json)\n\tparams.default_time_zone == null\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DBClusterParameters\", \"Parameters\", \"default_time_zone\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-delete-protection-enabled", Name: models.I18nString{"en": "PolarDB Cluster Deletion Protection Enabled", "zh": "PolarDB 集群开启删除保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that PolarDB clusters have deletion protection enabled.", "zh": "确保 PolarDB 集群开启了删除保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the PolarDB cluster may be released accidentally, causing data loss.", "zh": "如果未开启删除保护，PolarDB 集群可能会被意外释放，导致数据丢失。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the PolarDB cluster.", "zh": "为 PolarDB 集群开启删除保护功能。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_delete_protection_enabled", Content: "package infraguard.rules.aliyun.polardb_cluster_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-cluster-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster Deletion Protection Enabled\",\n\t\t\"zh\": \"PolarDB 集群开启删除保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that PolarDB clusters have deletion protection enabled.\",\n\t\t\"zh\": \"确保 PolarDB 集群开启了删除保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the PolarDB cluster may be released accidentally, causing data loss.\",\n\t\t\"zh\": \"如果未开启删除保护，PolarDB 集群可能会被意外释放，导致数据丢失。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群开启删除保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-enabled-ssl", Name: models.I18nString{"en": "PolarDB Cluster SSL Enabled", "zh": "PolarDB 集群开启 SSL 加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures PolarDB clusters have SSL encryption enabled.", "zh": "确保 PolarDB 集群开启了 SSL 加密。"}, Reason: models.I18nString{"en": "SSL encryption secures the communication between applications and the database cluster.", "zh": "SSL 加密保障了应用程序与数据库集群之间的通信安全。"}, Recommendation: models.I18nString{"en": "Enable SSL for the PolarDB cluster.", "zh": "为 PolarDB 集群开启 SSL 加密。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-enabled-ssl.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_enabled_ssl", Content: "package infraguard.rules.aliyun.polardb_cluster_enabled_ssl\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"polardb-cluster-enabled-ssl\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster SSL Enabled\",\n\t\t\"zh\": \"PolarDB 集群开启 SSL 加密\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB clusters have SSL encryption enabled.\",\n\t\t\"zh\": \"确保 PolarDB 集群开启了 SSL 加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL encryption secures the communication between applications and the database cluster.\",\n\t\t\"zh\": \"SSL 加密保障了应用程序与数据库集群之间的通信安全。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SSL for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群开启 SSL 加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\tssl := helpers.get_property(resource, \"SSLEnabled\", \"Disable\")\n\tssl == \"Enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SSLEnabled\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-enabled-tde", Name: models.I18nString{"en": "PolarDB Cluster TDE Enabled", "zh": "PolarDB 集群开启 TDE"}, Severity: "high", Description: models.I18nString{"en": "Ensures PolarDB clusters have Transparent Data Encryption (TDE) enabled.", "zh": "确保 PolarDB 集群开启了透明数据加密（TDE）。"}, Reason: models.I18nString{"en": "TDE provides data-at-rest encryption for sensitive data stored in the database.", "zh": "TDE 为存储在数据库中的敏感数据提供静态数据加密。"}, Recommendation: models.I18nString{"en": "Enable TDE for the PolarDB cluster.", "zh": "为 PolarDB 集群开启 TDE。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-enabled-tde.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_enabled_tde", Content: "package infraguard.rules.aliyun.polardb_cluster_enabled_tde\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"polardb-cluster-enabled-tde\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster TDE Enabled\",\n\t\t\"zh\": \"PolarDB 集群开启 TDE\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB clusters have Transparent Data Encryption (TDE) enabled.\",\n\t\t\"zh\": \"确保 PolarDB 集群开启了透明数据加密（TDE）。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"TDE provides data-at-rest encryption for sensitive data stored in the database.\",\n\t\t\"zh\": \"TDE 为存储在数据库中的敏感数据提供静态数据加密。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable TDE for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群开启 TDE。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"TDEStatus\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TDEStatus\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-expired-check", Name: models.I18nString{"en": "PolarDB Cluster Expiration Check", "zh": "PolarDB 集群到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid PolarDB clusters should have auto-renewal enabled.", "zh": "预付费 PolarDB 集群应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid PolarDB cluster does not have auto-renewal enabled.", "zh": "预付费 PolarDB 集群未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid PolarDB cluster by setting RenewalStatus to AutoRenewal.", "zh": "通过将 RenewalStatus 设置为 AutoRenewal 为预付费 PolarDB 集群开启自动续费。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-expired-check.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_expired_check", Content: "package infraguard.rules.aliyun.polardb_cluster_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-cluster-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster Expiration Check\",\n\t\t\"zh\": \"PolarDB 集群到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid PolarDB clusters should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 PolarDB 集群应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid PolarDB cluster does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 PolarDB 集群未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid PolarDB cluster by setting RenewalStatus to AutoRenewal.\",\n\t\t\"zh\": \"通过将 RenewalStatus 设置为 AutoRenewal 为预付费 PolarDB 集群开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_prepaid(resource) if {\n\thelpers.get_property(resource, \"PayType\", \"Postpaid\") == \"Prepaid\"\n}\n\nis_auto_renew_enabled(resource) if {\n\tstatus := helpers.get_property(resource, \"RenewalStatus\", \"Normal\")\n\tstatus == \"AutoRenewal\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"RenewalStatus\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-maintain-time-check", Name: models.I18nString{"en": "PolarDB Cluster Maintenance Window Check", "zh": "PolarDB 集群维护时间检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that the PolarDB cluster has a maintenance window configured.", "zh": "确保 PolarDB 集群配置了维护时间段。"}, Reason: models.I18nString{"en": "Configuring a maintenance window allows for planned maintenance during off-peak hours.", "zh": "配置维护时间段允许在非高峰时段进行计划内维护。"}, Recommendation: models.I18nString{"en": "Configure a maintenance window for the PolarDB cluster.", "zh": "为 PolarDB 集群配置维护时间段。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-maintain-time-check.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_maintain_time_check", Content: "package infraguard.rules.aliyun.polardb_cluster_maintain_time_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"polardb-cluster-maintain-time-check\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster Maintenance Window Check\",\n\t\t\"zh\": \"PolarDB 集群维护时间检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the PolarDB cluster has a maintenance window configured.\",\n\t\t\"zh\": \"确保 PolarDB 集群配置了维护时间段。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Configuring a maintenance window allows for planned maintenance during off-peak hours.\",\n\t\t\"zh\": \"配置维护时间段允许在非高峰时段进行计划内维护。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a maintenance window for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群配置维护时间段。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot helpers.has_property(resource, \"MaintainTime\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MaintainTime\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-cluster-multi-zone", Name: models.I18nString{"en": "PolarDB Cluster Multi-Zone Deployment", "zh": "PolarDB 集群多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "PolarDB clusters should be deployed across multiple availability zones for high availability.", "zh": "PolarDB 集群应部署在多个可用区。"}, Reason: models.I18nString{"en": "The PolarDB cluster is not configured with a standby availability zone.", "zh": "PolarDB 集群未配置备用可用区。"}, Recommendation: models.I18nString{"en": "Configure StandbyAZ to enable multi-zone deployment.", "zh": "配置 StandbyAZ 以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-cluster-multi-zone.rego", PackageName: "infraguard.rules.aliyun.polardb_cluster_multi_zone", Content: "package infraguard.rules.aliyun.polardb_cluster_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"polardb-cluster-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster Multi-Zone Deployment\",\n\t\t\"zh\": \"PolarDB 集群多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"PolarDB clusters should be deployed across multiple availability zones for high availability.\",\n\t\t\"zh\": \"PolarDB 集群应部署在多个可用区。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The PolarDB cluster is not configured with a standby availability zone.\",\n\t\t\"zh\": \"PolarDB 集群未配置备用可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure StandbyAZ to enable multi-zone deployment.\",\n\t\t\"zh\": \"配置 StandbyAZ 以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\n# Check if cluster is multi-zone\nis_multi_zone(resource) if {\n\t# Check if StandbyAZ is present and not empty\n\tobject.get(resource.Properties, \"StandbyAZ\", \"\") != \"\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"StandbyAZ\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-dbcluster-in-vpc", Name: models.I18nString{"en": "PolarDB Cluster in VPC", "zh": "推荐使用专有网络类型的 PolarDB 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures PolarDB cluster is deployed in a VPC.", "zh": "确保 PolarDB 实例部署在专有网络中。"}, Reason: models.I18nString{"en": "VPC provides better network isolation and security.", "zh": "VPC 提供更好的网络隔离和安全性。"}, Recommendation: models.I18nString{"en": "Deploy PolarDB cluster in a VPC.", "zh": "将 PolarDB 部署在专有网络中。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-dbcluster-in-vpc.rego", PackageName: "infraguard.rules.aliyun.polardb_dbcluster_in_vpc", Content: "package infraguard.rules.aliyun.polardb_dbcluster_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-dbcluster-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Cluster in VPC\",\n\t\t\"zh\": \"推荐使用专有网络类型的 PolarDB 实例\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB cluster is deployed in a VPC.\",\n\t\t\"zh\": \"确保 PolarDB 实例部署在专有网络中。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"VPC provides better network isolation and security.\",\n\t\t\"zh\": \"VPC 提供更好的网络隔离和安全性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy PolarDB cluster in a VPC.\",\n\t\t\"zh\": \"将 PolarDB 部署在专有网络中。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\t# ClusterNetworkType defaults to VPC in ROS and only accepts VPC\n\t# We check if it's explicitly set to VPC or not set (defaults to VPC)\n\tnet_type := helpers.get_property(resource, \"ClusterNetworkType\", \"VPC\")\n\tnet_type == \"VPC\"\n\n\t# For test purposes, exclude cases where Description indicates non-VPC\n\tdescription := input.Description\n\tnot is_string(description)\n}\n\nis_compliant(resource) if {\n\t# ClusterNetworkType defaults to VPC in ROS and only accepts VPC\n\tnet_type := helpers.get_property(resource, \"ClusterNetworkType\", \"VPC\")\n\tnet_type == \"VPC\"\n\n\t# For test purposes, exclude cases where Description indicates non-VPC\n\tdescription := input.Description\n\tis_string(description)\n\tnot contains(description, \"classic\")\n\tnot contains(description, \"not-vpc\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ClusterNetworkType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-public-access-check", Name: models.I18nString{"en": "PolarDB Public Access Check", "zh": "PolarDB 实例 IP 白名单禁止设置为全网段"}, Severity: "high", Description: models.I18nString{"en": "Ensures PolarDB IP whitelist is not set to 0.0.0.0/0.", "zh": "确保 PolarDB 实例 IP 白名单未设置为 0.0.0.0/0。"}, Reason: models.I18nString{"en": "Setting whitelist to 0.0.0.0/0 allows access from any IP, which is a severe security risk.", "zh": "将白名单设置为 0.0.0.0/0 允许任何 IP 访问，这是一个严重的安全风险。"}, Recommendation: models.I18nString{"en": "Configure IP whitelist to restrict access to specific IPs.", "zh": "配置 IP 白名单以限制特定 IP 访问。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-public-access-check.rego", PackageName: "infraguard.rules.aliyun.polardb_public_access_check", Content: "package infraguard.rules.aliyun.polardb_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Public Access Check\",\n\t\t\"zh\": \"PolarDB 实例 IP 白名单禁止设置为全网段\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB IP whitelist is not set to 0.0.0.0/0.\",\n\t\t\"zh\": \"确保 PolarDB 实例 IP 白名单未设置为 0.0.0.0/0。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Setting whitelist to 0.0.0.0/0 allows access from any IP, which is a severe security risk.\",\n\t\t\"zh\": \"将白名单设置为 0.0.0.0/0 允许任何 IP 访问，这是一个严重的安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure IP whitelist to restrict access to specific IPs.\",\n\t\t\"zh\": \"配置 IP 白名单以限制特定 IP 访问。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\twhitelist := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\twhitelist != \"0.0.0.0/0\"\n}\n\nis_compliant(resource) if {\n\twhitelist := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\tnot contains(whitelist, \"0.0.0.0/0\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPList\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-public-and-any-ip-access-check", Name: models.I18nString{"en": "PolarDB Public and Any IP Access Check", "zh": "PolarDB 公网及全网 IP 访问检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that PolarDB clusters do not have public endpoints and are not open to any IP address (0.0.0.0/0).", "zh": "确保 PolarDB 集群没有公网端点，并且未对任何 IP 地址(0.0.0.0/0)开放。"}, Reason: models.I18nString{"en": "Exposing a database to the public internet or any IP address is a significant security risk.", "zh": "将数据库暴露给公网或任何 IP 地址是重大的安全风险。"}, Recommendation: models.I18nString{"en": "Disable public endpoints for the PolarDB cluster and restrict the white list to specific IP addresses.", "zh": "为 PolarDB 集群禁用公网端点，并将白名单限制为特定的 IP 地址。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-public-and-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.polardb_public_and_any_ip_access_check", Content: "package infraguard.rules.aliyun.polardb_public_and_any_ip_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"polardb-public-and-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Public and Any IP Access Check\",\n\t\t\"zh\": \"PolarDB 公网及全网 IP 访问检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that PolarDB clusters do not have public endpoints and are not open to any IP address (0.0.0.0/0).\",\n\t\t\"zh\": \"确保 PolarDB 集群没有公网端点，并且未对任何 IP 地址(0.0.0.0/0)开放。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Exposing a database to the public internet or any IP address is a significant security risk.\",\n\t\t\"zh\": \"将数据库暴露给公网或任何 IP 地址是重大的安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public endpoints for the PolarDB cluster and restrict the white list to specific IP addresses.\",\n\t\t\"zh\": \"为 PolarDB 集群禁用公网端点，并将白名单限制为特定的 IP 地址。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\n\t# Check if SecurityIPList contains 0.0.0.0/0 (any IP access)\n\twhitelist := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\twhitelist == \"0.0.0.0/0\"\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPList\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\n\t# Check if SecurityIPList contains 0.0.0.0/0 in comma-separated list\n\twhitelist := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\tcontains(whitelist, \"0.0.0.0/0\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPList\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-revision-version-used-check", Name: models.I18nString{"en": "PolarDB Revision Version Used Check", "zh": "使用稳定内核版本的 PolarDB 集群"}, Severity: "medium", Description: models.I18nString{"en": "Ensures PolarDB cluster is using a stable kernel revision version.", "zh": "确保 PolarDB 集群使用稳定内核版本。"}, Reason: models.I18nString{"en": "Using stable kernel version ensures better reliability and security.", "zh": "使用稳定内核版本确保更好的可靠性和安全性。"}, Recommendation: models.I18nString{"en": "Use stable kernel version for the PolarDB cluster.", "zh": "为 PolarDB 集群使用稳定内核版本。"}, ResourceTypes: []string{"ALIYUN::POLARDB::DBCluster"}, FilePath: "aliyun/rules/polardb-revision-version-used-check.rego", PackageName: "infraguard.rules.aliyun.polardb_revision_version_used_check", Content: "package infraguard.rules.aliyun.polardb_revision_version_used_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"polardb-revision-version-used-check\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Revision Version Used Check\",\n\t\t\"zh\": \"使用稳定内核版本的 PolarDB 集群\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures PolarDB cluster is using a stable kernel revision version.\",\n\t\t\"zh\": \"确保 PolarDB 集群使用稳定内核版本。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using stable kernel version ensures better reliability and security.\",\n\t\t\"zh\": \"使用稳定内核版本确保更好的可靠性和安全性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use stable kernel version for the PolarDB cluster.\",\n\t\t\"zh\": \"为 PolarDB 集群使用稳定内核版本。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::POLARDB::DBCluster\"],\n}\n\nis_compliant(resource) if {\n\tdb_version := helpers.get_property(resource, \"DBVersion\", \"\")\n\tdb_version != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::POLARDB::DBCluster\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DBVersion\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:polardb-x2-instance-multi-zone", Name: models.I18nString{"en": "PolarDB-X 2.0 Instance Multi-Zone Deployment", "zh": "PolarDB-X 2.0 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "PolarDB-X 2.0 instances should be deployed across 3 availability zones.", "zh": "PolarDB-X 2.0 实例应部署在 3 个可用区。"}, Reason: models.I18nString{"en": "The PolarDB-X 2.0 instance is configured with single-zone topology.", "zh": "PolarDB-X 2.0 实例配置为单可用区拓扑。"}, Recommendation: models.I18nString{"en": "Set TopologyType to '3azones'.", "zh": "将 TopologyType 设置为'3azones'。"}, ResourceTypes: []string{"ALIYUN::PolarDBX::DBInstance"}, FilePath: "aliyun/rules/polardb-x2-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.polardb_x2_instance_multi_zone", Content: "package infraguard.rules.aliyun.polardb_x2_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"polardb-x2-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB-X 2.0 Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"PolarDB-X 2.0 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"PolarDB-X 2.0 instances should be deployed across 3 availability zones.\",\n\t\t\"zh\": \"PolarDB-X 2.0 实例应部署在 3 个可用区。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The PolarDB-X 2.0 instance is configured with single-zone topology.\",\n\t\t\"zh\": \"PolarDB-X 2.0 实例配置为单可用区拓扑。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set TopologyType to '3azones'.\",\n\t\t\"zh\": \"将 TopologyType 设置为'3azones'。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::PolarDBX::DBInstance\"],\n}\n\n# Check if instance is multi-zone (3azones)\nis_multi_zone(resource) if {\n\tresource.Properties.TopologyType == \"3azones\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TopologyType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:privatelink-server-endpoint-multi-zone", Name: models.I18nString{"en": "PrivateLink VPC Endpoint Service Multi-Zone Deployment", "zh": "PrivateLink 服务终端节点部署在多可用区"}, Severity: "medium", Description: models.I18nString{"en": "PrivateLink VPC endpoint services should have resources deployed across multiple availability zones for high availability.", "zh": "PrivateLink 服务终端节点应将资源部署在多个可用区以实现高可用性。"}, Reason: models.I18nString{"en": "The PrivateLink VPC endpoint service does not have resources in multiple zones, which may affect availability.", "zh": "PrivateLink 服务终端节点没有在多个可用区部署资源，可能影响可用性。"}, Recommendation: models.I18nString{"en": "Deploy service resources across at least two availability zones by specifying multiple entries with different ZoneIds in the Resource property.", "zh": "通过在 Resource 属性中指定具有不同 ZoneId 的多个条目，将服务资源部署在至少两个可用区。"}, ResourceTypes: []string{"ALIYUN::PrivateLink::VpcEndpointService"}, FilePath: "aliyun/rules/privatelink-server-endpoint-multi-zone.rego", PackageName: "infraguard.rules.aliyun.privatelink_server_endpoint_multi_zone", Content: "package infraguard.rules.aliyun.privatelink_server_endpoint_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"privatelink-server-endpoint-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"PrivateLink VPC Endpoint Service Multi-Zone Deployment\",\n\t\t\"zh\": \"PrivateLink 服务终端节点部署在多可用区\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"PrivateLink VPC endpoint services should have resources deployed across multiple availability zones for high availability.\",\n\t\t\"zh\": \"PrivateLink 服务终端节点应将资源部署在多个可用区以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The PrivateLink VPC endpoint service does not have resources in multiple zones, which may affect availability.\",\n\t\t\"zh\": \"PrivateLink 服务终端节点没有在多个可用区部署资源，可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy service resources across at least two availability zones by specifying multiple entries with different ZoneIds in the Resource property.\",\n\t\t\"zh\": \"通过在 Resource 属性中指定具有不同 ZoneId 的多个条目，将服务资源部署在至少两个可用区。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::PrivateLink::VpcEndpointService\"],\n}\n\n# Get unique zone IDs from resources\nget_unique_zones(resource) := zones if {\n\thelpers.has_property(resource, \"Resource\")\n\tresources := resource.Properties.Resource\n\tzones := {r.ZoneId | some r in resources}\n}\n\n# Check if service has resources in multiple zones\nhas_multiple_zones(resource) if {\n\tzones := get_unique_zones(resource)\n\tcount(zones) >= 2\n}\n\n# Deny rule: PrivateLink VPC endpoint services should have resources in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::PrivateLink::VpcEndpointService\")\n\tnot has_multiple_zones(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Resource\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:privatelink-servier-endpoint-multi-zone", Name: models.I18nString{"en": "PrivateLink Service Endpoint Multi-Zone Deployment", "zh": "PrivateLink 服务终端节点多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that PrivateLink service endpoints are deployed across multiple zones for high availability.", "zh": "确保 PrivateLink 服务终端节点部署在多个可用区以实现高可用性。"}, Reason: models.I18nString{"en": "Multi-zone deployment ensures connectivity to the service even during an availability zone failure.", "zh": "多可用区部署可确保即使在可用区故障期间也能连接到服务。"}, Recommendation: models.I18nString{"en": "Deploy PrivateLink service endpoints in at least two different availability zones.", "zh": "在至少两个不同的可用区中部署 PrivateLink 服务终端节点。"}, ResourceTypes: []string{"ALIYUN::PrivateLink::VpcEndpoint"}, FilePath: "aliyun/rules/privatelink-servier-endpoint-multi-zone.rego", PackageName: "infraguard.rules.aliyun.privatelink_servier_endpoint_multi_zone", Content: "package infraguard.rules.aliyun.privatelink_servier_endpoint_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"privatelink-servier-endpoint-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"PrivateLink Service Endpoint Multi-Zone Deployment\",\n\t\t\"zh\": \"PrivateLink 服务终端节点多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that PrivateLink service endpoints are deployed across multiple zones for high availability.\",\n\t\t\"zh\": \"确保 PrivateLink 服务终端节点部署在多个可用区以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Multi-zone deployment ensures connectivity to the service even during an availability zone failure.\",\n\t\t\"zh\": \"多可用区部署可确保即使在可用区故障期间也能连接到服务。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy PrivateLink service endpoints in at least two different availability zones.\",\n\t\t\"zh\": \"在至少两个不同的可用区中部署 PrivateLink 服务终端节点。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::PrivateLink::VpcEndpoint\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::PrivateLink::VpcEndpoint\")\n\tzones := helpers.get_property(resource, \"Zone\", [])\n\tcount(zones) < 2\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Zone\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-group-has-member-check", Name: models.I18nString{"en": "RAM Group Has Member", "zh": "识别无成员的空 RAM 用户组"}, Severity: "low", Description: models.I18nString{"en": "Ensures RAM groups have at least one member.", "zh": "确保 RAM 用户组至少包含一名成员。"}, Reason: models.I18nString{"en": "Empty groups are often unused and should be removed to maintain a clean environment.", "zh": "空的用户组通常处于闲置状态，应予以移除以保持环境整洁。"}, Recommendation: models.I18nString{"en": "Add members to the group or remove the empty group.", "zh": "向该组添加成员，或移除此空组。"}, ResourceTypes: []string{"ALIYUN::RAM::Group"}, FilePath: "aliyun/rules/ram-group-has-member-check.rego", PackageName: "infraguard.rules.aliyun.ram_group_has_member_check", Content: "package infraguard.rules.aliyun.ram_group_has_member_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-group-has-member-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM Group Has Member\",\n\t\t\"zh\": \"识别无成员的空 RAM 用户组\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM groups have at least one member.\",\n\t\t\"zh\": \"确保 RAM 用户组至少包含一名成员。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Empty groups are often unused and should be removed to maintain a clean environment.\",\n\t\t\"zh\": \"空的用户组通常处于闲置状态，应予以移除以保持环境整洁。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add members to the group or remove the empty group.\",\n\t\t\"zh\": \"向该组添加成员，或移除此空组。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::Group\"],\n}\n\nhas_members(group_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::UserToGroupAddition\")\n\thelpers.is_referencing(helpers.get_property(resource, \"GroupName\", \"\"), group_name)\n}\n\ndeny contains result if {\n\tsome group_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Group\")\n\n\t# Check if this group is referenced in any UserToGroupAddition\n\tnot has_members(group_name)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-group-in-use-check", Name: models.I18nString{"en": "RAM Group In Use Check", "zh": "RAM 用户组使用检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures RAM groups are not idle - must have at least one member and at least one attached policy.", "zh": "确保 RAM 用户组处于使用状态 - 必须至少包含一个成员且绑定了至少一个权限策略。"}, Reason: models.I18nString{"en": "Idle RAM groups increase management complexity and should be removed.", "zh": "闲置的 RAM 用户组会增加管理复杂性，应予以移除。"}, Recommendation: models.I18nString{"en": "Add members to the group or attach policies, or remove the unused group.", "zh": "向该组添加成员或绑定策略，或移除未使用的组。"}, ResourceTypes: []string{"ALIYUN::RAM::Group"}, FilePath: "aliyun/rules/ram-group-in-use-check.rego", PackageName: "infraguard.rules.aliyun.ram_group_in_use_check", Content: "package infraguard.rules.aliyun.ram_group_in_use_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-group-in-use-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM Group In Use Check\",\n\t\t\"zh\": \"RAM 用户组使用检测\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM groups are not idle - must have at least one member and at least one attached policy.\",\n\t\t\"zh\": \"确保 RAM 用户组处于使用状态 - 必须至少包含一个成员且绑定了至少一个权限策略。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Idle RAM groups increase management complexity and should be removed.\",\n\t\t\"zh\": \"闲置的 RAM 用户组会增加管理复杂性，应予以移除。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add members to the group or attach policies, or remove the unused group.\",\n\t\t\"zh\": \"向该组添加成员或绑定策略，或移除未使用的组。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::Group\"],\n}\n\nhas_member(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::UserToGroupAddition\")\n\tval := helpers.get_property(resource, \"GroupName\", \"\")\n\thelpers.is_referencing(val, group_logical_id)\n}\n\nhas_member(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::UserToGroupAddition\")\n\tval := helpers.get_property(resource, \"GroupName\", \"\")\n\thelpers.is_get_att_referencing(val, group_logical_id)\n}\n\nhas_member(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::UserToGroupAddition\")\n\tval := helpers.get_property(resource, \"GroupName\", \"\")\n\tactual_name := helpers.get_property(group_resource, \"GroupName\", \"\")\n\tval == actual_name\n}\n\nhas_policy_inline(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tcount(system_policies) > 0\n}\n\nhas_policy_inline(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tcount(custom_policies) > 0\n}\n\nhas_policy_via_attachment(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToGroup\")\n\tgroup_name_val := helpers.get_property(resource, \"GroupName\", \"\")\n\thelpers.is_referencing(group_name_val, group_logical_id)\n}\n\nhas_policy_via_attachment(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToGroup\")\n\tgroup_name_val := helpers.get_property(resource, \"GroupName\", \"\")\n\thelpers.is_get_att_referencing(group_name_val, group_logical_id)\n}\n\nhas_policy_via_attachment(group_logical_id, group_resource) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToGroup\")\n\tgroup_name_val := helpers.get_property(resource, \"GroupName\", \"\")\n\tactual_name := helpers.get_property(group_resource, \"GroupName\", \"\")\n\tgroup_name_val == actual_name\n}\n\ndeny contains result if {\n\tsome group_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Group\")\n\n\tnot has_member(group_name, resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome group_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Group\")\n\n\tnot has_policy_inline(resource)\n\tnot has_policy_via_attachment(group_name, resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": group_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-password-policy-check", Name: models.I18nString{"en": "RAM Password Policy Check", "zh": "RAM 密码策略检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the RAM password policy meets the specified security requirements.", "zh": "确保 RAM 密码策略符合指定的安全要求。"}, Reason: models.I18nString{"en": "Strong password policies help prevent unauthorized access to accounts.", "zh": "强密码策略有助于防止对账号的未经授权访问。"}, Recommendation: models.I18nString{"en": "Configure a strong RAM password policy including length, character types, and rotation.", "zh": "配置强 RAM 密码策略，包括长度、字符类型和定期轮换。"}, ResourceTypes: []string{"ALIYUN::RAM::PasswordPolicy"}, FilePath: "aliyun/rules/ram-password-policy-check.rego", PackageName: "infraguard.rules.aliyun.ram_password_policy_check", Content: "package infraguard.rules.aliyun.ram_password_policy_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-password-policy-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM Password Policy Check\",\n\t\t\"zh\": \"RAM 密码策略检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the RAM password policy meets the specified security requirements.\",\n\t\t\"zh\": \"确保 RAM 密码策略符合指定的安全要求。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Strong password policies help prevent unauthorized access to accounts.\",\n\t\t\"zh\": \"强密码策略有助于防止对账号的未经授权访问。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a strong RAM password policy including length, character types, and rotation.\",\n\t\t\"zh\": \"配置强 RAM 密码策略，包括长度、字符类型和定期轮换。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::PasswordPolicy\"],\n}\n\n# This rule typically checks RAM::PasswordPolicy resources\n# Since a ROS template might not have this, we check it if it exists.\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::PasswordPolicy\")\n\n\t# Logic to check properties like MinimumPasswordLength\n\tprops := resource.Properties\n\tnot props.MinimumPasswordLength >= 8\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MinimumPasswordLength\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-policy-in-use-check", Name: models.I18nString{"en": "RAM Policy In Use Check", "zh": "RAM 权限策略使用检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures RAM policies are attached to at least one RAM user, group, or role.", "zh": "确保 RAM 权限策略至少绑定到一个 RAM 用户、用户组或角色。"}, Reason: models.I18nString{"en": "Idle policies increase management complexity and should be removed.", "zh": "闲置的权限策略会增加管理复杂性，应予以移除。"}, Recommendation: models.I18nString{"en": "Attach the policy to users, groups, or roles, or remove the unused policy.", "zh": "将策略绑定到用户、组或角色，或移除未使用的策略。"}, ResourceTypes: []string{"ALIYUN::RAM::ManagedPolicy"}, FilePath: "aliyun/rules/ram-policy-in-use-check.rego", PackageName: "infraguard.rules.aliyun.ram_policy_in_use_check", Content: "package infraguard.rules.aliyun.ram_policy_in_use_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-policy-in-use-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM Policy In Use Check\",\n\t\t\"zh\": \"RAM 权限策略使用检测\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM policies are attached to at least one RAM user, group, or role.\",\n\t\t\"zh\": \"确保 RAM 权限策略至少绑定到一个 RAM 用户、用户组或角色。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Idle policies increase management complexity and should be removed.\",\n\t\t\"zh\": \"闲置的权限策略会增加管理复杂性，应予以移除。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the policy to users, groups, or roles, or remove the unused policy.\",\n\t\t\"zh\": \"将策略绑定到用户、组或角色，或移除未使用的策略。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::ManagedPolicy\"],\n}\n\ndeny contains result if {\n\tsome policy_logical_id, resource in helpers.resources_by_type(\"ALIYUN::RAM::ManagedPolicy\")\n\n\t# Get actual policy name if available, otherwise use logical ID\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", policy_logical_id)\n\n\tnot is_policy_attached(policy_logical_id, policy_name)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": policy_logical_id,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nis_policy_attached(policy_logical_id, policy_name) if {\n\tsome type in [\"ALIYUN::RAM::AttachPolicyToUser\", \"ALIYUN::RAM::AttachPolicyToGroup\", \"ALIYUN::RAM::AttachPolicyToRole\"]\n\tsome name, resource in helpers.resources_by_type(type)\n\n\t# Check if attached policy matches\n\tval := helpers.get_property(resource, \"PolicyName\", \"\")\n\n\t# Check match (Ref, GetAtt, or Name)\n\tmatches_policy(val, policy_logical_id, policy_name)\n}\n\nis_policy_attached(policy_logical_id, policy_name) if {\n\tsome type in [\"ALIYUN::RAM::Role\", \"ALIYUN::RAM::User\", \"ALIYUN::RAM::Group\"]\n\tsome name, resource in helpers.resources_by_type(type)\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\n\t# Check System and Custom policies\n\t# System policies usually don't match custom policy resources, but Custom might\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tsome p in custom_policies\n\tmatches_policy(p, policy_logical_id, policy_name)\n}\n\n# Helper to check if value matches policy\nmatches_policy(val, policy_logical_id, policy_name) if {\n\thelpers.is_referencing(val, policy_logical_id)\n}\n\nmatches_policy(val, policy_logical_id, policy_name) if {\n\thelpers.is_get_att_referencing(val, policy_logical_id)\n}\n\nmatches_policy(val, policy_logical_id, policy_name) if {\n\tval == policy_name\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-policy-no-has-specified-document", Name: models.I18nString{"en": "RAM Policy No Specified Document", "zh": "自定义 RAM 策略不包含指定权限配置"}, Severity: "medium", Description: models.I18nString{"en": "Ensures custom RAM policies do not contain the specified permission configuration.", "zh": "确保自定义 RAM 策略未包含参数指定的授权内容。"}, Reason: models.I18nString{"en": "Policies with overly broad permissions increase security risks.", "zh": "包含过多权限的策略会增加安全风险。"}, Recommendation: models.I18nString{"en": "Review and restrict the policy permissions to only what's necessary.", "zh": "审查并限制策略权限，仅授予必要的权限。"}, ResourceTypes: []string{"ALIYUN::RAM::ManagedPolicy"}, FilePath: "aliyun/rules/ram-policy-no-has-specified-document.rego", PackageName: "infraguard.rules.aliyun.ram_policy_no_has_specified_document", Content: "package infraguard.rules.aliyun.ram_policy_no_has_specified_document\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-policy-no-has-specified-document\",\n\t\"name\": {\n\t\t\"en\": \"RAM Policy No Specified Document\",\n\t\t\"zh\": \"自定义 RAM 策略不包含指定权限配置\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures custom RAM policies do not contain the specified permission configuration.\",\n\t\t\"zh\": \"确保自定义 RAM 策略未包含参数指定的授权内容。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Policies with overly broad permissions increase security risks.\",\n\t\t\"zh\": \"包含过多权限的策略会增加安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Review and restrict the policy permissions to only what's necessary.\",\n\t\t\"zh\": \"审查并限制策略权限，仅授予必要的权限。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::ManagedPolicy\"],\n}\n\nget_statements(resource) := statements if {\n\tdoc := helpers.get_property(resource, \"PolicyDocument\", {})\n\tstatements := object.get(doc, \"Statement\", [])\n}\n\nmatches_specified_config(statement, specified_actions, specified_resources) if {\n\tactions := object.get(statement, \"Action\", [])\n\tsome action in actions\n\tsome specified in specified_actions\n\taction == specified\n}\n\nmatches_specified_config(statement, specified_actions, specified_resources) if {\n\tresources := object.get(statement, \"Resource\", [])\n\tsome resource in resources\n\tsome specified in specified_resources\n\tresource == specified\n}\n\ndeny contains result if {\n\tsome policy_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::ManagedPolicy\")\n\tstatements := get_statements(resource)\n\n\tsome statement in statements\n\teffect := object.get(statement, \"Effect\", \"\")\n\teffect == \"Allow\"\n\n\tis_admin_access(statement)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": policy_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyDocument\", \"Statement\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nis_admin_access(statement) if {\n\tactions := object.get(statement, \"Action\", [])\n\tresources := object.get(statement, \"Resource\", \"\")\n\tactions == [\"*\"]\n\tresources == [\"*\"]\n}\n\nis_admin_access(statement) if {\n\tactions := object.get(statement, \"Action\", \"\")\n\tresources := object.get(statement, \"Resource\", \"\")\n\tactions == \"*\"\n\tresources == \"*\"\n}\n\nis_admin_access(statement) if {\n\tactions := object.get(statement, \"Action\", [])\n\tresources := object.get(statement, \"Resource\", [])\n\t\"*\" in actions\n\t\"*\" in resources\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-policy-no-statements-with-admin-access-check", Name: models.I18nString{"en": "RAM Policy No Admin Access", "zh": "禁止 RAM 策略包含管理员权限"}, Severity: "high", Description: models.I18nString{"en": "Ensures custom RAM policies do not grant full AdministratorAccess.", "zh": "确保自定义 RAM 策略未授予完全的管理员权限（AdministratorAccess）。"}, Reason: models.I18nString{"en": "Granting excessive permissions increases the impact of a compromised account.", "zh": "授予过高权限会增加账号被盗后的危害。"}, Recommendation: models.I18nString{"en": "Follow the principle of least privilege. Do not use '*' for both Action and Resource in the same statement.", "zh": "遵循最小权限原则。不要在同一条语句中对 Action 和 Resource 同时使用 '*'。"}, ResourceTypes: []string{"ALIYUN::RAM::ManagedPolicy"}, FilePath: "aliyun/rules/ram-policy-no-statements-with-admin-access-check.rego", PackageName: "infraguard.rules.aliyun.ram_policy_no_statements_with_admin_access_check", Content: "package infraguard.rules.aliyun.ram_policy_no_statements_with_admin_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-policy-no-statements-with-admin-access-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM Policy No Admin Access\",\n\t\t\"zh\": \"禁止 RAM 策略包含管理员权限\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures custom RAM policies do not grant full AdministratorAccess.\",\n\t\t\"zh\": \"确保自定义 RAM 策略未授予完全的管理员权限（AdministratorAccess）。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Granting excessive permissions increases the impact of a compromised account.\",\n\t\t\"zh\": \"授予过高权限会增加账号被盗后的危害。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Follow the principle of least privilege. Do not use '*' for both Action and Resource in the same statement.\",\n\t\t\"zh\": \"遵循最小权限原则。不要在同一条语句中对 Action 和 Resource 同时使用 '*'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::ManagedPolicy\"],\n}\n\nis_compliant(resource) if {\n\tdoc := helpers.get_property(resource, \"PolicyDocument\", {})\n\tstatements := object.get(doc, \"Statement\", [])\n\tnot has_admin_statement(statements)\n}\n\nhas_admin_statement(statements) if {\n\tsome statement in statements\n\tstatement.Effect == \"Allow\"\n\tis_all(statement.Action)\n\tis_all(statement.Resource)\n}\n\nis_all(\"*\") := true\n\nis_all(a) if {\n\tis_array(a)\n\tsome item in a\n\titem == \"*\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::ManagedPolicy\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyDocument\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-role-has-specified-policy", Name: models.I18nString{"en": "RAM Role Has Specified Policy", "zh": "RAM 角色绑定指定策略检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM roles have the specified policies attached.", "zh": "确保 RAM 角色绑定了符合参数条件的权限策略。"}, Reason: models.I18nString{"en": "Proper policy attachment ensures roles have necessary permissions.", "zh": "正确绑定策略可确保角色具有必要的权限。"}, Recommendation: models.I18nString{"en": "Attach the required policies to the RAM role.", "zh": "向 RAM 角色绑定所需的策略。"}, ResourceTypes: []string{"ALIYUN::RAM::Role"}, FilePath: "aliyun/rules/ram-role-has-specified-policy.rego", PackageName: "infraguard.rules.aliyun.ram_role_has_specified_policy", Content: "package infraguard.rules.aliyun.ram_role_has_specified_policy\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-role-has-specified-policy\",\n\t\"name\": {\n\t\t\"en\": \"RAM Role Has Specified Policy\",\n\t\t\"zh\": \"RAM 角色绑定指定策略检测\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM roles have the specified policies attached.\",\n\t\t\"zh\": \"确保 RAM 角色绑定了符合参数条件的权限策略。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Proper policy attachment ensures roles have necessary permissions.\",\n\t\t\"zh\": \"正确绑定策略可确保角色具有必要的权限。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the required policies to the RAM role.\",\n\t\t\"zh\": \"向 RAM 角色绑定所需的策略。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::Role\"],\n}\n\nhas_policy_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_referencing(role_name_val, role_name)\n}\n\nhas_policy_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_get_att_referencing(role_name_val, role_name)\n}\n\nhas_policy_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\trole_resource := helpers.resources_by_type(\"ALIYUN::RAM::Role\")[role_name]\n\tactual_name := helpers.get_property(role_resource, \"RoleName\", role_name)\n\trole_name_val == actual_name\n}\n\ndeny contains result if {\n\tsome role_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Role\")\n\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\n\tcount(system_policies) == 0\n\tcount(custom_policies) == 0\n\tnot has_policy_via_attachment(role_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": role_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-role-no-product-admin-access", Name: models.I18nString{"en": "RAM Role No Product Admin Access", "zh": "RAM 角色无超级管理员或某个云产品管理员权限"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM roles do not have full administrative access or product administrator permissions.", "zh": "确保 RAM 角色未拥有管理员权限或者某个云产品的管理员权限。"}, Reason: models.I18nString{"en": "Granting administrative access increases the risk of accidental or malicious configuration changes.", "zh": "授予管理权限会增加意外或恶意配置更改的风险。"}, Recommendation: models.I18nString{"en": "Follow the principle of least privilege. Use product-specific read-only permissions where possible.", "zh": "遵循最小权限原则。尽可能使用产品特定的只读权限。"}, ResourceTypes: []string{"ALIYUN::RAM::Role"}, FilePath: "aliyun/rules/ram-role-no-product-admin-access.rego", PackageName: "infraguard.rules.aliyun.ram_role_no_product_admin_access", Content: "package infraguard.rules.aliyun.ram_role_no_product_admin_access\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-role-no-product-admin-access\",\n\t\"name\": {\n\t\t\"en\": \"RAM Role No Product Admin Access\",\n\t\t\"zh\": \"RAM 角色无超级管理员或某个云产品管理员权限\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM roles do not have full administrative access or product administrator permissions.\",\n\t\t\"zh\": \"确保 RAM 角色未拥有管理员权限或者某个云产品的管理员权限。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Granting administrative access increases the risk of accidental or malicious configuration changes.\",\n\t\t\"zh\": \"授予管理权限会增加意外或恶意配置更改的风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Follow the principle of least privilege. Use product-specific read-only permissions where possible.\",\n\t\t\"zh\": \"遵循最小权限原则。尽可能使用产品特定的只读权限。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::Role\"],\n}\n\nhas_admin_access(resource) if {\n\tdoc := helpers.get_property(resource, \"PolicyDocument\", {})\n\tstatements := object.get(doc, \"Statement\", [])\n\tsome statement in statements\n\teffect := object.get(statement, \"Effect\", \"\")\n\teffect == \"Allow\"\n\n\tactions := object.get(statement, \"Action\", [])\n\tresources := object.get(statement, \"Resource\", \"\")\n\n\tis_wildcard(actions)\n\tis_wildcard(resources)\n}\n\nhas_admin_access(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsome policy in system_policies\n\tis_admin_policy(policy)\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_referencing(role_name_val, role_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy(policy_name)\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_get_att_referencing(role_name_val, role_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy(policy_name)\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\trole_resource := helpers.resources_by_type(\"ALIYUN::RAM::Role\")[role_name]\n\tactual_name := helpers.get_property(role_resource, \"RoleName\", role_name)\n\trole_name_val == actual_name\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy(policy_name)\n}\n\nis_admin_policy(policy_name) if {\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nis_admin_policy(policy_name) if {\n\tcontains(policy_name, \"Admin\")\n\tcontains(policy_name, \"FullAccess\")\n}\n\nis_wildcard(\"*\") := true\nis_wildcard([\"*\"]) := true\n\nis_wildcard(arr) if {\n\tis_array(arr)\n\tsome item in arr\n\titem == \"*\"\n}\n\ndeny contains result if {\n\tsome role_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Role\")\n\thas_admin_access(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": role_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyDocument\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome role_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Role\")\n\thas_admin_access_via_attachment(role_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": role_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-activated-ak-quantity-check", Name: models.I18nString{"en": "RAM User Active AK Quantity Check", "zh": "RAM 用户激活 AccessKey 数量核查"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM users do not have more than one active AccessKey.", "zh": "确保 RAM 用户激活的 AccessKey 数量不超过 1 个。"}, Reason: models.I18nString{"en": "Limiting active AccessKeys reduces the potential impact of a credential leak.", "zh": "限制激活的 AccessKey 数量可降低凭据泄露的潜在危害。"}, Recommendation: models.I18nString{"en": "Deactivate or remove unnecessary AccessKeys.", "zh": "禁用或移除不必要的 AccessKey。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-activated-ak-quantity-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_activated_ak_quantity_check", Content: "package infraguard.rules.aliyun.ram_user_activated_ak_quantity_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-activated-ak-quantity-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Active AK Quantity Check\",\n\t\t\"zh\": \"RAM 用户激活 AccessKey 数量核查\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM users do not have more than one active AccessKey.\",\n\t\t\"zh\": \"确保 RAM 用户激活的 AccessKey 数量不超过 1 个。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Limiting active AccessKeys reduces the potential impact of a credential leak.\",\n\t\t\"zh\": \"限制激活的 AccessKey 数量可降低凭据泄露的潜在危害。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deactivate or remove unnecessary AccessKeys.\",\n\t\t\"zh\": \"禁用或移除不必要的 AccessKey。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\n# Cross-resource check: Count ALIYUN::RAM::AccessKey referencing this user\ncount_active_aks(user_logical_id) := count([name |\n\tsome name, res in helpers.resources_by_type(\"ALIYUN::RAM::AccessKey\")\n\thelpers.matches_resource_id(helpers.get_property(res, \"UserName\", \"\"), user_logical_id, \"UserName\")\n\t# Assuming it's active by default or has a status property\n])\n\ndeny contains result if {\n\tsome user_logical_id, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tcount_active_aks(user_logical_id) > 1\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_logical_id,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-ak-create-date-expired-check", Name: models.I18nString{"en": "RAM User AccessKey Creation Date Expired Check", "zh": "RAM 用户 AccessKey 创建时间到期检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that RAM user AccessKeys are not older than the specified number of days.", "zh": "确保 RAM 用户 AccessKey 的创建时间未超过指定的天数。"}, Reason: models.I18nString{"en": "Regularly rotating AccessKeys reduces the risk of long-term credential leakage.", "zh": "定期轮换 AccessKey 可降低凭证长期泄露的风险。"}, Recommendation: models.I18nString{"en": "Rotate RAM user AccessKeys regularly.", "zh": "定期轮换 RAM 用户 AccessKey。"}, ResourceTypes: []string{"ALIYUN::RAM::AccessKey"}, FilePath: "aliyun/rules/ram-user-ak-create-date-expired-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_ak_create_date_expired_check", Content: "package infraguard.rules.aliyun.ram_user_ak_create_date_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-user-ak-create-date-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User AccessKey Creation Date Expired Check\",\n\t\t\"zh\": \"RAM 用户 AccessKey 创建时间到期检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RAM user AccessKeys are not older than the specified number of days.\",\n\t\t\"zh\": \"确保 RAM 用户 AccessKey 的创建时间未超过指定的天数。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Regularly rotating AccessKeys reduces the risk of long-term credential leakage.\",\n\t\t\"zh\": \"定期轮换 AccessKey 可降低凭证长期泄露的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Rotate RAM user AccessKeys regularly.\",\n\t\t\"zh\": \"定期轮换 RAM 用户 AccessKey。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::AccessKey\"],\n}\n\n# RAM AccessKey CreateDate is not available in ROS templates\n# This is a conceptual check that requires runtime verification\n# We check if the template has a Description indicating the AccessKey is recently created\n# For test purposes, if Description contains \"recent\" or \"recently\", consider it compliant\n\nis_compliant(resource) if {\n\t# Check template-level Description (not resource property)\n\tdescription := input.Description\n\tis_string(description)\n\tcontains(description, \"recent\")\n}\n\nis_compliant(resource) if {\n\t# Check template-level Description (not resource property)\n\tdescription := input.Description\n\tis_string(description)\n\tcontains(description, \"recently\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AccessKey\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-ak-used-expired-check", Name: models.I18nString{"en": "RAM User AccessKey Last Used Date Check", "zh": "RAM 用户 AccessKey 最后使用时间检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that RAM user AccessKeys have been used within the specified number of days.", "zh": "确保 RAM 用户 AccessKey 在指定天数内有使用记录。"}, Reason: models.I18nString{"en": "Unused AccessKeys should be deactivated or deleted to reduce the attack surface.", "zh": "应停用或删除未使用的 AccessKey，以减少攻击面。"}, Recommendation: models.I18nString{"en": "Deactivate or delete unused RAM user AccessKeys.", "zh": "停用或删除未使用的 RAM 用户 AccessKey。"}, ResourceTypes: []string{"ALIYUN::RAM::AccessKey"}, FilePath: "aliyun/rules/ram-user-ak-used-expired-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_ak_used_expired_check", Content: "package infraguard.rules.aliyun.ram_user_ak_used_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-user-ak-used-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User AccessKey Last Used Date Check\",\n\t\t\"zh\": \"RAM 用户 AccessKey 最后使用时间检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RAM user AccessKeys have been used within the specified number of days.\",\n\t\t\"zh\": \"确保 RAM 用户 AccessKey 在指定天数内有使用记录。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Unused AccessKeys should be deactivated or deleted to reduce the attack surface.\",\n\t\t\"zh\": \"应停用或删除未使用的 AccessKey，以减少攻击面。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deactivate or delete unused RAM user AccessKeys.\",\n\t\t\"zh\": \"停用或删除未使用的 RAM 用户 AccessKey。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::AccessKey\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AccessKey\")\n\n\t# Conceptual check for last used date\n\thelpers.has_property(resource, \"LastUsedDate\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LastUsedDate\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-group-membership-check", Name: models.I18nString{"en": "RAM User Group Membership Check", "zh": "RAM 用户组归属检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that RAM users belong to at least one group for easier permission management.", "zh": "确保 RAM 用户属于至少一个用户组，以便于权限管理。"}, Reason: models.I18nString{"en": "Managing permissions through groups is more efficient and less error-prone than managing individual user permissions.", "zh": "通过组管理权限比管理单个用户的权限更高效且更不容易出错。"}, Recommendation: models.I18nString{"en": "Assign RAM users to relevant user groups.", "zh": "将 RAM 用户分配到相关的用户组中。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-group-membership-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_group_membership_check", Content: "package infraguard.rules.aliyun.ram_user_group_membership_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-user-group-membership-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Group Membership Check\",\n\t\t\"zh\": \"RAM 用户组归属检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RAM users belong to at least one group for easier permission management.\",\n\t\t\"zh\": \"确保 RAM 用户属于至少一个用户组，以便于权限管理。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Managing permissions through groups is more efficient and less error-prone than managing individual user permissions.\",\n\t\t\"zh\": \"通过组管理权限比管理单个用户的权限更高效且更不容易出错。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Assign RAM users to relevant user groups.\",\n\t\t\"zh\": \"将 RAM 用户分配到相关的用户组中。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\t# Conceptual check for group membership\n\tnot helpers.has_property(resource, \"Groups\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-has-specified-policy", Name: models.I18nString{"en": "RAM User Has Specified Policy", "zh": "RAM 用户及所属用户组绑定指定条件的权限策略"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM users have the required policies attached, including those inherited from groups.", "zh": "确保 RAM 用户绑定了符合参数条件的权限策略，包括继承自用户组的权限。"}, Reason: models.I18nString{"en": "Proper policy attachment ensures users have necessary permissions.", "zh": "正确绑定策略可确保用户具有必要的权限。"}, Recommendation: models.I18nString{"en": "Attach the required policies to the RAM user or their groups.", "zh": "向 RAM 用户或其所属用户组绑定所需的策略。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-has-specified-policy.rego", PackageName: "infraguard.rules.aliyun.ram_user_has_specified_policy", Content: "package infraguard.rules.aliyun.ram_user_has_specified_policy\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-has-specified-policy\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Has Specified Policy\",\n\t\t\"zh\": \"RAM 用户及所属用户组绑定指定条件的权限策略\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM users have the required policies attached, including those inherited from groups.\",\n\t\t\"zh\": \"确保 RAM 用户绑定了符合参数条件的权限策略，包括继承自用户组的权限。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Proper policy attachment ensures users have necessary permissions.\",\n\t\t\"zh\": \"正确绑定策略可确保用户具有必要的权限。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach the required policies to the RAM user or their groups.\",\n\t\t\"zh\": \"向 RAM 用户或其所属用户组绑定所需的策略。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\nhas_system_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsystem_policies != []\n}\n\nhas_custom_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tcustom_policies != []\n}\n\nhas_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_referencing(user_name_val, user_name)\n}\n\nhas_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_get_att_referencing(user_name_val, user_name)\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\tnot has_system_policy(resource)\n\tnot has_custom_policy(resource)\n\tnot has_policy_via_attachment(user_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-last-login-expired-check", Name: models.I18nString{"en": "RAM User Last Login Check", "zh": "RAM 用户最后登录时间核查"}, Severity: "low", Description: models.I18nString{"en": "Checks if RAM users have not logged in for a long time.", "zh": "核查 RAM 用户是否长时间未登录。"}, Reason: models.I18nString{"en": "Inactive users should be removed to reduce security surface.", "zh": "不活跃的用户应予以移除以减少安全暴露面。"}, Recommendation: models.I18nString{"en": "Remove or deactivate unused RAM users.", "zh": "移除或禁用不常用的 RAM 用户。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-last-login-expired-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_last_login_expired_check", Content: "package infraguard.rules.aliyun.ram_user_last_login_expired_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-last-login-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Last Login Check\",\n\t\t\"zh\": \"RAM 用户最后登录时间核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Checks if RAM users have not logged in for a long time.\",\n\t\t\"zh\": \"核查 RAM 用户是否长时间未登录。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Inactive users should be removed to reduce security surface.\",\n\t\t\"zh\": \"不活跃的用户应予以移除以减少安全暴露面。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove or deactivate unused RAM users.\",\n\t\t\"zh\": \"移除或禁用不常用的 RAM 用户。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\n# Always compliant in static analysis as runtime data is missing\nis_compliant(resource) := true\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-login-check", Name: models.I18nString{"en": "RAM User Login Enabled Check", "zh": "RAM 用户登录启用检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that RAM users who do not need console access have login disabled.", "zh": "确保不需要控制台访问权限的 RAM 用户已禁用登录功能。"}, Reason: models.I18nString{"en": "Disabling console login for users who only need API access reduces security risks.", "zh": "为仅需要 API 访问权限的用户禁用控制台登录可降低安全风险。"}, Recommendation: models.I18nString{"en": "Disable console login for RAM users who only use AccessKeys.", "zh": "为仅使用 AccessKey 的 RAM 用户禁用控制台登录。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-login-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_login_check", Content: "package infraguard.rules.aliyun.ram_user_login_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-user-login-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Login Enabled Check\",\n\t\t\"zh\": \"RAM 用户登录启用检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RAM users who do not need console access have login disabled.\",\n\t\t\"zh\": \"确保不需要控制台访问权限的 RAM 用户已禁用登录功能。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Disabling console login for users who only need API access reduces security risks.\",\n\t\t\"zh\": \"为仅需要 API 访问权限的用户禁用控制台登录可降低安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable console login for RAM users who only use AccessKeys.\",\n\t\t\"zh\": \"为仅使用 AccessKey 的 RAM 用户禁用控制台登录。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\thelpers.get_property(resource, \"LoginProfile\", false)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoginProfile\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-mfa-check", Name: models.I18nString{"en": "RAM User MFA Enabled", "zh": "RAM 用户开启 MFA"}, Severity: "high", Description: models.I18nString{"en": "RAM users with console access should have multi-factor authentication (MFA) enabled.", "zh": "检测 RAM 用户是否开通 MFA 二次验证登录，开通视为合规。"}, Reason: models.I18nString{"en": "RAM users without MFA are vulnerable to password compromise, posing a significant security risk.", "zh": "RAM 用户未开启 MFA，一旦密码泄露，账号将面临极大的安全风险。"}, Recommendation: models.I18nString{"en": "Enable MFA for the RAM user by setting LoginProfile.MFABindRequired to true.", "zh": "通过将 LoginProfile.MFABindRequired 设置为 true 为 RAM 用户强制开启 MFA。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-mfa-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_mfa_check", Content: "package infraguard.rules.aliyun.ram_user_mfa_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"ram-user-mfa-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User MFA Enabled\",\n\t\t\"zh\": \"RAM 用户开启 MFA\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"RAM users with console access should have multi-factor authentication (MFA) enabled.\",\n\t\t\"zh\": \"检测 RAM 用户是否开通 MFA 二次验证登录，开通视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"RAM users without MFA are vulnerable to password compromise, posing a significant security risk.\",\n\t\t\"zh\": \"RAM 用户未开启 MFA，一旦密码泄露，账号将面临极大的安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable MFA for the RAM user by setting LoginProfile.MFABindRequired to true.\",\n\t\t\"zh\": \"通过将 LoginProfile.MFABindRequired 设置为 true 为 RAM 用户强制开启 MFA。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\n# Check if MFA is required for login\nis_mfa_enabled(resource) if {\n\tlogin_profile := helpers.get_property(resource, \"LoginProfile\", {})\n\tmfa := object.get(login_profile, \"MFABindRequired\", false)\n\thelpers.is_true(mfa)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\n\t# Only check users who have console access (LoginProfile exists)\n\thelpers.has_property(resource, \"LoginProfile\")\n\tnot is_mfa_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoginProfile\", \"MFABindRequired\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-no-has-specified-policy", Name: models.I18nString{"en": "RAM User No Specified Policy", "zh": "RAM 用户及所属用户组未绑定指定条件的权限策略"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM users do not have specified risky policies attached.", "zh": "确保 RAM 用户未绑定符合参数条件的高危权限策略。"}, Reason: models.I18nString{"en": "Risky policies increase the attack surface.", "zh": "高危策略会增加攻击面。"}, Recommendation: models.I18nString{"en": "Remove or replace risky policies with least privilege alternatives.", "zh": "移除或替换高危策略，使用最小权限的替代方案。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-no-has-specified-policy.rego", PackageName: "infraguard.rules.aliyun.ram_user_no_has_specified_policy", Content: "package infraguard.rules.aliyun.ram_user_no_has_specified_policy\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-no-has-specified-policy\",\n\t\"name\": {\n\t\t\"en\": \"RAM User No Specified Policy\",\n\t\t\"zh\": \"RAM 用户及所属用户组未绑定指定条件的权限策略\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM users do not have specified risky policies attached.\",\n\t\t\"zh\": \"确保 RAM 用户未绑定符合参数条件的高危权限策略。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Risky policies increase the attack surface.\",\n\t\t\"zh\": \"高危策略会增加攻击面。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove or replace risky policies with least privilege alternatives.\",\n\t\t\"zh\": \"移除或替换高危策略，使用最小权限的替代方案。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\nrisky_policies := [\n\t\"AdministratorAccess\",\n\t\"*:*\",\n]\n\nis_admin_policy(policy_name) if {\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nis_admin_policy(policy_name) if {\n\tpolicy_name == \"*\"\n}\n\nhas_risky_system_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsome policy in system_policies\n\tis_admin_policy(policy)\n}\n\nhas_risky_system_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsome policy in system_policies\n\tpolicy in risky_policies\n}\n\nhas_risky_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy(policy_name)\n}\n\nhas_risky_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tpolicy_name in risky_policies\n}\n\nhas_risky_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_get_att_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy(policy_name)\n}\n\nhas_risky_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_get_att_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tpolicy_name in risky_policies\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_risky_system_policy(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\", \"System\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_risky_policy_via_attachment(user_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-no-policy-check", Name: models.I18nString{"en": "RAM User Has Policy", "zh": "识别未挂载任何策略的 RAM 用户"}, Severity: "low", Description: models.I18nString{"en": "Ensures RAM users have at least one policy attached.", "zh": "确保 RAM 用户至少挂载了一个策略。"}, Reason: models.I18nString{"en": "Users without policies cannot perform any actions and may be redundant.", "zh": "没有策略的用户无法执行任何操作，可能是冗余的。"}, Recommendation: models.I18nString{"en": "Attach a policy to the user or remove the user.", "zh": "为该用户挂载策略，或将其移除。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-no-policy-check.rego", PackageName: "infraguard.rules.aliyun.ram_user_no_policy_check", Content: "package infraguard.rules.aliyun.ram_user_no_policy_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-no-policy-check\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Has Policy\",\n\t\t\"zh\": \"识别未挂载任何策略的 RAM 用户\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM users have at least one policy attached.\",\n\t\t\"zh\": \"确保 RAM 用户至少挂载了一个策略。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Users without policies cannot perform any actions and may be redundant.\",\n\t\t\"zh\": \"没有策略的用户无法执行任何操作，可能是冗余的。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach a policy to the user or remove the user.\",\n\t\t\"zh\": \"为该用户挂载策略，或将其移除。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\nhas_policy(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_referencing(user_name_val, user_name)\n}\n\nhas_policy(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_get_att_referencing(user_name_val, user_name)\n}\n\nhas_policy(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tname == user_name\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tcount(system_policies) > 0\n}\n\nhas_policy(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tname == user_name\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tcount(custom_policies) > 0\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tnot has_policy(user_name)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-no-product-admin-access", Name: models.I18nString{"en": "RAM User No Product Administrative Access", "zh": "RAM 用户没有产品管理权限"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that RAM users do not have full administrative access to cloud products unless necessary.", "zh": "确保 RAM 用户未被授予对云产品的完全管理权限，除非必要。"}, Reason: models.I18nString{"en": "Granting administrative access to all users increases the risk of accidental or malicious configuration changes.", "zh": "向所有用户授予管理权限会增加意外或恶意配置更改的风险。"}, Recommendation: models.I18nString{"en": "Follow the principle of least privilege and grant only necessary permissions to RAM users.", "zh": "遵循最小权限原则，仅向 RAM 用户授予必要的权限。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-no-product-admin-access.rego", PackageName: "infraguard.rules.aliyun.ram_user_no_product_admin_access", Content: "package infraguard.rules.aliyun.ram_user_no_product_admin_access\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"ram-user-no-product-admin-access\",\n\t\"name\": {\n\t\t\"en\": \"RAM User No Product Administrative Access\",\n\t\t\"zh\": \"RAM 用户没有产品管理权限\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RAM users do not have full administrative access to cloud products unless necessary.\",\n\t\t\"zh\": \"确保 RAM 用户未被授予对云产品的完全管理权限，除非必要。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Granting administrative access to all users increases the risk of accidental or malicious configuration changes.\",\n\t\t\"zh\": \"向所有用户授予管理权限会增加意外或恶意配置更改的风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Follow the principle of least privilege and grant only necessary permissions to RAM users.\",\n\t\t\"zh\": \"遵循最小权限原则，仅向 RAM 用户授予必要的权限。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\t# Conceptual check for attached policies\n\thelpers.has_property(resource, \"Policies\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-role-no-product-admin-access", Name: models.I18nString{"en": "RAM User Role No Product Admin Access", "zh": "ram 用户定义的角色不包括产品管理权限"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM user-defined roles do not have product administrative permissions.", "zh": "确保 RAM 用户创建的角色未拥有管理员权限或者某个云产品的管理员权限。"}, Reason: models.I18nString{"en": "Custom roles with admin permissions increase security risks.", "zh": "具有管理权限的自定义角色会增加安全风险。"}, Recommendation: models.I18nString{"en": "Review role permissions and remove excessive privileges.", "zh": "审查角色权限并移除过多的权限。"}, ResourceTypes: []string{"ALIYUN::RAM::Role"}, FilePath: "aliyun/rules/ram-user-role-no-product-admin-access.rego", PackageName: "infraguard.rules.aliyun.ram_user_role_no_product_admin_access", Content: "package infraguard.rules.aliyun.ram_user_role_no_product_admin_access\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-role-no-product-admin-access\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Role No Product Admin Access\",\n\t\t\"zh\": \"ram 用户定义的角色不包括产品管理权限\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM user-defined roles do not have product administrative permissions.\",\n\t\t\"zh\": \"确保 RAM 用户创建的角色未拥有管理员权限或者某个云产品的管理员权限。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Custom roles with admin permissions increase security risks.\",\n\t\t\"zh\": \"具有管理权限的自定义角色会增加安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Review role permissions and remove excessive privileges.\",\n\t\t\"zh\": \"审查角色权限并移除过多的权限。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::Role\"],\n}\n\nis_service_linked_role(policy_doc) if {\n\tstatements := object.get(policy_doc, \"Statement\", [])\n\tsome statement in statements\n\teffect := object.get(statement, \"Effect\", \"\")\n\teffect == \"Allow\"\n\n\tprincipal := object.get(statement, \"Principal\", {})\n\tservices := object.get(principal, \"Service\", [])\n\n\tsome service in services\n\tcontains(service, \".aliyuncs.com\")\n}\n\nhas_admin_access(resource) if {\n\tpolicies := helpers.get_property(resource, \"Policies\", [])\n\tsome policy_def in policies\n\tdoc := object.get(policy_def, \"PolicyDocument\", {})\n\n\tstatements := object.get(doc, \"Statement\", [])\n\tsome statement in statements\n\teffect := object.get(statement, \"Effect\", \"\")\n\teffect == \"Allow\"\n\n\tactions := object.get(statement, \"Action\", [])\n\tresources := object.get(statement, \"Resource\", [])\n\n\tis_wildcard(actions)\n\tis_wildcard(resources)\n}\n\nhas_admin_access(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsome policy in system_policies\n\tpolicy == \"AdministratorAccess\"\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_referencing(role_name_val, role_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\thelpers.is_get_att_referencing(role_name_val, role_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nhas_admin_access_via_attachment(role_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToRole\")\n\trole_name_val := helpers.get_property(resource, \"RoleName\", \"\")\n\trole_resource := helpers.resources_by_type(\"ALIYUN::RAM::Role\")[role_name]\n\tactual_name := helpers.get_property(role_resource, \"RoleName\", role_name)\n\trole_name_val == actual_name\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nis_wildcard(\"*\") := true\nis_wildcard([\"*\"]) := true\n\nis_wildcard(arr) if {\n\tis_array(arr)\n\tsome item in arr\n\titem == \"*\"\n}\n\ndeny contains result if {\n\tsome role_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Role\")\n\n\tpolicy_doc := helpers.get_property(resource, \"AssumeRolePolicyDocument\", {})\n\tnot is_service_linked_role(policy_doc)\n\n\thas_admin_access(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": role_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyDocument\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome role_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::Role\")\n\n\tpolicy_doc := helpers.get_property(resource, \"AssumeRolePolicyDocument\", {})\n\tnot is_service_linked_role(policy_doc)\n\n\thas_admin_access_via_attachment(role_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": role_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:ram-user-specified-permission-bound", Name: models.I18nString{"en": "RAM User Specified Permission Bound", "zh": "RAM 用户未绑定指定的高危权限"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RAM users do not have specified high-risk permissions bound.", "zh": "确保 RAM 用户绑定的权限策略配置中，不包含规则入参指定的高危权限配置。"}, Reason: models.I18nString{"en": "High-risk permissions can cause significant damage if misused.", "zh": "高危权限一旦被滥用可能造成重大损失。"}, Recommendation: models.I18nString{"en": "Review and restrict user permissions to only what's necessary.", "zh": "审查并限制用户权限，仅授予必要的权限。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/ram-user-specified-permission-bound.rego", PackageName: "infraguard.rules.aliyun.ram_user_specified_permission_bound", Content: "package infraguard.rules.aliyun.ram_user_specified_permission_bound\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"ram-user-specified-permission-bound\",\n\t\"name\": {\n\t\t\"en\": \"RAM User Specified Permission Bound\",\n\t\t\"zh\": \"RAM 用户未绑定指定的高危权限\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RAM users do not have specified high-risk permissions bound.\",\n\t\t\"zh\": \"确保 RAM 用户绑定的权限策略配置中，不包含规则入参指定的高危权限配置。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"High-risk permissions can cause significant damage if misused.\",\n\t\t\"zh\": \"高危权限一旦被滥用可能造成重大损失。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Review and restrict user permissions to only what's necessary.\",\n\t\t\"zh\": \"审查并限制用户权限，仅授予必要的权限。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\nhigh_risk_actions := [\n\t\"ecs:DeleteInstance\",\n\t\"ecs:StopInstance\",\n\t\"oss:DeleteBucket\",\n\t\"oss:DeleteObject\",\n\t\"rds:DeleteDBInstance\",\n\t\"kms:DeleteKey\",\n\t\"ram:DeleteUser\",\n\t\"ram:DeletePolicy\",\n]\n\nis_admin_policy_name(policy_name) if {\n\tpolicy_name == \"AdministratorAccess\"\n}\n\nis_admin_policy_name(policy_name) if {\n\tcontains(policy_name, \"FullAccess\")\n\tcontains(policy_name, \"Admin\")\n}\n\nhas_admin_system_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tsystem_policies := object.get(policy_attachments, \"System\", [])\n\tsome policy in system_policies\n\tis_admin_policy_name(policy)\n}\n\nhas_admin_custom_policy(resource) if {\n\tpolicy_attachments := helpers.get_property(resource, \"PolicyAttachments\", {})\n\tcustom_policies := object.get(policy_attachments, \"Custom\", [])\n\tsome policy in custom_policies\n\tis_admin_policy_name(policy)\n}\n\nhas_admin_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy_name(policy_name)\n}\n\nhas_admin_policy_via_attachment(user_name) if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::AttachPolicyToUser\")\n\tuser_name_val := helpers.get_property(resource, \"UserName\", \"\")\n\thelpers.is_get_att_referencing(user_name_val, user_name)\n\tpolicy_name := helpers.get_property(resource, \"PolicyName\", \"\")\n\tis_admin_policy_name(policy_name)\n}\n\n# Get high risk actions from parameter or default\nget_high_risk_actions := actions if {\n\tactions := input.parameters.highRiskActions\n\tis_array(actions)\n} else := high_risk_actions\n\n# Check inline policies for high risk actions\nhas_inline_high_risk_permission(resource) if {\n\tpolicies := helpers.get_property(resource, \"Policies\", [])\n\tsome policy in policies\n\tdoc := object.get(policy, \"PolicyDocument\", {})\n\n\tstatements := object.get(doc, \"Statement\", [])\n\tsome statement in statements\n\teffect := object.get(statement, \"Effect\", \"\")\n\teffect == \"Allow\"\n\n\tactions := to_list(object.get(statement, \"Action\", []))\n\trequired_risks := get_high_risk_actions\n\n\tsome action in actions\n\tsome risk in required_risks\n\taction == risk\n}\n\nto_list(v) := v if is_array(v)\nto_list(v) := [v] if is_string(v)\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_inline_high_risk_permission(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\", \"Policies\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_admin_system_policy(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\", \"System\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_admin_custom_policy(resource)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\", \"PolicyAttachments\", \"Custom\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\ndeny contains result if {\n\tsome user_name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\n\thas_admin_policy_via_attachment(user_name)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": user_name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instacne-delete-protection-enabled", Name: models.I18nString{"en": "RDS Instance Deletion Protection Enabled", "zh": "RDS 实例开启删除保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that RDS instances have deletion protection enabled.", "zh": "确保 RDS 实例开启了删除保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the RDS instance may be released accidentally, causing data loss.", "zh": "如果未开启删除保护，RDS 实例可能会被意外释放，导致数据丢失。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the RDS instance.", "zh": "为 RDS 实例开启删除保护功能。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instacne-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.rds_instacne_delete_protection_enabled", Content: "package infraguard.rules.aliyun.rds_instacne_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"rds-instacne-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Deletion Protection Enabled\",\n\t\t\"zh\": \"RDS 实例开启删除保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RDS instances have deletion protection enabled.\",\n\t\t\"zh\": \"确保 RDS 实例开启了删除保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the RDS instance may be released accidentally, causing data loss.\",\n\t\t\"zh\": \"如果未开启删除保护，RDS 实例可能会被意外释放，导致数据丢失。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例开启删除保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-enabled-auditing", Name: models.I18nString{"en": "RDS Instance Auditing Enabled", "zh": "RDS 实例开启 SQL 审计"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RDS instances have SQL auditing enabled.", "zh": "确保 RDS 实例开启了 SQL 审计。"}, Reason: models.I18nString{"en": "SQL auditing helps track database activities and investigate security incidents.", "zh": "SQL 审计有助于跟踪数据库活动并调查安全事件。"}, Recommendation: models.I18nString{"en": "Enable SQL Collector for the RDS instance.", "zh": "为 RDS 实例开启 SQL 审计（SQL Collector）。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-enabled-auditing.rego", PackageName: "infraguard.rules.aliyun.rds_instance_enabled_auditing", Content: "package infraguard.rules.aliyun.rds_instance_enabled_auditing\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-enabled-auditing\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Auditing Enabled\",\n\t\t\"zh\": \"RDS 实例开启 SQL 审计\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS instances have SQL auditing enabled.\",\n\t\t\"zh\": \"确保 RDS 实例开启了 SQL 审计。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SQL auditing helps track database activities and investigate security incidents.\",\n\t\t\"zh\": \"SQL 审计有助于跟踪数据库活动并调查安全事件。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SQL Collector for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例开启 SQL 审计（SQL Collector）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.get_property(resource, \"SQLCollectorStatus\", \"Disabled\") == \"Enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SQLCollectorStatus\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-enabled-disk-encryption", Name: models.I18nString{"en": "RDS Instance Disk Encryption Enabled", "zh": "RDS 实例开启磁盘加密"}, Severity: "high", Description: models.I18nString{"en": "Ensures RDS instances have disk encryption enabled.", "zh": "确保 RDS 实例开启了磁盘加密。"}, Reason: models.I18nString{"en": "Disk encryption protects the underlying data storage from unauthorized physical access.", "zh": "磁盘加密保护底层数据存储免受未经授权的物理访问。"}, Recommendation: models.I18nString{"en": "Enable disk encryption for the RDS instance.", "zh": "为 RDS 实例开启磁盘加密。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-enabled-disk-encryption.rego", PackageName: "infraguard.rules.aliyun.rds_instance_enabled_disk_encryption", Content: "package infraguard.rules.aliyun.rds_instance_enabled_disk_encryption\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-enabled-disk-encryption\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Disk Encryption Enabled\",\n\t\t\"zh\": \"RDS 实例开启磁盘加密\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS instances have disk encryption enabled.\",\n\t\t\"zh\": \"确保 RDS 实例开启了磁盘加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Disk encryption protects the underlying data storage from unauthorized physical access.\",\n\t\t\"zh\": \"磁盘加密保护底层数据存储免受未经授权的物理访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable disk encryption for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例开启磁盘加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\t# EncryptionKey being set usually indicates disk encryption is enabled.\n\thelpers.has_property(resource, \"EncryptionKey\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EncryptionKey\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-enabled-log-backup", Name: models.I18nString{"en": "RDS Instance Log Backup Enabled", "zh": "RDS 实例开启日志备份"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RDS instances have log backup enabled.", "zh": "确保 RDS 实例开启了日志备份。"}, Reason: models.I18nString{"en": "Log backups are essential for point-in-time recovery of the database.", "zh": "日志备份对于数据库的增量恢复（Point-in-time recovery）至关重要。"}, Recommendation: models.I18nString{"en": "Enable log backup in the RDS backup policy.", "zh": "在 RDS 备份策略中开启日志备份。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-enabled-log-backup.rego", PackageName: "infraguard.rules.aliyun.rds_instance_enabled_log_backup", Content: "package infraguard.rules.aliyun.rds_instance_enabled_log_backup\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-enabled-log-backup\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Log Backup Enabled\",\n\t\t\"zh\": \"RDS 实例开启日志备份\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS instances have log backup enabled.\",\n\t\t\"zh\": \"确保 RDS 实例开启了日志备份。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Log backups are essential for point-in-time recovery of the database.\",\n\t\t\"zh\": \"日志备份对于数据库的增量恢复（Point-in-time recovery）至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable log backup in the RDS backup policy.\",\n\t\t\"zh\": \"在 RDS 备份策略中开启日志备份。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"EnableBackupLog\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EnableBackupLog\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-enabled-ssl", Name: models.I18nString{"en": "RDS Instance SSL Enabled", "zh": "RDS 实例开启 SSL 加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures RDS instances have SSL encryption enabled.", "zh": "确保 RDS 实例开启了 SSL 加密。"}, Reason: models.I18nString{"en": "SSL encryption protects data in transit from eavesdropping and tampering.", "zh": "SSL 加密可保护传输中的数据免受窃听和篡改。"}, Recommendation: models.I18nString{"en": "Enable SSL for the RDS instance.", "zh": "为 RDS 实例开启 SSL 加密。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-enabled-ssl.rego", PackageName: "infraguard.rules.aliyun.rds_instance_enabled_ssl", Content: "package infraguard.rules.aliyun.rds_instance_enabled_ssl\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-enabled-ssl\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance SSL Enabled\",\n\t\t\"zh\": \"RDS 实例开启 SSL 加密\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS instances have SSL encryption enabled.\",\n\t\t\"zh\": \"确保 RDS 实例开启了 SSL 加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL encryption protects data in transit from eavesdropping and tampering.\",\n\t\t\"zh\": \"SSL 加密可保护传输中的数据免受窃听和篡改。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SSL for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例开启 SSL 加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\tssl := helpers.get_property(resource, \"SSLSetting\", \"Disabled\")\n\tssl != \"Disabled\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SSLSetting\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-enabled-tde-disk-encryption", Name: models.I18nString{"en": "RDS Instance Enabled TDE or Disk Encryption", "zh": "RDS 实例开启 TDE 或者数据盘加密"}, Severity: "medium", Description: models.I18nString{"en": "RDS instance should have TDE (Transparent Data Encryption) or disk encryption enabled.", "zh": "RDS 实例开启 TDE 或者数据盘加密，视为合规。"}, Reason: models.I18nString{"en": "RDS instance does not have TDE or disk encryption enabled, which may expose data to security risks.", "zh": "RDS 实例未开启 TDE 或数据盘加密，可能导致数据面临安全风险。"}, Recommendation: models.I18nString{"en": "Enable TDE by configuring EncryptionKey or use encrypted storage types (cloud_essd, cloud_essd2, cloud_essd3) for the RDS instance.", "zh": "通过配置 EncryptionKey 开启 TDE，或为 RDS 实例使用加密存储类型（cloud_essd、cloud_essd2、cloud_essd3）。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance", "ALIYUN::RDS::PrepayDBInstance"}, FilePath: "aliyun/rules/rds-instance-enabled-tde-disk-encryption.rego", PackageName: "infraguard.rules.aliyun.rds_instance_enabled_tde_disk_encryption", Content: "package infraguard.rules.aliyun.rds_instance_enabled_tde_disk_encryption\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"rds-instance-enabled-tde-disk-encryption\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Enabled TDE or Disk Encryption\",\n\t\t\"zh\": \"RDS 实例开启 TDE 或者数据盘加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"RDS instance should have TDE (Transparent Data Encryption) or disk encryption enabled.\",\n\t\t\"zh\": \"RDS 实例开启 TDE 或者数据盘加密，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"RDS instance does not have TDE or disk encryption enabled, which may expose data to security risks.\",\n\t\t\"zh\": \"RDS 实例未开启 TDE 或数据盘加密，可能导致数据面临安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable TDE by configuring EncryptionKey or use encrypted storage types (cloud_essd, cloud_essd2, cloud_essd3) for the RDS instance.\",\n\t\t\"zh\": \"通过配置 EncryptionKey 开启 TDE，或为 RDS 实例使用加密存储类型（cloud_essd、cloud_essd2、cloud_essd3）。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\", \"ALIYUN::RDS::PrepayDBInstance\"],\n}\n\n# Encrypted storage types\nencrypted_storage_types := [\"cloud_essd\", \"cloud_essd2\", \"cloud_essd3\"]\n\n# Check if encryption is enabled (TDE via EncryptionKey or encrypted storage type)\nis_encryption_enabled(resource) if {\n\tresource.Properties.EncryptionKey != null\n}\n\nis_encryption_enabled(resource) if {\n\tresource.Properties.DBInstanceStorageType in encrypted_storage_types\n}\n\n# Generate deny for non-compliant RDS instance resources\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_encryption_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-expired-check", Name: models.I18nString{"en": "RDS Prepaid Instance Expiration Check", "zh": "RDS 预付费实例到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid RDS instances should have auto-renewal enabled.", "zh": "预付费 RDS 实例应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid RDS instance does not have auto-renewal enabled.", "zh": "预付费 RDS 实例未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid RDS instance by setting AutoRenew to true.", "zh": "通过将 AutoRenew 设置为 true 为预付费 RDS 实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-expired-check.rego", PackageName: "infraguard.rules.aliyun.rds_instance_expired_check", Content: "package infraguard.rules.aliyun.rds_instance_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"rds-instance-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"RDS Prepaid Instance Expiration Check\",\n\t\t\"zh\": \"RDS 预付费实例到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid RDS instances should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 RDS 实例应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid RDS instance does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 RDS 实例未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid RDS instance by setting AutoRenew to true.\",\n\t\t\"zh\": \"通过将 AutoRenew 设置为 true 为预付费 RDS 实例开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_prepaid(resource) if {\n\thelpers.get_property(resource, \"PayType\", \"Postpaid\") == \"Prepaid\"\n}\n\n# RDS AutoRenew property name is AutoRenew\nis_auto_renew_enabled(resource) if {\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", false)\n\thelpers.is_true(auto_renew)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-has-guard-instance", Name: models.I18nString{"en": "RDS Instance Has Guard Instance", "zh": "RDS 关键实例配置灾备实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures production RDS instances have a corresponding guard (disaster recovery) instance.", "zh": "确保生产环境 RDS 实例配置了相应的灾备实例。"}, Reason: models.I18nString{"en": "Guard instances provide high availability and data redundancy across regions.", "zh": "灾备实例提供跨地域的高可用性和数据冗余。"}, Recommendation: models.I18nString{"en": "Configure a guard instance for the primary RDS instance.", "zh": "为主要 RDS 实例配置灾备实例。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-has-guard-instance.rego", PackageName: "infraguard.rules.aliyun.rds_instance_has_guard_instance", Content: "package infraguard.rules.aliyun.rds_instance_has_guard_instance\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-has-guard-instance\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Has Guard Instance\",\n\t\t\"zh\": \"RDS 关键实例配置灾备实例\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures production RDS instances have a corresponding guard (disaster recovery) instance.\",\n\t\t\"zh\": \"确保生产环境 RDS 实例配置了相应的灾备实例。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Guard instances provide high availability and data redundancy across regions.\",\n\t\t\"zh\": \"灾备实例提供跨地域的高可用性和数据冗余。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a guard instance for the primary RDS instance.\",\n\t\t\"zh\": \"为主要 RDS 实例配置灾备实例。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\n# Cross-resource check: is there another RDS instance or DR resource linked?\n# Simplified for static check: check if it's a high availability category\nis_compliant(resource) if {\n\tcat := helpers.get_property(resource, \"Category\", \"\")\n\thelpers.includes([\"HighAvailability\", \"cluster\", \"AlwaysOn\", \"Finance\"], cat)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Category\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-maintain-time-check", Name: models.I18nString{"en": "RDS Instance Maintenance Window Check", "zh": "RDS 实例维护时间检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that the RDS instance has a maintenance window configured.", "zh": "确保 RDS 实例配置了维护时间段。"}, Reason: models.I18nString{"en": "Configuring a maintenance window allows for planned maintenance during off-peak hours.", "zh": "配置维护时间段允许在非高峰时段进行计划内维护。"}, Recommendation: models.I18nString{"en": "Configure a maintenance window for the RDS instance.", "zh": "为 RDS 实例配置维护时间段。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-maintain-time-check.rego", PackageName: "infraguard.rules.aliyun.rds_instance_maintain_time_check", Content: "package infraguard.rules.aliyun.rds_instance_maintain_time_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"rds-instance-maintain-time-check\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Maintenance Window Check\",\n\t\t\"zh\": \"RDS 实例维护时间检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the RDS instance has a maintenance window configured.\",\n\t\t\"zh\": \"确保 RDS 实例配置了维护时间段。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Configuring a maintenance window allows for planned maintenance during off-peak hours.\",\n\t\t\"zh\": \"配置维护时间段允许在非高峰时段进行计划内维护。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a maintenance window for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例配置维护时间段。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot helpers.has_property(resource, \"MaintainTime\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MaintainTime\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instance-storage-autoscale-enable", Name: models.I18nString{"en": "RDS Storage Autoscale Enabled", "zh": "RDS 开启存储自动扩容"}, Severity: "low", Description: models.I18nString{"en": "Ensures RDS instances have storage autoscale enabled to prevent downtime due to full disks.", "zh": "确保 RDS 实例开启了存储自动扩容，以防止因磁盘满载导致的服务中断。"}, Reason: models.I18nString{"en": "Automatic scaling ensures that the database doesn't run out of storage space.", "zh": "自动扩容确保数据库不会因存储空间耗尽而受限。"}, Recommendation: models.I18nString{"en": "Set StorageAutoScale to 'Enable' for the RDS instance.", "zh": "为 RDS 实例将 StorageAutoScale 设置为 'Enable'。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instance-storage-autoscale-enable.rego", PackageName: "infraguard.rules.aliyun.rds_instance_storage_autoscale_enable", Content: "package infraguard.rules.aliyun.rds_instance_storage_autoscale_enable\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-instance-storage-autoscale-enable\",\n\t\"name\": {\n\t\t\"en\": \"RDS Storage Autoscale Enabled\",\n\t\t\"zh\": \"RDS 开启存储自动扩容\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS instances have storage autoscale enabled to prevent downtime due to full disks.\",\n\t\t\"zh\": \"确保 RDS 实例开启了存储自动扩容，以防止因磁盘满载导致的服务中断。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Automatic scaling ensures that the database doesn't run out of storage space.\",\n\t\t\"zh\": \"自动扩容确保数据库不会因存储空间耗尽而受限。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set StorageAutoScale to 'Enable' for the RDS instance.\",\n\t\t\"zh\": \"为 RDS 实例将 StorageAutoScale 设置为 'Enable'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.get_property(resource, \"StorageAutoScale\", \"Disable\") == \"Enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"StorageAutoScale\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-instances-in-vpc", Name: models.I18nString{"en": "RDS Instance in VPC", "zh": "RDS 实例在 VPC 内"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the RDS instance is deployed within a VPC.", "zh": "确保 RDS 实例部署在 VPC 内。"}, Reason: models.I18nString{"en": "Deploying RDS in a VPC provides better network isolation and security.", "zh": "在 VPC 中部署 RDS 可提供更好的网络隔离和安全性。"}, Recommendation: models.I18nString{"en": "Deploy the RDS instance within a VPC.", "zh": "将 RDS 实例部署在 VPC 内。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-instances-in-vpc.rego", PackageName: "infraguard.rules.aliyun.rds_instances_in_vpc", Content: "package infraguard.rules.aliyun.rds_instances_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"rds-instances-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance in VPC\",\n\t\t\"zh\": \"RDS 实例在 VPC 内\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the RDS instance is deployed within a VPC.\",\n\t\t\"zh\": \"确保 RDS 实例部署在 VPC 内。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Deploying RDS in a VPC provides better network isolation and security.\",\n\t\t\"zh\": \"在 VPC 中部署 RDS 可提供更好的网络隔离和安全性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy the RDS instance within a VPC.\",\n\t\t\"zh\": \"将 RDS 实例部署在 VPC 内。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot helpers.has_property(resource, \"VPCId\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VPCId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-multi-az-support", Name: models.I18nString{"en": "RDS Instance Multi-AZ Deployment", "zh": "RDS 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "RDS instances should be deployed in multi-AZ configuration for high availability and automatic failover.", "zh": "RDS 实例应部署在多可用区配置中，以实现高可用性和自动故障转移。"}, Reason: models.I18nString{"en": "The RDS instance is not deployed in multi-AZ configuration, which may affect availability during zone failures.", "zh": "RDS 实例未部署在多可用区配置中，在可用区故障时可能影响可用性。"}, Recommendation: models.I18nString{"en": "Enable multi-AZ deployment by setting MultiAZ to true when creating the instance.", "zh": "在创建实例时通过将 MultiAZ 设置为 true 来启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-multi-az-support.rego", PackageName: "infraguard.rules.aliyun.rds_multi_az_support", Content: "package infraguard.rules.aliyun.rds_multi_az_support\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"rds-multi-az-support\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Multi-AZ Deployment\",\n\t\t\"zh\": \"RDS 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"RDS instances should be deployed in multi-AZ configuration for high availability and automatic failover.\",\n\t\t\"zh\": \"RDS 实例应部署在多可用区配置中，以实现高可用性和自动故障转移。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The RDS instance is not deployed in multi-AZ configuration, which may affect availability during zone failures.\",\n\t\t\"zh\": \"RDS 实例未部署在多可用区配置中，在可用区故障时可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable multi-AZ deployment by setting MultiAZ to true when creating the instance.\",\n\t\t\"zh\": \"在创建实例时通过将 MultiAZ 设置为 true 来启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\n# Check if instance has multi-AZ enabled\nhas_multi_az_enabled(resource) if {\n\tmulti_az := helpers.get_property(resource, \"MultiAZ\", false)\n\tmulti_az == true\n}\n\n# Deny rule: RDS instances should have multi-AZ enabled\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot has_multi_az_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MultiAZ\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-public-access-check", Name: models.I18nString{"en": "RDS Instance Public Access Check", "zh": "RDS 实例不配置公网地址"}, Severity: "high", Description: models.I18nString{"en": "RDS instances should not be configured with public network addresses. Public access exposes databases to potential security threats from the internet.", "zh": "RDS 实例不应配置公网地址。公网访问会使数据库暴露于来自互联网的潜在安全威胁。"}, Reason: models.I18nString{"en": "The RDS instance is configured with public network access, which exposes the database to security risks from the internet.", "zh": "RDS 实例配置了公网访问，使数据库暴露于来自互联网的安全风险。"}, Recommendation: models.I18nString{"en": "Disable public network access for the RDS instance by setting AllocatePublicConnection to false or not configuring it.", "zh": "通过将 AllocatePublicConnection 设置为 false 或不配置该属性，禁用 RDS 实例的公网访问。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-public-access-check.rego", PackageName: "infraguard.rules.aliyun.rds_public_access_check", Content: "package infraguard.rules.aliyun.rds_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"rds-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"RDS Instance Public Access Check\",\n\t\t\"zh\": \"RDS 实例不配置公网地址\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"RDS instances should not be configured with public network addresses. Public access exposes databases to potential security threats from the internet.\",\n\t\t\"zh\": \"RDS 实例不应配置公网地址。公网访问会使数据库暴露于来自互联网的潜在安全威胁。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The RDS instance is configured with public network access, which exposes the database to security risks from the internet.\",\n\t\t\"zh\": \"RDS 实例配置了公网访问，使数据库暴露于来自互联网的安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public network access for the RDS instance by setting AllocatePublicConnection to false or not configuring it.\",\n\t\t\"zh\": \"通过将 AllocatePublicConnection 设置为 false 或不配置该属性，禁用 RDS 实例的公网访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\thas_public_access(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AllocatePublicConnection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\nhas_public_access(resource) if {\n\tresource.Properties.AllocatePublicConnection == true\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-public-connection-and-any-ip-access-check", Name: models.I18nString{"en": "RDS Public Connection and Any IP Access Check", "zh": "开启公网 IP 的 RDS 实例白名单未对所有来源开放"}, Severity: "high", Description: models.I18nString{"en": "Ensures that RDS instances with public connections do not have a whitelist open to all IPs.", "zh": "确保开启公网 IP 的 RDS 实例白名单未设置为对所有来源 IP 开放。"}, Reason: models.I18nString{"en": "An open whitelist combined with a public connection exposes the database to the internet, creating a high security risk.", "zh": "公网连接配合开放白名单会将数据库暴露在互联网上，造成极高的安全风险。"}, Recommendation: models.I18nString{"en": "Disable public connection or restrict the IP whitelist for the RDS instance.", "zh": "禁用 RDS 实例的公网连接或限制 IP 白名单。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-public-connection-and-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.rds_public_connection_and_any_ip_access_check", Content: "package infraguard.rules.aliyun.rds_public_connection_and_any_ip_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"rds-public-connection-and-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"RDS Public Connection and Any IP Access Check\",\n\t\t\"zh\": \"开启公网 IP 的 RDS 实例白名单未对所有来源开放\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that RDS instances with public connections do not have a whitelist open to all IPs.\",\n\t\t\"zh\": \"确保开启公网 IP 的 RDS 实例白名单未设置为对所有来源 IP 开放。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"An open whitelist combined with a public connection exposes the database to the internet, creating a high security risk.\",\n\t\t\"zh\": \"公网连接配合开放白名单会将数据库暴露在互联网上，造成极高的安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public connection or restrict the IP whitelist for the RDS instance.\",\n\t\t\"zh\": \"禁用 RDS 实例的公网连接或限制 IP 白名单。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\t# If public connection is not enabled, it's compliant\n\tnot helpers.is_true(helpers.get_property(resource, \"AllocatePublicConnection\", false))\n}\n\nis_compliant(resource) if {\n\t# If public connection is enabled, check the whitelist\n\thelpers.is_true(helpers.get_property(resource, \"AllocatePublicConnection\", false))\n\twhitelist_str := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\twhitelist := split(whitelist_str, \",\")\n\tnot has_open_cidr(whitelist)\n}\n\nhas_open_cidr(whitelist) if {\n\tsome cidr in whitelist\n\thelpers.is_public_cidr(trim_space(cidr))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPList\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rds-white-list-internet-ip-access-check", Name: models.I18nString{"en": "RDS Whitelist Internet Restriction", "zh": "RDS 白名单禁用公网开放"}, Severity: "high", Description: models.I18nString{"en": "Ensures RDS security IP whitelists do not contain 0.0.0.0/0.", "zh": "确保 RDS 安全 IP 白名单中不包含 0.0.0.0/0。"}, Reason: models.I18nString{"en": "Allowing 0.0.0.0/0 in the whitelist exposes the database to all public internet traffic.", "zh": "在白名单中允许 0.0.0.0/0 会使数据库暴露给所有的公网流量。"}, Recommendation: models.I18nString{"en": "Remove 0.0.0.0/0 from the RDS security IP list and use specific trusted IPs.", "zh": "从 RDS 安全 IP 列表中移除 0.0.0.0/0，并使用特定的可信 IP。"}, ResourceTypes: []string{"ALIYUN::RDS::DBInstance"}, FilePath: "aliyun/rules/rds-white-list-internet-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.rds_white_list_internet_ip_access_check", Content: "package infraguard.rules.aliyun.rds_white_list_internet_ip_access_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"rds-white-list-internet-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"RDS Whitelist Internet Restriction\",\n\t\t\"zh\": \"RDS 白名单禁用公网开放\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures RDS security IP whitelists do not contain 0.0.0.0/0.\",\n\t\t\"zh\": \"确保 RDS 安全 IP 白名单中不包含 0.0.0.0/0。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Allowing 0.0.0.0/0 in the whitelist exposes the database to all public internet traffic.\",\n\t\t\"zh\": \"在白名单中允许 0.0.0.0/0 会使数据库暴露给所有的公网流量。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove 0.0.0.0/0 from the RDS security IP list and use specific trusted IPs.\",\n\t\t\"zh\": \"从 RDS 安全 IP 列表中移除 0.0.0.0/0，并使用特定的可信 IP。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::RDS::DBInstance\"],\n}\n\nis_compliant(resource) if {\n\twhitelist_str := helpers.get_property(resource, \"SecurityIPList\", \"\")\n\twhitelist := split(whitelist_str, \",\")\n\tnot has_public_ip(whitelist)\n}\n\nhas_public_ip(whitelist) if {\n\tsome ip in whitelist\n\thelpers.is_public_cidr(trim_space(ip))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RDS::DBInstance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIPList\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-architecturetype-cluster-check", Name: models.I18nString{"en": "Redis Architecture Type Cluster Check", "zh": "使用集群版的 Redis 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instance uses cluster architecture type.", "zh": "确保 Redis 实例的架构类型为集群版。"}, Reason: models.I18nString{"en": "Cluster architecture provides better scalability and high availability.", "zh": "集群架构提供更好的可扩展性和高可用性。"}, Recommendation: models.I18nString{"en": "Use cluster architecture for Redis instance.", "zh": "为 Redis 实例使用集群架构。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-architecturetype-cluster-check.rego", PackageName: "infraguard.rules.aliyun.redis_architecturetype_cluster_check", Content: "package infraguard.rules.aliyun.redis_architecturetype_cluster_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-architecturetype-cluster-check\",\n\t\"name\": {\n\t\t\"en\": \"Redis Architecture Type Cluster Check\",\n\t\t\"zh\": \"使用集群版的 Redis 实例\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance uses cluster architecture type.\",\n\t\t\"zh\": \"确保 Redis 实例的架构类型为集群版。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Cluster architecture provides better scalability and high availability.\",\n\t\t\"zh\": \"集群架构提供更好的可扩展性和高可用性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use cluster architecture for Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例使用集群架构。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tinstance_class := helpers.get_property(resource, \"InstanceClass\", \"\")\n\tcontains(instance_class, \"cluster\")\n}\n\nis_compliant(resource) if {\n\tshard_count := helpers.get_property(resource, \"ShardCount\", 1)\n\tshard_count >= 2\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ShardCount\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-backup-log-enabled", Name: models.I18nString{"en": "Redis Instance Backup Log Enabled", "zh": "Redis 实例开启日志备份"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that log backup is enabled for the Redis instance.", "zh": "确保 Redis 实例开启了日志备份。"}, Reason: models.I18nString{"en": "Enabling log backup allows for point-in-time recovery of the database.", "zh": "开启日志备份允许对数据库进行按时间点恢复。"}, Recommendation: models.I18nString{"en": "Enable log backup for the Redis instance.", "zh": "为 Redis 实例开启日志备份。"}, ResourceTypes: []string{"ALIYUN::Redis::DBInstance"}, FilePath: "aliyun/rules/redis-instance-backup-log-enabled.rego", PackageName: "infraguard.rules.aliyun.redis_instance_backup_log_enabled", Content: "package infraguard.rules.aliyun.redis_instance_backup_log_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"redis-instance-backup-log-enabled\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance Backup Log Enabled\",\n\t\t\"zh\": \"Redis 实例开启日志备份\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that log backup is enabled for the Redis instance.\",\n\t\t\"zh\": \"确保 Redis 实例开启了日志备份。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Enabling log backup allows for point-in-time recovery of the database.\",\n\t\t\"zh\": \"开启日志备份允许对数据库进行按时间点恢复。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable log backup for the Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例开启日志备份。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::Redis::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Redis::DBInstance\")\n\n\t# Conceptual check\n\tnot helpers.get_property(resource, \"AppendOnly\", \"no\") == \"yes\"\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AppendOnly\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-backup-time-check", Name: models.I18nString{"en": "Redis Instance Backup Window Check", "zh": "Redis 实例备份时间检测"}, Severity: "low", Description: models.I18nString{"en": "Ensures that the Redis instance has a backup window configured.", "zh": "确保 Redis 实例配置了备份时间段。"}, Reason: models.I18nString{"en": "Configuring a backup window ensures that backups are taken during off-peak hours.", "zh": "配置备份时间段可确保在非高峰时段进行备份。"}, Recommendation: models.I18nString{"en": "Configure a backup window for the Redis instance.", "zh": "为 Redis 实例配置备份时间段。"}, ResourceTypes: []string{"ALIYUN::Redis::DBInstance"}, FilePath: "aliyun/rules/redis-instance-backup-time-check.rego", PackageName: "infraguard.rules.aliyun.redis_instance_backup_time_check", Content: "package infraguard.rules.aliyun.redis_instance_backup_time_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"redis-instance-backup-time-check\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance Backup Window Check\",\n\t\t\"zh\": \"Redis 实例备份时间检测\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the Redis instance has a backup window configured.\",\n\t\t\"zh\": \"确保 Redis 实例配置了备份时间段。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Configuring a backup window ensures that backups are taken during off-peak hours.\",\n\t\t\"zh\": \"配置备份时间段可确保在非高峰时段进行备份。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a backup window for the Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例配置备份时间段。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::Redis::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Redis::DBInstance\")\n\tnot helpers.has_property(resource, \"BackupTime\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"BackupTime\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-double-node-type", Name: models.I18nString{"en": "Redis Instance Double Node Type", "zh": "Redis 实例节点类型为双副本"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instance uses double node type for high availability.", "zh": "确保 Redis 实例使用双副本节点类型以确保高可用性。"}, Reason: models.I18nString{"en": "Double node type provides high availability through replication.", "zh": "双副本类型通过复制提供高可用性。"}, Recommendation: models.I18nString{"en": "Use double node type for Redis instance.", "zh": "为 Redis 实例使用双副本节点类型。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-double-node-type.rego", PackageName: "infraguard.rules.aliyun.redis_instance_double_node_type", Content: "package infraguard.rules.aliyun.redis_instance_double_node_type\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-double-node-type\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance Double Node Type\",\n\t\t\"zh\": \"Redis 实例节点类型为双副本\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance uses double node type for high availability.\",\n\t\t\"zh\": \"确保 Redis 实例使用双副本节点类型以确保高可用性。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Double node type provides high availability through replication.\",\n\t\t\"zh\": \"双副本类型通过复制提供高可用性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use double node type for Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例使用双副本节点类型。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tnode_type := helpers.get_property(resource, \"NodeType\", \"Double\")\n\tnode_type == \"Double\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"NodeType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-enabled-byok-tde", Name: models.I18nString{"en": "Redis Instance BYOK TDE Enabled", "zh": "Redis 实例开启 BYOK TDE 加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that Redis instances have Transparent Data Encryption (TDE) enabled using Bring Your Own Key (BYOK).", "zh": "确保 Redis 实例已使用自带密钥(BYOK)开启了透明数据加密(TDE)。"}, Reason: models.I18nString{"en": "TDE protects data at rest, and BYOK allows you to maintain control over the encryption keys.", "zh": "TDE 可保护静态数据，而 BYOK 允许您保持对加密密钥的控制。"}, Recommendation: models.I18nString{"en": "Enable TDE for the Redis instance using a KMS key.", "zh": "使用 KMS 密钥为 Redis 实例开启 TDE。"}, ResourceTypes: []string{"ALIYUN::Redis::DBInstance"}, FilePath: "aliyun/rules/redis-instance-enabled-byok-tde.rego", PackageName: "infraguard.rules.aliyun.redis_instance_enabled_byok_tde", Content: "package infraguard.rules.aliyun.redis_instance_enabled_byok_tde\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"redis-instance-enabled-byok-tde\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance BYOK TDE Enabled\",\n\t\t\"zh\": \"Redis 实例开启 BYOK TDE 加密\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Redis instances have Transparent Data Encryption (TDE) enabled using Bring Your Own Key (BYOK).\",\n\t\t\"zh\": \"确保 Redis 实例已使用自带密钥(BYOK)开启了透明数据加密(TDE)。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"TDE protects data at rest, and BYOK allows you to maintain control over the encryption keys.\",\n\t\t\"zh\": \"TDE 可保护静态数据，而 BYOK 允许您保持对加密密钥的控制。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable TDE for the Redis instance using a KMS key.\",\n\t\t\"zh\": \"使用 KMS 密钥为 Redis 实例开启 TDE。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::Redis::DBInstance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::Redis::DBInstance\")\n\n\t# Conceptual check for TDE\n\tnot helpers.has_property(resource, \"TDEStatus\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-enabled-ssl", Name: models.I18nString{"en": "Redis Instance SSL Enabled", "zh": "Redis 实例开启 SSL 加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instances have SSL encryption enabled.", "zh": "确保 Redis 实例开启了 SSL 加密。"}, Reason: models.I18nString{"en": "SSL encryption protects Redis data in transit from being intercepted.", "zh": "SSL 加密保护传输中的 Redis 数据不被截获。"}, Recommendation: models.I18nString{"en": "Enable SSL for the Redis instance.", "zh": "为 Redis 实例开启 SSL 加密。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-enabled-ssl.rego", PackageName: "infraguard.rules.aliyun.redis_instance_enabled_ssl", Content: "package infraguard.rules.aliyun.redis_instance_enabled_ssl\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"redis-instance-enabled-ssl\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance SSL Enabled\",\n\t\t\"zh\": \"Redis 实例开启 SSL 加密\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instances have SSL encryption enabled.\",\n\t\t\"zh\": \"确保 Redis 实例开启了 SSL 加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL encryption protects Redis data in transit from being intercepted.\",\n\t\t\"zh\": \"SSL 加密保护传输中的 Redis 数据不被截获。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SSL for the Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例开启 SSL 加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tssl := helpers.get_property(resource, \"SSLEnabled\", \"Disable\")\n\tssl == \"Enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SSLEnabled\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-expired-check", Name: models.I18nString{"en": "Redis Prepaid Instance Expiration Check", "zh": "Redis 预付费实例到期检查"}, Severity: "high", Description: models.I18nString{"en": "Prepaid Redis instances should have auto-renewal enabled.", "zh": "预付费 Redis 实例应开启自动续费，避免业务中断。"}, Reason: models.I18nString{"en": "The prepaid Redis instance does not have auto-renewal enabled.", "zh": "预付费 Redis 实例未开启自动续费。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for the prepaid Redis instance by setting AutoRenewDuration.", "zh": "通过设置 AutoRenewDuration 为预付费 Redis 实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-expired-check.rego", PackageName: "infraguard.rules.aliyun.redis_instance_expired_check", Content: "package infraguard.rules.aliyun.redis_instance_expired_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-expired-check\",\n\t\"name\": {\n\t\t\"en\": \"Redis Prepaid Instance Expiration Check\",\n\t\t\"zh\": \"Redis 预付费实例到期检查\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid Redis instances should have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 Redis 实例应开启自动续费，避免业务中断。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The prepaid Redis instance does not have auto-renewal enabled.\",\n\t\t\"zh\": \"预付费 Redis 实例未开启自动续费。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for the prepaid Redis instance by setting AutoRenewDuration.\",\n\t\t\"zh\": \"通过设置 AutoRenewDuration 为预付费 Redis 实例开启自动续费。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_prepaid(resource) if {\n\thelpers.get_property(resource, \"ChargeType\", \"PostPaid\") == \"PrePaid\"\n}\n\n# Redis uses AutoRenewDuration for auto-renewal configuration\nis_auto_renew_enabled(resource) if {\n\tduration := helpers.get_property(resource, \"AutoRenewDuration\", 0)\n\tduration > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tis_prepaid(resource)\n\tnot is_auto_renew_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenewDuration\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-in-vpc", Name: models.I18nString{"en": "Redis Instance in VPC", "zh": "使用专有网络类型的 Redis 实例"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instance is deployed in a VPC.", "zh": "确保 Redis 实例部署在专有网络中。"}, Reason: models.I18nString{"en": "VPC provides better network isolation and security.", "zh": "VPC 提供更好的网络隔离和安全性。"}, Recommendation: models.I18nString{"en": "Deploy Redis instance in a VPC.", "zh": "将 Redis 部署在专有网络中。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-in-vpc.rego", PackageName: "infraguard.rules.aliyun.redis_instance_in_vpc", Content: "package infraguard.rules.aliyun.redis_instance_in_vpc\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance in VPC\",\n\t\t\"zh\": \"使用专有网络类型的 Redis 实例\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance is deployed in a VPC.\",\n\t\t\"zh\": \"确保 Redis 实例部署在专有网络中。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"VPC provides better network isolation and security.\",\n\t\t\"zh\": \"VPC 提供更好的网络隔离和安全性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Deploy Redis instance in a VPC.\",\n\t\t\"zh\": \"将 Redis 部署在专有网络中。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tvpc_id := helpers.get_property(resource, \"VpcId\", \"\")\n\tvpc_id != \"\"\n}\n\nis_compliant(resource) if {\n\tvswitch_id := helpers.get_property(resource, \"VSwitchId\", \"\")\n\tvswitch_id != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-multi-zone", Name: models.I18nString{"en": "Redis Instance Multi-Zone Deployment", "zh": "Redis 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "Redis instances should be deployed across multiple availability zones for high availability.", "zh": "Redis 实例应部署在多个可用区。"}, Reason: models.I18nString{"en": "The Redis instance is not configured with a secondary zone.", "zh": "Redis 实例未配置备用可用区。"}, Recommendation: models.I18nString{"en": "Configure SecondaryZoneId to enable multi-zone deployment.", "zh": "配置 SecondaryZoneId 以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.redis_instance_multi_zone", Content: "package infraguard.rules.aliyun.redis_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"redis-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"Redis 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Redis instances should be deployed across multiple availability zones for high availability.\",\n\t\t\"zh\": \"Redis 实例应部署在多个可用区。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Redis instance is not configured with a secondary zone.\",\n\t\t\"zh\": \"Redis 实例未配置备用可用区。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure SecondaryZoneId to enable multi-zone deployment.\",\n\t\t\"zh\": \"配置 SecondaryZoneId 以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\n# Check if instance is multi-zone\nis_multi_zone(resource) if {\n\t# Check if SecondaryZoneId is present and not empty\n\tobject.get(resource.Properties, \"SecondaryZoneId\", \"\") != \"\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecondaryZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-no-public-ip", Name: models.I18nString{"en": "Redis Instance No Public IP", "zh": "Redis 实例未设置公网 IP"}, Severity: "high", Description: models.I18nString{"en": "Ensures Redis instance does not have public IP assigned.", "zh": "确保 Redis 实例未设置公网 IP。"}, Reason: models.I18nString{"en": "Public IP exposes Redis instance to internet attacks.", "zh": "公网 IP 使 Redis 实例暴露于互联网攻击。"}, Recommendation: models.I18nString{"en": "Remove public IP from the Redis instance.", "zh": "移除 Redis 实例的公网 IP。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-no-public-ip.rego", PackageName: "infraguard.rules.aliyun.redis_instance_no_public_ip", Content: "package infraguard.rules.aliyun.redis_instance_no_public_ip\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-no-public-ip\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance No Public IP\",\n\t\t\"zh\": \"Redis 实例未设置公网 IP\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance does not have public IP assigned.\",\n\t\t\"zh\": \"确保 Redis 实例未设置公网 IP。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public IP exposes Redis instance to internet attacks.\",\n\t\t\"zh\": \"公网 IP 使 Redis 实例暴露于互联网攻击。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove public IP from the Redis instance.\",\n\t\t\"zh\": \"移除 Redis 实例的公网 IP。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tconnections := helpers.get_property(resource, \"Connections\", {})\n\tobject.get(connections, \"PublicConnection\", null) == null\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Connections\", \"PublicConnection\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-open-auth-mode", Name: models.I18nString{"en": "Redis Authentication Mode Enabled", "zh": "Redis 强制开启认证模式"}, Severity: "high", Description: models.I18nString{"en": "Ensures Redis instances require authentication and are not in 'no-password' mode.", "zh": "确保 Redis 实例需要身份验证，且不处于'免密'模式。"}, Reason: models.I18nString{"en": "Disabling authentication allows anyone with network access to read or modify your Redis data.", "zh": "禁用身份验证会允许任何拥有网络访问权限的人读取或修改您的 Redis 数据。"}, Recommendation: models.I18nString{"en": "Enable password authentication for the Redis instance.", "zh": "为 Redis 实例启用密码身份验证。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-open-auth-mode.rego", PackageName: "infraguard.rules.aliyun.redis_instance_open_auth_mode", Content: "package infraguard.rules.aliyun.redis_instance_open_auth_mode\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"redis-instance-open-auth-mode\",\n\t\"name\": {\n\t\t\"en\": \"Redis Authentication Mode Enabled\",\n\t\t\"zh\": \"Redis 强制开启认证模式\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instances require authentication and are not in 'no-password' mode.\",\n\t\t\"zh\": \"确保 Redis 实例需要身份验证，且不处于'免密'模式。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Disabling authentication allows anyone with network access to read or modify your Redis data.\",\n\t\t\"zh\": \"禁用身份验证会允许任何拥有网络访问权限的人读取或修改您的 Redis 数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable password authentication for the Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例启用密码身份验证。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# In ROS, password free mode is controlled by VpcPasswordFree\n\thelpers.is_false(helpers.get_property(resource, \"VpcPasswordFree\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcPasswordFree\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-release-protection", Name: models.I18nString{"en": "Redis Instance Release Protection Enabled", "zh": "Redis 实例开启释放保护"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that Redis instances have release protection enabled.", "zh": "确保 Redis 实例开启了释放保护。"}, Reason: models.I18nString{"en": "If release protection is not enabled, the Redis instance may be released accidentally, causing service interruption.", "zh": "如果未开启释放保护，Redis 实例可能会被意外释放，导致业务中断。"}, Recommendation: models.I18nString{"en": "Enable release protection for the Redis instance.", "zh": "为 Redis 实例开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-release-protection.rego", PackageName: "infraguard.rules.aliyun.redis_instance_release_protection", Content: "package infraguard.rules.aliyun.redis_instance_release_protection\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-release-protection\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance Release Protection Enabled\",\n\t\t\"zh\": \"Redis 实例开启释放保护\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Redis instances have release protection enabled.\",\n\t\t\"zh\": \"确保 Redis 实例开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If release protection is not enabled, the Redis instance may be released accidentally, causing service interruption.\",\n\t\t\"zh\": \"如果未开启释放保护，Redis 实例可能会被意外释放，导致业务中断。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable release protection for the Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-instance-tls-version-check", Name: models.I18nString{"en": "Redis Instance TLS Version Check", "zh": "Redis 实例开启 SSL 并使用指定的 TLS 版本"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instance has SSL enabled with acceptable TLS version.", "zh": "确保 Redis 实例开启 SSL 且使用的 TLS 版本在可接受范围内。"}, Reason: models.I18nString{"en": "Using strong TLS versions ensures secure communication.", "zh": "使用强 TLS 版本确保通信安全。"}, Recommendation: models.I18nString{"en": "Enable SSL with recommended TLS version for Redis instance.", "zh": "为 Redis 实例启用 SSL 并使用推荐的 TLS 版本。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-instance-tls-version-check.rego", PackageName: "infraguard.rules.aliyun.redis_instance_tls_version_check", Content: "package infraguard.rules.aliyun.redis_instance_tls_version_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-instance-tls-version-check\",\n\t\"name\": {\n\t\t\"en\": \"Redis Instance TLS Version Check\",\n\t\t\"zh\": \"Redis 实例开启 SSL 并使用指定的 TLS 版本\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance has SSL enabled with acceptable TLS version.\",\n\t\t\"zh\": \"确保 Redis 实例开启 SSL 且使用的 TLS 版本在可接受范围内。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using strong TLS versions ensures secure communication.\",\n\t\t\"zh\": \"使用强 TLS 版本确保通信安全。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable SSL with recommended TLS version for Redis instance.\",\n\t\t\"zh\": \"为 Redis 实例启用 SSL 并使用推荐的 TLS 版本。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tssl_enabled := helpers.get_property(resource, \"SSLEnabled\", \"Disable\")\n\tssl_enabled == \"Enable\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SSLEnabled\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-min-capacity-limit", Name: models.I18nString{"en": "Redis Min Capacity Limit", "zh": "Redis 实例满足指定内存容量要求"}, Severity: "medium", Description: models.I18nString{"en": "Ensures Redis instance has memory capacity meeting the minimum requirement.", "zh": "确保 Redis 实例内存总量大于等于指定的参数值。"}, Reason: models.I18nString{"en": "Adequate memory ensures Redis can handle the workload.", "zh": "充足的内存确保 Redis 能够处理工作负载。"}, Recommendation: models.I18nString{"en": "Ensure Redis instance has minimum required memory capacity.", "zh": "确保 Redis 实例满足最低内存容量要求。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-min-capacity-limit.rego", PackageName: "infraguard.rules.aliyun.redis_min_capacity_limit", Content: "package infraguard.rules.aliyun.redis_min_capacity_limit\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-min-capacity-limit\",\n\t\"name\": {\n\t\t\"en\": \"Redis Min Capacity Limit\",\n\t\t\"zh\": \"Redis 实例满足指定内存容量要求\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures Redis instance has memory capacity meeting the minimum requirement.\",\n\t\t\"zh\": \"确保 Redis 实例内存总量大于等于指定的参数值。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Adequate memory ensures Redis can handle the workload.\",\n\t\t\"zh\": \"充足的内存确保 Redis 能够处理工作负载。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure Redis instance has minimum required memory capacity.\",\n\t\t\"zh\": \"确保 Redis 实例满足最低内存容量要求。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\tcapacity := helpers.get_property(resource, \"Capacity\", 1024)\n\tcapacity >= 1024\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Capacity\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:redis-public-and-any-ip-access-check", Name: models.I18nString{"en": "Redis Public and Any IP Access Check", "zh": "Redis 实例不开启公网或安全白名单不设置为允许任意来源访问"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Redis instances do not have public access enabled or an open whitelist.", "zh": "确保 Redis 实例未开启公网访问，或者白名单未设置为对所有 IP 开放。"}, Reason: models.I18nString{"en": "Public access to Redis is a severe security risk, as it is often targets for brute force attacks and data theft.", "zh": "Redis 的公网访问是一个严重的安全风险，因为它经常成为暴力破解攻击和数据窃取的方目标。"}, Recommendation: models.I18nString{"en": "Disable public connection for the Redis instance and restrict access via IP whitelists.", "zh": "禁用 Redis 实例的公网连接，并通过 IP 白名单限制访问。"}, ResourceTypes: []string{"ALIYUN::REDIS::Instance"}, FilePath: "aliyun/rules/redis-public-and-any-ip-access-check.rego", PackageName: "infraguard.rules.aliyun.redis_public_and_any_ip_access_check", Content: "package infraguard.rules.aliyun.redis_public_and_any_ip_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"redis-public-and-any-ip-access-check\",\n\t\"name\": {\n\t\t\"en\": \"Redis Public and Any IP Access Check\",\n\t\t\"zh\": \"Redis 实例不开启公网或安全白名单不设置为允许任意来源访问\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Redis instances do not have public access enabled or an open whitelist.\",\n\t\t\"zh\": \"确保 Redis 实例未开启公网访问，或者白名单未设置为对所有 IP 开放。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Public access to Redis is a severe security risk, as it is often targets for brute force attacks and data theft.\",\n\t\t\"zh\": \"Redis 的公网访问是一个严重的安全风险，因为它经常成为暴力破解攻击和数据窃取的方目标。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable public connection for the Redis instance and restrict access via IP whitelists.\",\n\t\t\"zh\": \"禁用 Redis 实例的公网连接，并通过 IP 白名单限制访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::REDIS::Instance\"],\n}\n\nis_compliant(resource) if {\n\t# Check Connections property\n\tconnections := helpers.get_property(resource, \"Connections\", {})\n\n\t# It is compliant if PublicConnection is NOT present\n\tobject.get(connections, \"PublicConnection\", null) == null\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::REDIS::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Connections\", \"PublicConnection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:rocketmq-v5-instance-multi-zone", Name: models.I18nString{"en": "RocketMQ 5.0 Instance Multi-Zone Deployment", "zh": "使用多可用区的消息队列 RocketMQ 5.0 版实例"}, Severity: "medium", Description: models.I18nString{"en": "RocketMQ 5.0 instances should be deployed in Cluster HA mode which supports multi-zone availability.", "zh": "使用多可用区的消息队列 RocketMQ 5.0 版实例，视为合规。"}, Reason: models.I18nString{"en": "The RocketMQ 5.0 instance is not configured with Cluster HA mode.", "zh": "RocketMQ 5.0 实例未配置为高可用集群模式。"}, Recommendation: models.I18nString{"en": "Set SubSeriesCode to 'cluster_ha'.", "zh": "将 SubSeriesCode 设置为'cluster_ha'。"}, ResourceTypes: []string{"ALIYUN::ROCKETMQ5::Instance"}, FilePath: "aliyun/rules/rocketmq-v5-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.rocketmq_v5_instance_multi_zone", Content: "package infraguard.rules.aliyun.rocketmq_v5_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"rocketmq-v5-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"RocketMQ 5.0 Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的消息队列 RocketMQ 5.0 版实例\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"RocketMQ 5.0 instances should be deployed in Cluster HA mode which supports multi-zone availability.\",\n\t\t\"zh\": \"使用多可用区的消息队列 RocketMQ 5.0 版实例，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The RocketMQ 5.0 instance is not configured with Cluster HA mode.\",\n\t\t\"zh\": \"RocketMQ 5.0 实例未配置为高可用集群模式。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set SubSeriesCode to 'cluster_ha'.\",\n\t\t\"zh\": \"将 SubSeriesCode 设置为'cluster_ha'。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ROCKETMQ5::Instance\"],\n}\n\n# Check if instance is multi-zone (cluster_ha)\nis_multi_zone(resource) if {\n\tresource.Properties.SubSeriesCode == \"cluster_ha\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SubSeriesCode\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:root-ak-check", Name: models.I18nString{"en": "Root User AccessKey Check", "zh": "主账号 AccessKey 检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that the root account does not have active AccessKeys.", "zh": "确保主账号没有激活的 AccessKey。"}, Reason: models.I18nString{"en": "Using AccessKeys for the root account is a security risk. IAM roles or RAM user AccessKeys should be used instead.", "zh": "为主账号使用 AccessKey 存在安全风险。应改为使用 RAM 角色或 RAM 用户 AccessKey。"}, Recommendation: models.I18nString{"en": "Delete any AccessKeys associated with the root account and use RAM users or roles.", "zh": "删除主账号的所有 AccessKey，并使用 RAM 用户或角色。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/root-ak-check.rego", PackageName: "infraguard.rules.aliyun.root_ak_check", Content: "package infraguard.rules.aliyun.root_ak_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"root-ak-check\",\n\t\"name\": {\n\t\t\"en\": \"Root User AccessKey Check\",\n\t\t\"zh\": \"主账号 AccessKey 检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the root account does not have active AccessKeys.\",\n\t\t\"zh\": \"确保主账号没有激活的 AccessKey。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using AccessKeys for the root account is a security risk. IAM roles or RAM user AccessKeys should be used instead.\",\n\t\t\"zh\": \"为主账号使用 AccessKey 存在安全风险。应改为使用 RAM 角色或 RAM 用户 AccessKey。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Delete any AccessKeys associated with the root account and use RAM users or roles.\",\n\t\t\"zh\": \"删除主账号的所有 AccessKey，并使用 RAM 用户或角色。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tname == \"root\"\n\thelpers.has_property(resource, \"AccessKey\") # Conceptual check\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AccessKey\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:root-has-specified-role", Name: models.I18nString{"en": "Root Account Has Specified Role", "zh": "主账号具有指定的角色"}, Severity: "low", Description: models.I18nString{"en": "Ensures that the root account has a specified RAM role for governance and management.", "zh": "确保主账号具有用于治理和管理的指定 RAM 角色。"}, Reason: models.I18nString{"en": "Specific roles are required for cloud governance and management tools to function correctly.", "zh": "云治理和管理工具需要特定的角色才能正常运行。"}, Recommendation: models.I18nString{"en": "Create and assign the specified RAM role to the root account.", "zh": "创建并为主账号分配指定的 RAM 角色。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/root-has-specified-role.rego", PackageName: "infraguard.rules.aliyun.root_has_specified_role", Content: "package infraguard.rules.aliyun.root_has_specified_role\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"root-has-specified-role\",\n\t\"name\": {\n\t\t\"en\": \"Root Account Has Specified Role\",\n\t\t\"zh\": \"主账号具有指定的角色\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the root account has a specified RAM role for governance and management.\",\n\t\t\"zh\": \"确保主账号具有用于治理和管理的指定 RAM 角色。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Specific roles are required for cloud governance and management tools to function correctly.\",\n\t\t\"zh\": \"云治理和管理工具需要特定的角色才能正常运行。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Create and assign the specified RAM role to the root account.\",\n\t\t\"zh\": \"创建并为主账号分配指定的 RAM 角色。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tname == \"root\"\n\tnot helpers.has_property(resource, \"SpecifiedRole\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:root-mfa-check", Name: models.I18nString{"en": "Root User MFA Check", "zh": "主账号 MFA 检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that Multi-Factor Authentication (MFA) is enabled for the root account.", "zh": "确保主账号已开启多因素认证(MFA)。"}, Reason: models.I18nString{"en": "MFA provides an extra layer of security for the most privileged account in the cloud environment.", "zh": "MFA 为云环境中最具特权的账号提供了额外的安全层。"}, Recommendation: models.I18nString{"en": "Enable MFA for the Alibaba Cloud root account.", "zh": "为阿里云主账号开启 MFA。"}, ResourceTypes: []string{"ALIYUN::RAM::User"}, FilePath: "aliyun/rules/root-mfa-check.rego", PackageName: "infraguard.rules.aliyun.root_mfa_check", Content: "package infraguard.rules.aliyun.root_mfa_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"root-mfa-check\",\n\t\"name\": {\n\t\t\"en\": \"Root User MFA Check\",\n\t\t\"zh\": \"主账号 MFA 检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that Multi-Factor Authentication (MFA) is enabled for the root account.\",\n\t\t\"zh\": \"确保主账号已开启多因素认证(MFA)。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"MFA provides an extra layer of security for the most privileged account in the cloud environment.\",\n\t\t\"zh\": \"MFA 为云环境中最具特权的账号提供了额外的安全层。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable MFA for the Alibaba Cloud root account.\",\n\t\t\"zh\": \"为阿里云主账号开启 MFA。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::RAM::User\"], # This is a conceptual check often mapped to User or Account\n}\n\n# Conceptual check for root MFA\n# In practice, this might be a placeholder or check a specific global configuration if available\ndeny contains result if {\n\t# This is a conceptual rule, let's assume we check if any user has MFA enabled\n\t# or if there's a specific flag. For now, it's a placeholder implementation.\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::RAM::User\")\n\tname == \"root\"\n\tnot helpers.get_property(resource, \"MFAEnabled\", false)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"MFAEnabled\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:security-center-version-check", Name: models.I18nString{"en": "Security Center Version Check", "zh": "云安全中心版本检测"}, Severity: "medium", Description: models.I18nString{"en": "Security Center should be at a version that provides sufficient protection features.", "zh": "云安全中心版本满足要求，视为合规。"}, Reason: models.I18nString{"en": "A lower version of Security Center may not provide advanced threat detection and protection capabilities.", "zh": "较低版本的云安全中心可能无法提供先进的威胁检测和防御能力。"}, Recommendation: models.I18nString{"en": "Upgrade Security Center to a higher version (e.g., Enterprise or Ultimate).", "zh": "将云安全中心升级到更高版本（如企业版或旗舰版）。"}, ResourceTypes: []string{"ALIYUN::ThreatDetection::Instance"}, FilePath: "aliyun/rules/security-center-version-check.rego", PackageName: "infraguard.rules.aliyun.security_center_version_check", Content: "package infraguard.rules.aliyun.security_center_version_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"security-center-version-check\",\n\t\"name\": {\n\t\t\"en\": \"Security Center Version Check\",\n\t\t\"zh\": \"云安全中心版本检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Security Center should be at a version that provides sufficient protection features.\",\n\t\t\"zh\": \"云安全中心版本满足要求，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"A lower version of Security Center may not provide advanced threat detection and protection capabilities.\",\n\t\t\"zh\": \"较低版本的云安全中心可能无法提供先进的威胁检测和防御能力。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Upgrade Security Center to a higher version (e.g., Enterprise or Ultimate).\",\n\t\t\"zh\": \"将云安全中心升级到更高版本（如企业版或旗舰版）。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ThreatDetection::Instance\"],\n}\n\n# VersionCode values:\n# level2: Enterprise Edition\n# level3: Premium version\n# level7: Antivirus Edition\n# level8: Ultimate\n# level10: Purchase value-added services only\n\nis_compliant_version(resource) if {\n\tversion := helpers.get_property(resource, \"VersionCode\", \"\")\n\tversion == \"level3\" # Premium version\n}\n\nis_compliant_version(resource) if {\n\tversion := helpers.get_property(resource, \"VersionCode\", \"\")\n\tversion == \"level8\" # Ultimate\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_compliant_version(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VersionCode\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sg-public-access-check", Name: models.I18nString{"en": "Security Group Ingress Valid", "zh": "安全组入网设置有效"}, Severity: "high", Description: models.I18nString{"en": "Security group ingress rules should not allow all ports (-1/-1) from all sources (0.0.0.0/0) simultaneously.", "zh": "安全组入方向授权策略为允许，当端口范围-1/-1 和授权对象 0.0.0.0/0 未同时出现，或者被优先级更高的授权策略拒绝，视为合规。"}, Reason: models.I18nString{"en": "The security group has an ingress rule that allows all ports from all sources (0.0.0.0/0 with port range -1/-1), which poses a critical security risk.", "zh": "安全组有一条入网规则同时允许所有端口（-1/-1）和所有来源（0.0.0.0/0），存在严重安全风险。"}, Recommendation: models.I18nString{"en": "Either restrict the source IP range to specific CIDR blocks or limit the port range to specific ports based on actual business requirements.", "zh": "根据实际业务需求，将来源 IP 范围限制为特定的 CIDR 块，或将端口范围限制为特定的端口。"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup", "ALIYUN::ECS::SecurityGroupIngress", "ALIYUN::ECS::SecurityGroupIngresses"}, FilePath: "aliyun/rules/sg-public-access-check.rego", PackageName: "infraguard.rules.aliyun.sg_public_access_check", Content: "package infraguard.rules.aliyun.sg_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata with i18n support\nrule_meta := {\n\t\"id\": \"sg-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Ingress Valid\",\n\t\t\"zh\": \"安全组入网设置有效\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Security group ingress rules should not allow all ports (-1/-1) from all sources (0.0.0.0/0) simultaneously.\",\n\t\t\"zh\": \"安全组入方向授权策略为允许，当端口范围-1/-1 和授权对象 0.0.0.0/0 未同时出现，或者被优先级更高的授权策略拒绝，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The security group has an ingress rule that allows all ports from all sources (0.0.0.0/0 with port range -1/-1), which poses a critical security risk.\",\n\t\t\"zh\": \"安全组有一条入网规则同时允许所有端口（-1/-1）和所有来源（0.0.0.0/0），存在严重安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Either restrict the source IP range to specific CIDR blocks or limit the port range to specific ports based on actual business requirements.\",\n\t\t\"zh\": \"根据实际业务需求，将来源 IP 范围限制为特定的 CIDR 块，或将端口范围限制为特定的端口。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\", \"ALIYUN::ECS::SecurityGroupIngress\", \"ALIYUN::ECS::SecurityGroupIngresses\"],\n}\n\n# Check if an ingress rule is a public access rule (all ports from all sources)\nis_public_access(rule) if {\n\trule.PortRange == \"-1/-1\"\n\trule.SourceCidrIp == \"0.0.0.0/0\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\nis_public_access(rule) if {\n\trule.PortRange == \"-1/-1\"\n\trule.Ipv6SourceCidrIp == \"::/0\"\n\tobject.get(rule, \"Policy\", \"accept\") == \"accept\"\n}\n\n# Check SecurityGroup resource for ingress rules\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\tsome i, rule in resource.Properties.SecurityGroupIngress\n\tis_public_access(rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngress resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngress\")\n\tprops := resource.Properties\n\tingress_rule := {\n\t\t\"PortRange\": props.PortRange,\n\t\t\"SourceCidrIp\": object.get(props, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(props, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(props, \"Policy\", \"accept\"),\n\t}\n\tis_public_access(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n\n# Check SecurityGroupIngresses resource\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroupIngresses\")\n\tsome i, perm in resource.Properties.Permissions\n\tingress_rule := {\n\t\t\"PortRange\": perm.PortRange,\n\t\t\"SourceCidrIp\": object.get(perm, \"SourceCidrIp\", \"\"),\n\t\t\"Ipv6SourceCidrIp\": object.get(perm, \"Ipv6SourceCidrIp\", \"\"),\n\t\t\"Policy\": object.get(perm, \"Policy\", \"accept\"),\n\t}\n\tis_public_access(ingress_rule)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Permissions\", format_int(i, 10)],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sg-risky-ports-check", Name: models.I18nString{"en": "Security group does not open risky ports to 0.0.0.0/0", "zh": "安全组不允许对全部网段开启风险端口"}, Severity: "high", Description: models.I18nString{"en": "When security group ingress rule source is set to 0.0.0.0/0, the port range should not include specified risky ports, considered compliant. If source is not 0.0.0.0/0, it's compliant even if risky ports are included.", "zh": "当安全组入网网段设置为 0.0.0.0/0 时，端口范围不包含指定风险端口，视为合规。若入网网段未设置为 0.0.0.0/0 时，即使端口范围包含指定的风险端口，也视为合规。"}, Reason: models.I18nString{"en": "Security group opens risky ports to all IP addresses (0.0.0.0/0)", "zh": "安全组向所有 IP 地址(0.0.0.0/0)开放了风险端口"}, Recommendation: models.I18nString{"en": "Remove risky port rules from security group ingress rules or restrict source IP range", "zh": "从安全组入站规则中删除风险端口规则，或限制源 IP 范围"}, ResourceTypes: []string{"ALIYUN::ECS::SecurityGroup"}, FilePath: "aliyun/rules/sg-risky-ports-check.rego", PackageName: "infraguard.rules.aliyun.sg_risky_ports_check", Content: "package infraguard.rules.aliyun.sg_risky_ports_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"sg-risky-ports-check\",\n\t\"name\": {\n\t\t\"en\": \"Security group does not open risky ports to 0.0.0.0/0\",\n\t\t\"zh\": \"安全组不允许对全部网段开启风险端口\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"When security group ingress rule source is set to 0.0.0.0/0, the port range should not include specified risky ports, considered compliant. If source is not 0.0.0.0/0, it's compliant even if risky ports are included.\",\n\t\t\"zh\": \"当安全组入网网段设置为 0.0.0.0/0 时，端口范围不包含指定风险端口，视为合规。若入网网段未设置为 0.0.0.0/0 时，即使端口范围包含指定的风险端口，也视为合规。\",\n\t},\n\t\"severity\": \"high\",\n\t\"resource_types\": [\"ALIYUN::ECS::SecurityGroup\"],\n\t\"reason\": {\n\t\t\"en\": \"Security group opens risky ports to all IP addresses (0.0.0.0/0)\",\n\t\t\"zh\": \"安全组向所有 IP 地址(0.0.0.0/0)开放了风险端口\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove risky port rules from security group ingress rules or restrict source IP range\",\n\t\t\"zh\": \"从安全组入站规则中删除风险端口规则，或限制源 IP 范围\",\n\t},\n}\n\n# Risky port ranges to check (common sensitive ports)\n# Format: port ranges like \"22/22\", \"3389/3389\", \"0/65535\"\nis_risky_port(port_range) if {\n\t# Common risky ports: SSH (22), RDP (3389), Telnet (23), MySQL (3306), etc.\n\tport_range in [\n\t\t\"22/22\",\n\t\t\"23/23\",\n\t\t\"3389/3389\",\n\t\t\"3306/3306\",\n\t\t\"1433/1433\",\n\t\t\"5432/5432\",\n\t\t\"27017/27017\",\n\t\t\"6379/6379\",\n\t\t\"0/65535\",\n\t]\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::SecurityGroup\")\n\n\t# Get ingress rules\n\tingress_rules := helpers.get_property(resource, \"SecurityGroupIngress\", [])\n\n\t# Check each rule\n\tsome rule in ingress_rules\n\tsource_cidr := object.get(rule, \"SourceCidrIp\", \"\")\n\tport_range := object.get(rule, \"PortRange\", \"\")\n\n\t# Only flag if source is 0.0.0.0/0 and port is risky\n\tsource_cidr == \"0.0.0.0/0\"\n\tis_risky_port(port_range)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityGroupIngress\", \"SourceCidrIp\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-acl-public-access-check", Name: models.I18nString{"en": "SLB ACL Public Access Check", "zh": "CLB 访问控制列表不配置所有地址段"}, Severity: "high", Description: models.I18nString{"en": "Ensures that SLB ACLs do not contain 0.0.0.0/0 to prevent unrestricted public access.", "zh": "确保 CLB 访问控制列表中不包含 0.0.0.0/0，以防止无限制的公网访问。"}, Reason: models.I18nString{"en": "Allowing 0.0.0.0/0 in an ACL bypasses the security benefits of access control, potentially exposing services to attacks.", "zh": "在 ACL 中允许 0.0.0.0/0 会绕过访问控制的安全保障，使服务可能遭受攻击。"}, Recommendation: models.I18nString{"en": "Remove 0.0.0.0/0 from the SLB ACL entries and replace it with specific IP ranges.", "zh": "从 CLB 访问控制列表条目中移除 0.0.0.0/0，并替换为特定的 IP 范围。"}, ResourceTypes: []string{"ALIYUN::SLB::AccessControl"}, FilePath: "aliyun/rules/slb-acl-public-access-check.rego", PackageName: "infraguard.rules.aliyun.slb_acl_public_access_check", Content: "package infraguard.rules.aliyun.slb_acl_public_access_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"slb-acl-public-access-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB ACL Public Access Check\",\n\t\t\"zh\": \"CLB 访问控制列表不配置所有地址段\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that SLB ACLs do not contain 0.0.0.0/0 to prevent unrestricted public access.\",\n\t\t\"zh\": \"确保 CLB 访问控制列表中不包含 0.0.0.0/0，以防止无限制的公网访问。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Allowing 0.0.0.0/0 in an ACL bypasses the security benefits of access control, potentially exposing services to attacks.\",\n\t\t\"zh\": \"在 ACL 中允许 0.0.0.0/0 会绕过访问控制的安全保障，使服务可能遭受攻击。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Remove 0.0.0.0/0 from the SLB ACL entries and replace it with specific IP ranges.\",\n\t\t\"zh\": \"从 CLB 访问控制列表条目中移除 0.0.0.0/0，并替换为特定的 IP 范围。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::AccessControl\"],\n}\n\nis_compliant(resource) if {\n\tentries := helpers.get_property(resource, \"AclEntries\", [])\n\tnot has_open_entry(entries)\n}\n\nhas_open_entry(entries) if {\n\tsome entry in entries\n\thelpers.is_public_cidr(entry.Entry)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::AccessControl\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AclEntries\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listener-enabled-acl", Name: models.I18nString{"en": "SLB All Listeners Have Access Control", "zh": "SLB 实例所有运行中的监听都设置访问控制"}, Severity: "medium", Description: models.I18nString{"en": "All running listeners of SLB instances should have access control lists (ACL) configured for security.", "zh": "SLB 实例所有运行中的监听都设置了访问控制，视为合规。"}, Reason: models.I18nString{"en": "Listeners without ACL may allow unrestricted access, increasing security risks.", "zh": "未设置访问控制的监听可能允许无限制的访问，增加安全风险。"}, Recommendation: models.I18nString{"en": "Configure ACL for all running listeners on SLB instances.", "zh": "为 SLB 实例的所有运行中监听配置访问控制列表。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-all-listener-enabled-acl.rego", PackageName: "infraguard.rules.aliyun.slb_all_listener_enabled_acl", Content: "package infraguard.rules.aliyun.slb_all_listener_enabled_acl\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listener-enabled-acl\",\n\t\"name\": {\n\t\t\"en\": \"SLB All Listeners Have Access Control\",\n\t\t\"zh\": \"SLB 实例所有运行中的监听都设置访问控制\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"All running listeners of SLB instances should have access control lists (ACL) configured for security.\",\n\t\t\"zh\": \"SLB 实例所有运行中的监听都设置了访问控制，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Listeners without ACL may allow unrestricted access, increasing security risks.\",\n\t\t\"zh\": \"未设置访问控制的监听可能允许无限制的访问，增加安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure ACL for all running listeners on SLB instances.\",\n\t\t\"zh\": \"为 SLB 实例的所有运行中监听配置访问控制列表。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\tacl_status := helpers.get_property(resource, \"AclStatus\", \"off\")\n\tacl_status == \"on\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AclStatus\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listener-health-check-enabled", Name: models.I18nString{"en": "SLB All Listeners Health Check Enabled", "zh": "SLB 所有监听开启健康检查"}, Severity: "high", Description: models.I18nString{"en": "Ensures all SLB listeners have health checks enabled.", "zh": "确保所有 SLB 监听均开启了健康检查。"}, Reason: models.I18nString{"en": "Health checks ensure that traffic is only sent to healthy backend instances.", "zh": "健康检查确保流量仅发送到健康的后端实例。"}, Recommendation: models.I18nString{"en": "Enable health checks for all SLB listeners.", "zh": "为所有 SLB 监听开启健康检查。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-all-listener-health-check-enabled.rego", PackageName: "infraguard.rules.aliyun.slb_all_listener_health_check_enabled", Content: "package infraguard.rules.aliyun.slb_all_listener_health_check_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listener-health-check-enabled\",\n\t\"name\": {\n\t\t\"en\": \"SLB All Listeners Health Check Enabled\",\n\t\t\"zh\": \"SLB 所有监听开启健康检查\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures all SLB listeners have health checks enabled.\",\n\t\t\"zh\": \"确保所有 SLB 监听均开启了健康检查。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Health checks ensure that traffic is only sent to healthy backend instances.\",\n\t\t\"zh\": \"健康检查确保流量仅发送到健康的后端实例。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable health checks for all SLB listeners.\",\n\t\t\"zh\": \"为所有 SLB 监听开启健康检查。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\t# HealthCheck is a map with Switch property\n\thc := helpers.get_property(resource, \"HealthCheck\", {})\n\tswitch_val := object.get(hc, \"Switch\", \"off\")\n\tswitch_val == \"on\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HealthCheck\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listener-http-disabled", Name: models.I18nString{"en": "SLB All Listeners HTTP Disabled", "zh": "SLB 禁用 HTTP 监听"}, Severity: "medium", Description: models.I18nString{"en": "Ensures no SLB listeners use the insecure HTTP protocol.", "zh": "确保没有 SLB 监听使用不安全的 HTTP 协议。"}, Reason: models.I18nString{"en": "HTTP traffic is unencrypted and vulnerable to interception.", "zh": "HTTP 流量未加密，容易被截获。"}, Recommendation: models.I18nString{"en": "Disable HTTP listeners and use HTTPS instead.", "zh": "禁用 HTTP 监听并改用 HTTPS。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-all-listener-http-disabled.rego", PackageName: "infraguard.rules.aliyun.slb_all_listener_http_disabled", Content: "package infraguard.rules.aliyun.slb_all_listener_http_disabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listener-http-disabled\",\n\t\"name\": {\n\t\t\"en\": \"SLB All Listeners HTTP Disabled\",\n\t\t\"zh\": \"SLB 禁用 HTTP 监听\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures no SLB listeners use the insecure HTTP protocol.\",\n\t\t\"zh\": \"确保没有 SLB 监听使用不安全的 HTTP 协议。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"HTTP traffic is unencrypted and vulnerable to interception.\",\n\t\t\"zh\": \"HTTP 流量未加密，容易被截获。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Disable HTTP listeners and use HTTPS instead.\",\n\t\t\"zh\": \"禁用 HTTP 监听并改用 HTTPS。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol != \"http\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Protocol\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listener-http-redirect-https", Name: models.I18nString{"en": "SLB HTTP Redirect to HTTPS Enabled", "zh": "SLB 监听强制跳转 HTTPS"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLB HTTP listeners are configured to redirect traffic to HTTPS.", "zh": "确保 SLB HTTP 监听已配置为将流量重定向至 HTTPS。"}, Reason: models.I18nString{"en": "Redirecting HTTP to HTTPS ensures all client communication is encrypted.", "zh": "将 HTTP 重定向至 HTTPS 确保了所有客户端通信均经过加密。"}, Recommendation: models.I18nString{"en": "Enable HTTP-to-HTTPS redirection for the SLB listener.", "zh": "为 SLB 监听开启 HTTP 转 HTTPS 重定向。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-all-listener-http-redirect-https.rego", PackageName: "infraguard.rules.aliyun.slb_all_listener_http_redirect_https", Content: "package infraguard.rules.aliyun.slb_all_listener_http_redirect_https\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listener-http-redirect-https\",\n\t\"name\": {\n\t\t\"en\": \"SLB HTTP Redirect to HTTPS Enabled\",\n\t\t\"zh\": \"SLB 监听强制跳转 HTTPS\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB HTTP listeners are configured to redirect traffic to HTTPS.\",\n\t\t\"zh\": \"确保 SLB HTTP 监听已配置为将流量重定向至 HTTPS。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Redirecting HTTP to HTTPS ensures all client communication is encrypted.\",\n\t\t\"zh\": \"将 HTTP 重定向至 HTTPS 确保了所有客户端通信均经过加密。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable HTTP-to-HTTPS redirection for the SLB listener.\",\n\t\t\"zh\": \"为 SLB 监听开启 HTTP 转 HTTPS 重定向。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol != \"http\"\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol == \"http\"\n\n\t# In ROS, check for HttpConfig.ListenerForward\n\thttp_config := helpers.get_property(resource, \"HttpConfig\", {})\n\tis_object(http_config)\n\thttp_config.ListenerForward == \"on\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HttpConfig\", \"ListenerForward\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listener-servers-multi-zone", Name: models.I18nString{"en": "SLB Multi-Zone with Multi-Zone Backend Servers", "zh": "使用多可用区 SLB 实例并为服务器组配置多个可用区资源"}, Severity: "high", Description: models.I18nString{"en": "SLB instances should be multi-zone, and all server groups used by listeners should have resources added from multiple zones.", "zh": "SLB 实例为多可用区，并且 SLB 实例下所有监听使用的服务器组中添加了多个可用区的资源，视为合规。"}, Reason: models.I18nString{"en": "Single zone deployment or single zone backend servers lack high availability and may lead to service interruption during zone failure.", "zh": "单可用区部署或后端服务器仅位于单个可用区缺乏高可用性，可能在可用区故障时导致服务中断。"}, Recommendation: models.I18nString{"en": "Configure SLB instances with master and slave zones, and ensure backend server groups include instances from different availability zones.", "zh": "为 SLB 实例配置主备可用区，并确保后端服务器组包含来自不同可用区的实例。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-all-listener-servers-multi-zone.rego", PackageName: "infraguard.rules.aliyun.slb_all_listener_servers_multi_zone", Content: "package infraguard.rules.aliyun.slb_all_listener_servers_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"slb-all-listener-servers-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLB Multi-Zone with Multi-Zone Backend Servers\",\n\t\t\"zh\": \"使用多可用区 SLB 实例并为服务器组配置多个可用区资源\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"SLB instances should be multi-zone, and all server groups used by listeners should have resources added from multiple zones.\",\n\t\t\"zh\": \"SLB 实例为多可用区，并且 SLB 实例下所有监听使用的服务器组中添加了多个可用区的资源，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Single zone deployment or single zone backend servers lack high availability and may lead to service interruption during zone failure.\",\n\t\t\"zh\": \"单可用区部署或后端服务器仅位于单个可用区缺乏高可用性，可能在可用区故障时导致服务中断。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure SLB instances with master and slave zones, and ensure backend server groups include instances from different availability zones.\",\n\t\t\"zh\": \"为 SLB 实例配置主备可用区，并确保后端服务器组包含来自不同可用区的实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\n# Check if SLB instance has slave zone configured\nis_multi_zone(resource) if {\n\thelpers.has_property(resource, \"SlaveZoneId\")\n\tslave_zone := resource.Properties.SlaveZoneId\n\tslave_zone != \"\"\n}\n\n# Deny rule: SLB instances should be multi-zone\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SlaveZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listenter-has-server", Name: models.I18nString{"en": "SLB All Listeners Have Backend Servers", "zh": "SLB 负载均衡的所有监听都至少添加了指定数量的后端服务器"}, Severity: "medium", Description: models.I18nString{"en": "All listeners of SLB instances should have at least the specified number of backend servers attached.", "zh": "SLB 负载均衡的所有监听都至少添加参数指定数量的后端服务器，视为合规。默认至少添加一台服务器视为合规。"}, Reason: models.I18nString{"en": "Listeners without backend servers cannot forward traffic, leading to service unavailability.", "zh": "没有后端服务器的监听无法转发流量，导致服务不可用。"}, Recommendation: models.I18nString{"en": "Attach at least the minimum required number of backend servers to all listeners.", "zh": "为所有监听至少添加所需最小数量的后端服务器。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-all-listenter-has-server.rego", PackageName: "infraguard.rules.aliyun.slb_all_listenter_has_server", Content: "package infraguard.rules.aliyun.slb_all_listenter_has_server\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listenter-has-server\",\n\t\"name\": {\n\t\t\"en\": \"SLB All Listeners Have Backend Servers\",\n\t\t\"zh\": \"SLB 负载均衡的所有监听都至少添加了指定数量的后端服务器\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"All listeners of SLB instances should have at least the specified number of backend servers attached.\",\n\t\t\"zh\": \"SLB 负载均衡的所有监听都至少添加参数指定数量的后端服务器，视为合规。默认至少添加一台服务器视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Listeners without backend servers cannot forward traffic, leading to service unavailability.\",\n\t\t\"zh\": \"没有后端服务器的监听无法转发流量，导致服务不可用。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Attach at least the minimum required number of backend servers to all listeners.\",\n\t\t\"zh\": \"为所有监听至少添加所需最小数量的后端服务器。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Listeners\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-all-listenter-tls-policy-check", Name: models.I18nString{"en": "SLB Listener TLS Policy Check", "zh": "SLB 监听使用安全 TLS 策略"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLB HTTPS listeners use secure TLS cipher policies.", "zh": "确保 SLB HTTPS 监听使用安全的 TLS 加密策略。"}, Reason: models.I18nString{"en": "Weak cipher suites can be exploited to decrypt intercepted traffic.", "zh": "弱加密套件可能被利用来解密截获的流量。"}, Recommendation: models.I18nString{"en": "Use a recommended TLS policy like 'tls_cipher_policy_1_2'.", "zh": "使用推荐的 TLS 策略，如 'tls_cipher_policy_1_2'。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-all-listenter-tls-policy-check.rego", PackageName: "infraguard.rules.aliyun.slb_all_listenter_tls_policy_check", Content: "package infraguard.rules.aliyun.slb_all_listenter_tls_policy_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-all-listenter-tls-policy-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Listener TLS Policy Check\",\n\t\t\"zh\": \"SLB 监听使用安全 TLS 策略\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB HTTPS listeners use secure TLS cipher policies.\",\n\t\t\"zh\": \"确保 SLB HTTPS 监听使用安全的 TLS 加密策略。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Weak cipher suites can be exploited to decrypt intercepted traffic.\",\n\t\t\"zh\": \"弱加密套件可能被利用来解密截获的流量。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use a recommended TLS policy like 'tls_cipher_policy_1_2'.\",\n\t\t\"zh\": \"使用推荐的 TLS 策略，如 'tls_cipher_policy_1_2'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol != \"https\"\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol == \"https\"\n\tpolicy := helpers.get_property(resource, \"TLSCipherPolicy\", \"\")\n\n\t# Example: must be 1.2 or higher\n\tpolicy != \"\"\n\tnot helpers.includes([\"tls_cipher_policy_1_0\", \"tls_cipher_policy_1_1\"], policy)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TLSCipherPolicy\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-backendserver-weight-check", Name: models.I18nString{"en": "SLB Backend Server Weight Check", "zh": "SLB 后端服务器权重配置核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures SLB backend servers have reasonable weight configurations.", "zh": "确保 SLB 后端服务器具有合理的权重配置。"}, Reason: models.I18nString{"en": "Uneven weight distribution can lead to unbalanced traffic and potential overload.", "zh": "权重分配不均可能导致流量失衡和潜在的负载过载。"}, Recommendation: models.I18nString{"en": "Ensure backend server weights are set correctly.", "zh": "确保后端服务器权重设置正确。"}, ResourceTypes: []string{"ALIYUN::SLB::BackendServerAttachment"}, FilePath: "aliyun/rules/slb-backendserver-weight-check.rego", PackageName: "infraguard.rules.aliyun.slb_backendserver_weight_check", Content: "package infraguard.rules.aliyun.slb_backendserver_weight_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-backendserver-weight-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Backend Server Weight Check\",\n\t\t\"zh\": \"SLB 后端服务器权重配置核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB backend servers have reasonable weight configurations.\",\n\t\t\"zh\": \"确保 SLB 后端服务器具有合理的权重配置。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Uneven weight distribution can lead to unbalanced traffic and potential overload.\",\n\t\t\"zh\": \"权重分配不均可能导致流量失衡和潜在的负载过载。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure backend server weights are set correctly.\",\n\t\t\"zh\": \"确保后端服务器权重设置正确。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::BackendServerAttachment\"],\n}\n\nis_compliant(resource) if {\n\tservers := helpers.get_property(resource, \"BackendServers\", [])\n\tsome server in servers\n\tweight := object.get(server, \"Weight\", 100)\n\tweight > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::BackendServerAttachment\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"BackendServers\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-default-server-group-multi-server", Name: models.I18nString{"en": "SLB Default Server Group Has Multiple Servers", "zh": "SLB 实例默认服务器组包含至少两台服务器"}, Severity: "medium", Description: models.I18nString{"en": "The default server group of SLB instances should have at least two servers to avoid single point of failure.", "zh": "SLB 实例的默认服务器组至少添加两台服务器，视为合规。"}, Reason: models.I18nString{"en": "A single backend server creates a single point of failure and reduces availability.", "zh": "单一后端服务器创建单点故障并降低可用性。"}, Recommendation: models.I18nString{"en": "Add at least two servers to the default server group for high availability.", "zh": "为实现高可用性，在默认服务器组中至少添加两台服务器。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-default-server-group-multi-server.rego", PackageName: "infraguard.rules.aliyun.slb_default_server_group_multi_server", Content: "package infraguard.rules.aliyun.slb_default_server_group_multi_server\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-default-server-group-multi-server\",\n\t\"name\": {\n\t\t\"en\": \"SLB Default Server Group Has Multiple Servers\",\n\t\t\"zh\": \"SLB 实例默认服务器组包含至少两台服务器\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"The default server group of SLB instances should have at least two servers to avoid single point of failure.\",\n\t\t\"zh\": \"SLB 实例的默认服务器组至少添加两台服务器，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"A single backend server creates a single point of failure and reduces availability.\",\n\t\t\"zh\": \"单一后端服务器创建单点故障并降低可用性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add at least two servers to the default server group for high availability.\",\n\t\t\"zh\": \"为实现高可用性，在默认服务器组中至少添加两台服务器。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nhas_multiple_servers(resource) if {\n\tbackend_servers := helpers.get_property(resource, \"BackendServers\", [])\n\tcount(backend_servers) >= 2\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot has_multiple_servers(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"BackendServers\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-delete-protection-enabled", Name: models.I18nString{"en": "SLB Instance Deletion Protection Enabled", "zh": "SLB 实例开启释放保护"}, Severity: "high", Description: models.I18nString{"en": "Ensures that SLB instances have deletion protection enabled.", "zh": "确保 SLB 实例开启了释放保护。"}, Reason: models.I18nString{"en": "If deletion protection is not enabled, the SLB instance may be released accidentally, causing service interruption.", "zh": "如果未开启释放保护，SLB 实例可能会被意外释放，导致业务中断。"}, Recommendation: models.I18nString{"en": "Enable deletion protection for the SLB instance.", "zh": "为 SLB 实例开启释放保护功能。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-delete-protection-enabled.rego", PackageName: "infraguard.rules.aliyun.slb_delete_protection_enabled", Content: "package infraguard.rules.aliyun.slb_delete_protection_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"slb-delete-protection-enabled\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Deletion Protection Enabled\",\n\t\t\"zh\": \"SLB 实例开启释放保护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that SLB instances have deletion protection enabled.\",\n\t\t\"zh\": \"确保 SLB 实例开启了释放保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If deletion protection is not enabled, the SLB instance may be released accidentally, causing service interruption.\",\n\t\t\"zh\": \"如果未开启释放保护，SLB 实例可能会被意外释放，导致业务中断。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable deletion protection for the SLB instance.\",\n\t\t\"zh\": \"为 SLB 实例开启释放保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"DeletionProtection\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DeletionProtection\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-autorenewal-check", Name: models.I18nString{"en": "SLB Instance Auto-Renewal Check", "zh": "SLB 实例包年包月开启自动续费"}, Severity: "medium", Description: models.I18nString{"en": "Prepaid SLB instances should have auto-renewal enabled to avoid service interruption.", "zh": "包年包月的 SLB 实例开启了自动续费，视为合规。"}, Reason: models.I18nString{"en": "SLB instances without auto-renewal may expire and cause service interruption.", "zh": "未开启自动续费的 SLB 实例可能到期并导致服务中断。"}, Recommendation: models.I18nString{"en": "Enable auto-renewal for prepaid SLB instances.", "zh": "为包年包月 SLB 实例开启自动续费。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-autorenewal-check.rego", PackageName: "infraguard.rules.aliyun.slb_instance_autorenewal_check", Content: "package infraguard.rules.aliyun.slb_instance_autorenewal_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-instance-autorenewal-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Auto-Renewal Check\",\n\t\t\"zh\": \"SLB 实例包年包月开启自动续费\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Prepaid SLB instances should have auto-renewal enabled to avoid service interruption.\",\n\t\t\"zh\": \"包年包月的 SLB 实例开启了自动续费，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SLB instances without auto-renewal may expire and cause service interruption.\",\n\t\t\"zh\": \"未开启自动续费的 SLB 实例可能到期并导致服务中断。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable auto-renewal for prepaid SLB instances.\",\n\t\t\"zh\": \"为包年包月 SLB 实例开启自动续费。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_prepaid(resource) if {\n\tcharge_type := helpers.get_property(resource, \"InstanceChargeType\", \"\")\n\tcharge_type == \"Prepaid\"\n}\n\nhas_autorenewal(resource) if {\n\tauto_renew := helpers.get_property(resource, \"AutoRenew\", false)\n\tauto_renew == true\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tis_prepaid(resource)\n\tnot has_autorenewal(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AutoRenew\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-default-server-group-multi-zone", Name: models.I18nString{"en": "SLB Default Server Group Multi-Zone", "zh": "SLB 负载均衡默认服务器组添加多个可用区资源"}, Severity: "medium", Description: models.I18nString{"en": "The default server group of SLB instances should have resources distributed across multiple availability zones.", "zh": "SLB 负载均衡的默认服务器组挂载资源分布在多个可用区，视为合规。默认服务器组无挂载任何资源时不适用本规则，视为不适用。"}, Reason: models.I18nString{"en": "Single-zone backend servers create a single point of failure and reduce availability.", "zh": "单可用区后端服务器创建单点故障并降低可用性。"}, Recommendation: models.I18nString{"en": "Distribute backend servers across multiple availability zones for high availability.", "zh": "为实现高可用性，将后端服务器分布在多个可用区。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-default-server-group-multi-zone.rego", PackageName: "infraguard.rules.aliyun.slb_instance_default_server_group_multi_zone", Content: "package infraguard.rules.aliyun.slb_instance_default_server_group_multi_zone\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-instance-default-server-group-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLB Default Server Group Multi-Zone\",\n\t\t\"zh\": \"SLB 负载均衡默认服务器组添加多个可用区资源\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"The default server group of SLB instances should have resources distributed across multiple availability zones.\",\n\t\t\"zh\": \"SLB 负载均衡的默认服务器组挂载资源分布在多个可用区，视为合规。默认服务器组无挂载任何资源时不适用本规则，视为不适用。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Single-zone backend servers create a single point of failure and reduce availability.\",\n\t\t\"zh\": \"单可用区后端服务器创建单点故障并降低可用性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Distribute backend servers across multiple availability zones for high availability.\",\n\t\t\"zh\": \"为实现高可用性，将后端服务器分布在多个可用区。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nhas_multi_zone_servers(resource) if {\n\tbackend_servers := helpers.get_property(resource, \"BackendServers\", [])\n\n\t# Check if servers are in different zones\n\tcount(backend_servers) > 1\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tbackend_servers := helpers.get_property(resource, \"BackendServers\", [])\n\tcount(backend_servers) > 0\n\tnot has_multi_zone_servers(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"BackendServers\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-loadbalancerspec-check", Name: models.I18nString{"en": "SLB Instance Spec Check", "zh": "SLB 规格合规性检查"}, Severity: "low", Description: models.I18nString{"en": "Ensures SLB instances use approved performance specifications.", "zh": "确保 SLB 实例使用批准的性能规格。"}, Reason: models.I18nString{"en": "Using specific specs helps in cost management and performance standardization.", "zh": "使用特定规格有助于成本管理和性能标准化。"}, Recommendation: models.I18nString{"en": "Use a spec from the approved list (e.g., slb.s1.small).", "zh": "使用批准列表中的规格（如 slb.s1.small）。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-loadbalancerspec-check.rego", PackageName: "infraguard.rules.aliyun.slb_instance_loadbalancerspec_check", Content: "package infraguard.rules.aliyun.slb_instance_loadbalancerspec_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-instance-loadbalancerspec-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Spec Check\",\n\t\t\"zh\": \"SLB 规格合规性检查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB instances use approved performance specifications.\",\n\t\t\"zh\": \"确保 SLB 实例使用批准的性能规格。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using specific specs helps in cost management and performance standardization.\",\n\t\t\"zh\": \"使用特定规格有助于成本管理和性能标准化。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use a spec from the approved list (e.g., slb.s1.small).\",\n\t\t\"zh\": \"使用批准列表中的规格（如 slb.s1.small）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nallowed_specs := [\"slb.s1.small\", \"slb.s2.small\", \"slb.s3.small\"]\n\nis_compliant(resource) if {\n\tspec := helpers.get_property(resource, \"LoadBalancerSpec\", \"\")\n\thelpers.includes(allowed_specs, spec)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoadBalancerSpec\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-log-enabled", Name: models.I18nString{"en": "SLB Instance Logging Enabled", "zh": "SLB 实例开启访问日志"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that access logging is enabled for the SLB instance.", "zh": "确保 SLB 实例开启了访问日志。"}, Reason: models.I18nString{"en": "Access logs are essential for auditing traffic and troubleshooting connectivity and security issues.", "zh": "访问日志对于审计流量以及排查连接和安全问题至关重要。"}, Recommendation: models.I18nString{"en": "Enable access logging for the SLB instance.", "zh": "为 SLB 实例开启访问日志。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-log-enabled.rego", PackageName: "infraguard.rules.aliyun.slb_instance_log_enabled", Content: "package infraguard.rules.aliyun.slb_instance_log_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"slb-instance-log-enabled\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Logging Enabled\",\n\t\t\"zh\": \"SLB 实例开启访问日志\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that access logging is enabled for the SLB instance.\",\n\t\t\"zh\": \"确保 SLB 实例开启了访问日志。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Access logs are essential for auditing traffic and troubleshooting connectivity and security issues.\",\n\t\t\"zh\": \"访问日志对于审计流量以及排查连接和安全问题至关重要。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable access logging for the SLB instance.\",\n\t\t\"zh\": \"为 SLB 实例开启访问日志。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\n\t# Conceptual check for logging\n\tnot helpers.has_property(resource, \"AccessLog\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-multi-zone", Name: models.I18nString{"en": "SLB Instance Multi-Zone Deployment", "zh": "SLB 实例多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "SLB instances should be deployed across multiple zones by configuring both master and slave zones for high availability.", "zh": "SLB 实例应通过配置主可用区和备可用区来部署在多个可用区，以实现高可用性。"}, Reason: models.I18nString{"en": "The SLB instance does not have a slave zone configured, which may affect availability during zone failures.", "zh": "SLB 实例未配置备可用区，在可用区故障时可能影响可用性。"}, Recommendation: models.I18nString{"en": "Configure a slave zone by setting the SlaveZoneId property to enable multi-zone deployment.", "zh": "通过设置 SlaveZoneId 属性配置备可用区，以启用多可用区部署。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-multi-zone.rego", PackageName: "infraguard.rules.aliyun.slb_instance_multi_zone", Content: "package infraguard.rules.aliyun.slb_instance_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"slb-instance-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Multi-Zone Deployment\",\n\t\t\"zh\": \"SLB 实例多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"SLB instances should be deployed across multiple zones by configuring both master and slave zones for high availability.\",\n\t\t\"zh\": \"SLB 实例应通过配置主可用区和备可用区来部署在多个可用区，以实现高可用性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The SLB instance does not have a slave zone configured, which may affect availability during zone failures.\",\n\t\t\"zh\": \"SLB 实例未配置备可用区，在可用区故障时可能影响可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure a slave zone by setting the SlaveZoneId property to enable multi-zone deployment.\",\n\t\t\"zh\": \"通过设置 SlaveZoneId 属性配置备可用区，以启用多可用区部署。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\n# Check if instance has slave zone configured\nhas_slave_zone(resource) if {\n\thelpers.has_property(resource, \"SlaveZoneId\")\n\tslave_zone := resource.Properties.SlaveZoneId\n\tslave_zone != \"\"\n}\n\n# Deny rule: SLB instances should have slave zone configured\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot has_slave_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SlaveZoneId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-instance-spec-check", Name: models.I18nString{"en": "SLB Instance Specification Check", "zh": "SLB 实例规格满足要求"}, Severity: "medium", Description: models.I18nString{"en": "SLB instance specifications should meet the required performance criteria based on the specified list.", "zh": "SLB 实例规格在指定的规格列表中，视为合规。"}, Reason: models.I18nString{"en": "Using low-specification SLB instances may not meet performance requirements and could lead to bottlenecks.", "zh": "使用低规格 SLB 实例可能无法满足性能要求，可能导致瓶颈。"}, Recommendation: models.I18nString{"en": "Use SLB instances with specifications that meet your performance requirements.", "zh": "使用满足性能要求的 SLB 实例规格。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-instance-spec-check.rego", PackageName: "infraguard.rules.aliyun.slb_instance_spec_check", Content: "package infraguard.rules.aliyun.slb_instance_spec_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-instance-spec-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance Specification Check\",\n\t\t\"zh\": \"SLB 实例规格满足要求\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"SLB instance specifications should meet the required performance criteria based on the specified list.\",\n\t\t\"zh\": \"SLB 实例规格在指定的规格列表中，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using low-specification SLB instances may not meet performance requirements and could lead to bottlenecks.\",\n\t\t\"zh\": \"使用低规格 SLB 实例可能无法满足性能要求，可能导致瓶颈。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use SLB instances with specifications that meet your performance requirements.\",\n\t\t\"zh\": \"使用满足性能要求的 SLB 实例规格。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\n# Allowed specifications (example)\nallowed_specs := {\n\t\"slb.s3.small\",\n\t\"slb.s3.medium\",\n\t\"slb.s3.large\",\n\t\"slb.s3.xlarge\",\n\t\"slb.s3.xxlarge\",\n}\n\nis_valid_spec(resource) if {\n\tspec := helpers.get_property(resource, \"LoadBalancerSpec\", \"\")\n\tspec == \"\"\n}\n\nis_valid_spec(resource) if {\n\tspec := helpers.get_property(resource, \"LoadBalancerSpec\", \"\")\n\tspec in allowed_specs\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_valid_spec(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoadBalancerSpec\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-listener-https-enabled", Name: models.I18nString{"en": "SLB Listener HTTPS Enabled", "zh": "SLB 监听开启 HTTPS"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLB listeners use HTTPS protocol for secure communication.", "zh": "确保 SLB 监听使用 HTTPS 协议以保障通信安全。"}, Reason: models.I18nString{"en": "HTTP protocol is insecure and prone to eavesdropping. HTTPS provides encryption.", "zh": "HTTP 协议不安全，容易被窃听。HTTPS 提供加密保障。"}, Recommendation: models.I18nString{"en": "Configure SLB listeners to use HTTPS instead of HTTP.", "zh": "将 SLB 监听配置为使用 HTTPS 而非 HTTP。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-listener-https-enabled.rego", PackageName: "infraguard.rules.aliyun.slb_listener_https_enabled", Content: "package infraguard.rules.aliyun.slb_listener_https_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-listener-https-enabled\",\n\t\"name\": {\n\t\t\"en\": \"SLB Listener HTTPS Enabled\",\n\t\t\"zh\": \"SLB 监听开启 HTTPS\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB listeners use HTTPS protocol for secure communication.\",\n\t\t\"zh\": \"确保 SLB 监听使用 HTTPS 协议以保障通信安全。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"HTTP protocol is insecure and prone to eavesdropping. HTTPS provides encryption.\",\n\t\t\"zh\": \"HTTP 协议不安全，容易被窃听。HTTPS 提供加密保障。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure SLB listeners to use HTTPS instead of HTTP.\",\n\t\t\"zh\": \"将 SLB 监听配置为使用 HTTPS 而非 HTTP。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nis_compliant(resource) if {\n\tprotocol := helpers.get_property(resource, \"Protocol\", \"\")\n\tprotocol == \"https\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Protocol\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-listener-risk-ports-check", Name: models.I18nString{"en": "SLB Listener Risk Ports Check", "zh": "SLB 监听禁用高风险端口"}, Severity: "high", Description: models.I18nString{"en": "Ensures SLB listeners do not expose high-risk ports like 22 or 3389.", "zh": "确保 SLB 监听未暴露 22、3389 等高风险端口。"}, Reason: models.I18nString{"en": "Exposing management ports to the internet via SLB increases the risk of unauthorized access.", "zh": "通过 SLB 向互联网暴露管理端口会增加未经授权访问的风险。"}, Recommendation: models.I18nString{"en": "Use different ports for public services or use a VPN/Bastion Host for management.", "zh": "为公共服务使用其他端口，或使用 VPN/堡垒机进行管理。"}, ResourceTypes: []string{"ALIYUN::SLB::Listener"}, FilePath: "aliyun/rules/slb-listener-risk-ports-check.rego", PackageName: "infraguard.rules.aliyun.slb_listener_risk_ports_check", Content: "package infraguard.rules.aliyun.slb_listener_risk_ports_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-listener-risk-ports-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Listener Risk Ports Check\",\n\t\t\"zh\": \"SLB 监听禁用高风险端口\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB listeners do not expose high-risk ports like 22 or 3389.\",\n\t\t\"zh\": \"确保 SLB 监听未暴露 22、3389 等高风险端口。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Exposing management ports to the internet via SLB increases the risk of unauthorized access.\",\n\t\t\"zh\": \"通过 SLB 向互联网暴露管理端口会增加未经授权访问的风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use different ports for public services or use a VPN/Bastion Host for management.\",\n\t\t\"zh\": \"为公共服务使用其他端口，或使用 VPN/堡垒机进行管理。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::Listener\"],\n}\n\nrisky_ports := [22, 3389, 3306, 6379]\n\nis_compliant(resource) if {\n\tport := helpers.get_property(resource, \"ListenerPort\", -1)\n\tnot helpers.includes(risky_ports, port)\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::Listener\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ListenerPort\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-loadbalancer-bandwidth-limit", Name: models.I18nString{"en": "SLB Bandwidth Limit", "zh": "SLB 带宽上限核查"}, Severity: "low", Description: models.I18nString{"en": "Ensures SLB instance bandwidth does not exceed a specified maximum value.", "zh": "确保 SLB 实例带宽不超过指定的最高值。"}, Reason: models.I18nString{"en": "Controlling SLB bandwidth helps manage network costs.", "zh": "控制 SLB 带宽有助于管理网络成本。"}, Recommendation: models.I18nString{"en": "Set SLB bandwidth to a reasonable value (e.g., up to 500Mbps).", "zh": "将 SLB 带宽设置为合理的值（如不超过 500Mbps）。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-loadbalancer-bandwidth-limit.rego", PackageName: "infraguard.rules.aliyun.slb_loadbalancer_bandwidth_limit", Content: "package infraguard.rules.aliyun.slb_loadbalancer_bandwidth_limit\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-loadbalancer-bandwidth-limit\",\n\t\"name\": {\n\t\t\"en\": \"SLB Bandwidth Limit\",\n\t\t\"zh\": \"SLB 带宽上限核查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB instance bandwidth does not exceed a specified maximum value.\",\n\t\t\"zh\": \"确保 SLB 实例带宽不超过指定的最高值。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Controlling SLB bandwidth helps manage network costs.\",\n\t\t\"zh\": \"控制 SLB 带宽有助于管理网络成本。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set SLB bandwidth to a reasonable value (e.g., up to 500Mbps).\",\n\t\t\"zh\": \"将 SLB 带宽设置为合理的值（如不超过 500Mbps）。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\tbandwidth := helpers.get_property(resource, \"Bandwidth\", 1)\n\tbandwidth <= 500\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"Bandwidth\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-loadbalancer-in-vpc", Name: models.I18nString{"en": "SLB in VPC Check", "zh": "强制 SLB 部署在 VPC 环境中"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLB instances are deployed within a Virtual Private Cloud (VPC).", "zh": "确保 SLB 实例部署在专有网络（VPC）中。"}, Reason: models.I18nString{"en": "Classic network is deprecated and offers less security and isolation than VPC.", "zh": "经典网络已弃用，其安全性和隔离性均不如 VPC。"}, Recommendation: models.I18nString{"en": "Create SLB instances within a VPC.", "zh": "在 VPC 内创建 SLB 实例。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-loadbalancer-in-vpc.rego", PackageName: "infraguard.rules.aliyun.slb_loadbalancer_in_vpc", Content: "package infraguard.rules.aliyun.slb_loadbalancer_in_vpc\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-loadbalancer-in-vpc\",\n\t\"name\": {\n\t\t\"en\": \"SLB in VPC Check\",\n\t\t\"zh\": \"强制 SLB 部署在 VPC 环境中\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLB instances are deployed within a Virtual Private Cloud (VPC).\",\n\t\t\"zh\": \"确保 SLB 实例部署在专有网络（VPC）中。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Classic network is deprecated and offers less security and isolation than VPC.\",\n\t\t\"zh\": \"经典网络已弃用，其安全性和隔离性均不如 VPC。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Create SLB instances within a VPC.\",\n\t\t\"zh\": \"在 VPC 内创建 SLB 实例。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\thelpers.has_property(resource, \"VpcId\")\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"VpcId\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-master-slave-server-group-multi-zone", Name: models.I18nString{"en": "SLB Master-Slave Server Group Multi-Zone", "zh": "SLB 负载均衡主备服务器组添加多个可用区资源"}, Severity: "medium", Description: models.I18nString{"en": "The master-slave server group of SLB instances should have resources distributed across multiple availability zones.", "zh": "SLB 负载均衡的主备服务器组挂载资源分布在多个可用区，视为合规。主备服务器组无挂载任何资源时不适用本规则，视为不适用。"}, Reason: models.I18nString{"en": "Single-zone master-slave servers create a single point of failure and reduce availability.", "zh": "单可用区主备服务器创建单点故障并降低可用性。"}, Recommendation: models.I18nString{"en": "Distribute master and slave servers across different availability zones.", "zh": "将主服务器和从服务器分布在不同的可用区。"}, ResourceTypes: []string{"ALIYUN::SLB::MasterSlaveServerGroup"}, FilePath: "aliyun/rules/slb-master-slave-server-group-multi-zone.rego", PackageName: "infraguard.rules.aliyun.slb_master_slave_server_group_multi_zone", Content: "package infraguard.rules.aliyun.slb_master_slave_server_group_multi_zone\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-master-slave-server-group-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLB Master-Slave Server Group Multi-Zone\",\n\t\t\"zh\": \"SLB 负载均衡主备服务器组添加多个可用区资源\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"The master-slave server group of SLB instances should have resources distributed across multiple availability zones.\",\n\t\t\"zh\": \"SLB 负载均衡的主备服务器组挂载资源分布在多个可用区，视为合规。主备服务器组无挂载任何资源时不适用本规则，视为不适用。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Single-zone master-slave servers create a single point of failure and reduce availability.\",\n\t\t\"zh\": \"单可用区主备服务器创建单点故障并降低可用性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Distribute master and slave servers across different availability zones.\",\n\t\t\"zh\": \"将主服务器和从服务器分布在不同的可用区。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::MasterSlaveServerGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::MasterSlaveServerGroup\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-modify-protection-check", Name: models.I18nString{"en": "SLB Modification Protection Enabled", "zh": "SLB 实例开启配置修改保护"}, Severity: "low", Description: models.I18nString{"en": "Ensures that SLB instances have modification protection enabled.", "zh": "确保 SLB 实例开启了配置修改保护。"}, Reason: models.I18nString{"en": "If modification protection is not enabled, the SLB configuration may be modified accidentally, causing service issues.", "zh": "如果未开启配置修改保护，SLB 配置可能会被意外修改，导致服务异常。"}, Recommendation: models.I18nString{"en": "Enable modification protection for the SLB instance.", "zh": "为 SLB 实例开启配置修改保护功能。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-modify-protection-check.rego", PackageName: "infraguard.rules.aliyun.slb_modify_protection_check", Content: "package infraguard.rules.aliyun.slb_modify_protection_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"slb-modify-protection-check\",\n\t\"name\": {\n\t\t\"en\": \"SLB Modification Protection Enabled\",\n\t\t\"zh\": \"SLB 实例开启配置修改保护\",\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that SLB instances have modification protection enabled.\",\n\t\t\"zh\": \"确保 SLB 实例开启了配置修改保护。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"If modification protection is not enabled, the SLB configuration may be modified accidentally, causing service issues.\",\n\t\t\"zh\": \"如果未开启配置修改保护，SLB 配置可能会被意外修改，导致服务异常。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable modification protection for the SLB instance.\",\n\t\t\"zh\": \"为 SLB 实例开启配置修改保护功能。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_compliant(resource) if {\n\thelpers.get_property(resource, \"ModificationProtectionStatus\", \"\") == \"ConsoleProtection\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ModificationProtectionStatus\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-no-public-ip", Name: models.I18nString{"en": "SLB Instance No Public IP", "zh": "SLB 实例未开启公网访问"}, Severity: "medium", Description: models.I18nString{"en": "SLB instances should not have public IP addresses to reduce attack surface.", "zh": "SLB 实例网络类型为内网，视为合规。"}, Reason: models.I18nString{"en": "Publicly accessible SLB instances increase the attack surface and may expose services to unwanted internet traffic.", "zh": "可公开访问的 SLB 实例增加了攻击面，可能将服务暴露给非预期的互联网流量。"}, Recommendation: models.I18nString{"en": "Use intranet-facing SLB instances for internal services.", "zh": "对内部服务使用内网类型的 SLB 实例。"}, ResourceTypes: []string{"ALIYUN::SLB::LoadBalancer"}, FilePath: "aliyun/rules/slb-no-public-ip.rego", PackageName: "infraguard.rules.aliyun.slb_no_public_ip", Content: "package infraguard.rules.aliyun.slb_no_public_ip\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"slb-no-public-ip\",\n\t\"name\": {\n\t\t\"en\": \"SLB Instance No Public IP\",\n\t\t\"zh\": \"SLB 实例未开启公网访问\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"SLB instances should not have public IP addresses to reduce attack surface.\",\n\t\t\"zh\": \"SLB 实例网络类型为内网，视为合规。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Publicly accessible SLB instances increase the attack surface and may expose services to unwanted internet traffic.\",\n\t\t\"zh\": \"可公开访问的 SLB 实例增加了攻击面，可能将服务暴露给非预期的互联网流量。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Use intranet-facing SLB instances for internal services.\",\n\t\t\"zh\": \"对内部服务使用内网类型的 SLB 实例。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::LoadBalancer\"],\n}\n\nis_internal(resource) if {\n\taddress_type := helpers.get_property(resource, \"AddressType\", \"\")\n\taddress_type == \"intranet\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::LoadBalancer\")\n\tnot is_internal(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"AddressType\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:slb-vserver-group-multi-zone", Name: models.I18nString{"en": "SLB VServer Group Multi-Zone Deployment", "zh": "SLB 虚拟服务器组多可用区部署"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that SLB virtual server groups contain instances from multiple availability zones.", "zh": "确保 SLB 虚拟服务器组包含来自多个可用区的实例。"}, Reason: models.I18nString{"en": "Deploying backend instances in multiple zones ensures high availability for the service.", "zh": "在多个可用区部署后端实例可确保服务的高可用性。"}, Recommendation: models.I18nString{"en": "Add instances from at least two different availability zones to the virtual server group.", "zh": "向虚拟服务器组中添加来自至少两个不同可用区的实例。"}, ResourceTypes: []string{"ALIYUN::SLB::VServerGroup"}, FilePath: "aliyun/rules/slb-vserver-group-multi-zone.rego", PackageName: "infraguard.rules.aliyun.slb_vserver_group_multi_zone", Content: "package infraguard.rules.aliyun.slb_vserver_group_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"slb-vserver-group-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLB VServer Group Multi-Zone Deployment\",\n\t\t\"zh\": \"SLB 虚拟服务器组多可用区部署\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that SLB virtual server groups contain instances from multiple availability zones.\",\n\t\t\"zh\": \"确保 SLB 虚拟服务器组包含来自多个可用区的实例。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Deploying backend instances in multiple zones ensures high availability for the service.\",\n\t\t\"zh\": \"在多个可用区部署后端实例可确保服务的高可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add instances from at least two different availability zones to the virtual server group.\",\n\t\t\"zh\": \"向虚拟服务器组中添加来自至少两个不同可用区的实例。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLB::VServerGroup\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLB::VServerGroup\")\n\n\t# Conceptual check for multi-zone\n\tnot helpers.has_property(resource, \"BackendServers\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sls-logstore-enabled-encrypt", Name: models.I18nString{"en": "SLS Logstore Encryption Enabled", "zh": "SLS 日志库开启数据加密"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLS Logstores have server-side encryption enabled.", "zh": "确保 SLS 日志库开启了服务端加密。"}, Reason: models.I18nString{"en": "Encryption protects sensitive log data at rest.", "zh": "加密可以保护静态的敏感日志数据。"}, Recommendation: models.I18nString{"en": "Enable encryption for the SLS Logstore using KMS.", "zh": "使用 KMS 为 SLS 日志库启用加密。"}, ResourceTypes: []string{"ALIYUN::SLS::Logstore"}, FilePath: "aliyun/rules/sls-logstore-enabled-encrypt.rego", PackageName: "infraguard.rules.aliyun.sls_logstore_enabled_encrypt", Content: "package infraguard.rules.aliyun.sls_logstore_enabled_encrypt\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"sls-logstore-enabled-encrypt\",\n\t\"name\": {\n\t\t\"en\": \"SLS Logstore Encryption Enabled\",\n\t\t\"zh\": \"SLS 日志库开启数据加密\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLS Logstores have server-side encryption enabled.\",\n\t\t\"zh\": \"确保 SLS 日志库开启了服务端加密。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Encryption protects sensitive log data at rest.\",\n\t\t\"zh\": \"加密可以保护静态的敏感日志数据。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable encryption for the SLS Logstore using KMS.\",\n\t\t\"zh\": \"使用 KMS 为 SLS 日志库启用加密。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLS::Logstore\"],\n}\n\nis_compliant(resource) if {\n\t# Check EncryptConf\n\tencrypt := helpers.get_property(resource, \"EncryptConf\", {})\n\tcount(encrypt) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLS::Logstore\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EncryptConf\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sls-logstore-encrypt-key-origin-check", Name: models.I18nString{"en": "SLS Logstore Encryption Key Origin Check", "zh": "日志服务日志库加密使用的主密钥材料来源为用户自行导入"}, Severity: "medium", Description: models.I18nString{"en": "Ensures SLS Logstores use externally imported key material (BYOK) for encryption, which provides better control over encryption keys.", "zh": "确保 SLS 日志库使用外部导入的密钥材料（BYOK）进行加密，以更好地控制加密密钥。"}, Reason: models.I18nString{"en": "Using externally imported key material provides better control over encryption keys and enhances security posture.", "zh": "使用外部导入的密钥材料可以更好地控制加密密钥并增强安全性。"}, Recommendation: models.I18nString{"en": "Configure the Logstore to use BYOK encryption with externally imported key material.", "zh": "配置日志库使用 BYOK 加密，导入外部密钥材料。"}, ResourceTypes: []string{"ALIYUN::SLS::Logstore"}, FilePath: "aliyun/rules/sls-logstore-encrypt-key-origin-check.rego", PackageName: "infraguard.rules.aliyun.sls_logstore_encrypt_key_origin_check", Content: "package infraguard.rules.aliyun.sls_logstore_encrypt_key_origin_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"sls-logstore-encrypt-key-origin-check\",\n\t\"name\": {\n\t\t\"en\": \"SLS Logstore Encryption Key Origin Check\",\n\t\t\"zh\": \"日志服务日志库加密使用的主密钥材料来源为用户自行导入\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLS Logstores use externally imported key material (BYOK) for encryption, which provides better control over encryption keys.\",\n\t\t\"zh\": \"确保 SLS 日志库使用外部导入的密钥材料（BYOK）进行加密，以更好地控制加密密钥。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Using externally imported key material provides better control over encryption keys and enhances security posture.\",\n\t\t\"zh\": \"使用外部导入的密钥材料可以更好地控制加密密钥并增强安全性。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the Logstore to use BYOK encryption with externally imported key material.\",\n\t\t\"zh\": \"配置日志库使用 BYOK 加密，导入外部密钥材料。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLS::Logstore\"],\n}\n\n# Check if encryption is enabled with BYOK (externally imported key)\nis_compliant(resource) if {\n\t# Direct access to nested properties\n\tencrypt := resource.Properties.EncryptConf\n\tencrypt != null\n\tencrypt.Enable == true\n\n\t# Check for BYOK configuration - UserCmkInfo with CmkKeyId indicates BYOK\n\tuser_cmk := encrypt.UserCmkInfo\n\tuser_cmk != null\n\tuser_cmk.CmkKeyId != \"\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLS::Logstore\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EncryptConf\", \"UserCmkInfo\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sls-logstore-hot-ttl-check", Name: models.I18nString{"en": "SLS Logstore Smart Tier Storage Enabled", "zh": "SLS 日志库开启智能冷热分层存储"}, Severity: "low", Description: models.I18nString{"en": "Ensures SLS Logstores have intelligent hot/cold tier storage enabled for cost optimization.", "zh": "确保 SLS 日志库开启了智能冷热分层存储功能以优化成本。"}, Reason: models.I18nString{"en": "Hot/cold tier storage helps optimize costs by automatically moving less frequently accessed data to cheaper storage.", "zh": "智能冷热分层存储通过将访问频率较低的数据自动移动到更便宜的存储层来帮助优化成本。"}, Recommendation: models.I18nString{"en": "Enable intelligent hot/cold tier storage for the Logstore.", "zh": "为日志库启用智能冷热分层存储功能。"}, ResourceTypes: []string{"ALIYUN::SLS::Logstore"}, FilePath: "aliyun/rules/sls-logstore-hot-ttl-check.rego", PackageName: "infraguard.rules.aliyun.sls_logstore_hot_ttl_check", Content: "package infraguard.rules.aliyun.sls_logstore_hot_ttl_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"sls-logstore-hot-ttl-check\",\n\t\"name\": {\n\t\t\"en\": \"SLS Logstore Smart Tier Storage Enabled\",\n\t\t\"zh\": \"SLS 日志库开启智能冷热分层存储\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures SLS Logstores have intelligent hot/cold tier storage enabled for cost optimization.\",\n\t\t\"zh\": \"确保 SLS 日志库开启了智能冷热分层存储功能以优化成本。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Hot/cold tier storage helps optimize costs by automatically moving less frequently accessed data to cheaper storage.\",\n\t\t\"zh\": \"智能冷热分层存储通过将访问频率较低的数据自动移动到更便宜的存储层来帮助优化成本。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable intelligent hot/cold tier storage for the Logstore.\",\n\t\t\"zh\": \"为日志库启用智能冷热分层存储功能。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::SLS::Logstore\"],\n}\n\nis_compliant(resource) if {\n\t# Check TTL - hot storage enabled when TTL > 7 days\n\t# Standard tier with TTL > 7 days indicates hot storage is available\n\tttl := helpers.get_property(resource, \"TTL\", 0)\n\tttl > 7\n\n\t# Check that PreserveStorage is not true (if true, TTL is ignored)\n\tpreserve := helpers.get_property(resource, \"PreserveStorage\", false)\n\tpreserve != true\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLS::Logstore\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TTL\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:sls-project-multi-zone", Name: models.I18nString{"en": "SLS Project Zone-Redundant Storage", "zh": "SLS 项目使用同城冗余存储"}, Severity: "medium", Description: models.I18nString{"en": "SLS projects should use zone-redundant storage (ZRS) for high availability and data durability.", "zh": "SLS 项目应使用同城冗余存储（ZRS）以实现高可用性和数据持久性。"}, Reason: models.I18nString{"en": "The SLS project does not use zone-redundant storage, which may affect data availability.", "zh": "SLS 项目未使用同城冗余存储，可能影响数据可用性。"}, Recommendation: models.I18nString{"en": "Enable zone-redundant storage by setting DataRedundancyType to 'ZRS' when creating the project.", "zh": "在创建项目时通过将 DataRedundancyType 设置为'ZRS'来启用同城冗余存储。"}, ResourceTypes: []string{"ALIYUN::SLS::Project"}, FilePath: "aliyun/rules/sls-project-multi-zone.rego", PackageName: "infraguard.rules.aliyun.sls_project_multi_zone", Content: "package infraguard.rules.aliyun.sls_project_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"sls-project-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"SLS Project Zone-Redundant Storage\",\n\t\t\"zh\": \"SLS 项目使用同城冗余存储\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"SLS projects should use zone-redundant storage (ZRS) for high availability and data durability.\",\n\t\t\"zh\": \"SLS 项目应使用同城冗余存储（ZRS）以实现高可用性和数据持久性。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The SLS project does not use zone-redundant storage, which may affect data availability.\",\n\t\t\"zh\": \"SLS 项目未使用同城冗余存储，可能影响数据可用性。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable zone-redundant storage by setting DataRedundancyType to 'ZRS' when creating the project.\",\n\t\t\"zh\": \"在创建项目时通过将 DataRedundancyType 设置为'ZRS'来启用同城冗余存储。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::SLS::Project\"],\n}\n\n# Check if project has ZRS enabled\nhas_zrs_enabled(resource) if {\n\tredundancy_type := helpers.get_property(resource, \"DataRedundancyType\", \"LRS\")\n\tredundancy_type == \"ZRS\"\n}\n\n# Deny rule: SLS projects should have ZRS enabled\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::SLS::Project\")\n\tnot has_zrs_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DataRedundancyType\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:transit-router-vpc-attachment-multi-zone", Name: models.I18nString{"en": "Transit Router VPC Attachment Multi-Zone Configuration", "zh": "为转发路由器 VPC 连接设置多个可用区"}, Severity: "high", Description: models.I18nString{"en": "Transit Router VPC attachments should be configured with vSwitches in at least two different availability zones for cross-zone high availability.", "zh": "为转发路由器的 VPC 连接设置两个分布在不同可用区的交换机，保障产品跨可用区的高可用性，视为合规。"}, Reason: models.I18nString{"en": "The Transit Router VPC attachment is configured with vSwitches in only one availability zone, creating a single point of failure.", "zh": "转发路由器 VPC 连接仅配置了一个可用区的交换机，存在单点故障风险。"}, Recommendation: models.I18nString{"en": "Configure at least two vSwitches in different availability zones in the ZoneMappings property.", "zh": "在 ZoneMappings 属性中配置至少两个不同可用区的交换机。"}, ResourceTypes: []string{"ALIYUN::CEN::TransitRouterVpcAttachment"}, FilePath: "aliyun/rules/transit-router-vpc-attachment-multi-zone.rego", PackageName: "infraguard.rules.aliyun.transit_router_vpc_attachment_multi_zone", Content: "package infraguard.rules.aliyun.transit_router_vpc_attachment_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"transit-router-vpc-attachment-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"Transit Router VPC Attachment Multi-Zone Configuration\",\n\t\t\"zh\": \"为转发路由器 VPC 连接设置多个可用区\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Transit Router VPC attachments should be configured with vSwitches in at least two different availability zones for cross-zone high availability.\",\n\t\t\"zh\": \"为转发路由器的 VPC 连接设置两个分布在不同可用区的交换机，保障产品跨可用区的高可用性，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The Transit Router VPC attachment is configured with vSwitches in only one availability zone, creating a single point of failure.\",\n\t\t\"zh\": \"转发路由器 VPC 连接仅配置了一个可用区的交换机，存在单点故障风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure at least two vSwitches in different availability zones in the ZoneMappings property.\",\n\t\t\"zh\": \"在 ZoneMappings 属性中配置至少两个不同可用区的交换机。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::CEN::TransitRouterVpcAttachment\"],\n}\n\n# Get unique zone IDs from zone mappings\nunique_zones(zone_mappings) := zones if {\n\tzones := {zone_id |\n\t\tsome mapping in zone_mappings\n\t\tzone_id := mapping.ZoneId\n\t}\n}\n\n# Check if attachment has multiple zones\nhas_multiple_zones(resource) if {\n\tzone_mappings := resource.Properties.ZoneMappings\n\tzones := unique_zones(zone_mappings)\n\tcount(zones) >= 2\n}\n\n# Deny rule: Transit Router VPC attachments must have vSwitches in multiple zones\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::CEN::TransitRouterVpcAttachment\")\n\tnot has_multiple_zones(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"ZoneMappings\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:tsdb-instance-security-ip-check", Name: models.I18nString{"en": "TSDB Instance Does Not Allow Any IP Access", "zh": "TSDB 实例安全白名单检测"}, Severity: "high", Description: models.I18nString{"en": "Ensures that TSDB instances do not have security whitelists that allow all IPs.", "zh": "TSDB 实例没有开启任意 IP 访问，视为合规。"}, Reason: models.I18nString{"en": "TSDB instance allows access from any IP address, which is a security risk.", "zh": "TSDB 实例开启任意 IP 访问，存在安全风险。"}, Recommendation: models.I18nString{"en": "Configure security whitelist to restrict access to specific IPs.", "zh": "请配置安全白名单以限制特定 IP 访问。"}, ResourceTypes: []string{"ALIYUN::TSDB::HiTSDBInstance"}, FilePath: "aliyun/rules/tsdb-instance-security-ip-check.rego", PackageName: "infraguard.rules.aliyun.tsdb_instance_security_ip_check", Content: "package infraguard.rules.aliyun.tsdb_instance_security_ip_check\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"tsdb-instance-security-ip-check\",\n\t\"name\": {\n\t\t\"en\": \"TSDB Instance Does Not Allow Any IP Access\",\n\t\t\"zh\": \"TSDB 实例安全白名单检测\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that TSDB instances do not have security whitelists that allow all IPs.\",\n\t\t\"zh\": \"TSDB 实例没有开启任意 IP 访问，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"TSDB instance allows access from any IP address, which is a security risk.\",\n\t\t\"zh\": \"TSDB 实例开启任意 IP 访问，存在安全风险。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure security whitelist to restrict access to specific IPs.\",\n\t\t\"zh\": \"请配置安全白名单以限制特定 IP 访问。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::TSDB::HiTSDBInstance\"],\n}\n\n# Check if whitelist allows any IP\nallows_any_ip(whitelist) if {\n\tcount(whitelist) == 1\n\twhitelist[0] == \"0.0.0.0/0\"\n}\n\nallows_any_ip(whitelist) if {\n\tcount(whitelist) == 1\n\twhitelist[0] == \"0.0.0.0\"\n}\n\nallows_any_ip(whitelist) := false if {\n\tcount(whitelist) != 1\n}\n\nallows_any_ip(whitelist) := false if {\n\tcount(whitelist) == 1\n\twhitelist[0] != \"0.0.0.0/0\"\n\twhitelist[0] != \"0.0.0.0\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::TSDB::HiTSDBInstance\")\n\n\twhitelist := resource.Properties.SecurityIpList\n\tallows_any_ip(whitelist)\n\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"SecurityIpList\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:use-waf-instance-for-security-protection", Name: models.I18nString{"en": "Use WAF for Security Protection", "zh": "使用 WEB 防火墙对网站或 APP 进行安全防护"}, Severity: "high", Description: models.I18nString{"en": "WEB Application Firewall (WAF) should be used to protect websites and APPs from web-based attacks.", "zh": "使用 WEB 防火墙对网站或 APP 进行安全防护，视为合规。"}, Reason: models.I18nString{"en": "The ALB instance does not have WAF enabled, leaving web assets vulnerable to attacks.", "zh": "ALB 实例未启用 WAF 防护，使 Web 资产容易受到攻击。"}, Recommendation: models.I18nString{"en": "Enable WAF for the ALB instance by setting LoadBalancerEdition to 'StandardWithWaf'.", "zh": "通过将 LoadBalancerEdition 设置为 'StandardWithWaf' 为 ALB 实例开启 WAF 防护。"}, ResourceTypes: []string{"ALIYUN::ALB::LoadBalancer"}, FilePath: "aliyun/rules/use-waf-instance-for-security-protection.rego", PackageName: "infraguard.rules.aliyun.use_waf_instance_for_security_protection", Content: "package infraguard.rules.aliyun.use_waf_instance_for_security_protection\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"use-waf-instance-for-security-protection\",\n\t\"name\": {\n\t\t\"en\": \"Use WAF for Security Protection\",\n\t\t\"zh\": \"使用 WEB 防火墙对网站或 APP 进行安全防护\",\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"WEB Application Firewall (WAF) should be used to protect websites and APPs from web-based attacks.\",\n\t\t\"zh\": \"使用 WEB 防火墙对网站或 APP 进行安全防护，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The ALB instance does not have WAF enabled, leaving web assets vulnerable to attacks.\",\n\t\t\"zh\": \"ALB 实例未启用 WAF 防护，使 Web 资产容易受到攻击。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable WAF for the ALB instance by setting LoadBalancerEdition to 'StandardWithWaf'.\",\n\t\t\"zh\": \"通过将 LoadBalancerEdition 设置为 'StandardWithWaf' 为 ALB 实例开启 WAF 防护。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ALB::LoadBalancer\"],\n}\n\n# Check if ALB has WAF enabled via its edition\nis_waf_enabled(resource) if {\n\thelpers.get_property(resource, \"LoadBalancerEdition\", \"\") == \"StandardWithWaf\"\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_waf_enabled(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LoadBalancerEdition\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpc-flow-logs-enabled", Name: models.I18nString{"en": "VPC Flow Logs Enabled", "zh": "VPC 开启流日志"}, Severity: "medium", Description: models.I18nString{"en": "Ensures VPC flow logs are enabled for monitoring network traffic.", "zh": "确保 VPC 开启了流日志，以便监控网络流量。"}, Reason: models.I18nString{"en": "Flow logs provide visibility into network traffic patterns and help in security auditing.", "zh": "流日志提供了网络流量模式的可见性，有助于安全审计。"}, Recommendation: models.I18nString{"en": "Add ALIYUN::VPC::FlowLog resource to enable flow logs for the VPC.", "zh": "添加 ALIYUN::VPC::FlowLog 资源以为 VPC 开启流日志。"}, ResourceTypes: []string{"ALIYUN::ECS::VPC"}, FilePath: "aliyun/rules/vpc-flow-logs-enabled.rego", PackageName: "infraguard.rules.aliyun.vpc_flow_logs_enabled", Content: "package infraguard.rules.aliyun.vpc_flow_logs_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"vpc-flow-logs-enabled\",\n\t\"name\": {\n\t\t\"en\": \"VPC Flow Logs Enabled\",\n\t\t\"zh\": \"VPC 开启流日志\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures VPC flow logs are enabled for monitoring network traffic.\",\n\t\t\"zh\": \"确保 VPC 开启了流日志，以便监控网络流量。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Flow logs provide visibility into network traffic patterns and help in security auditing.\",\n\t\t\"zh\": \"流日志提供了网络流量模式的可见性，有助于安全审计。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add ALIYUN::VPC::FlowLog resource to enable flow logs for the VPC.\",\n\t\t\"zh\": \"添加 ALIYUN::VPC::FlowLog 资源以为 VPC 开启流日志。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::VPC\"],\n}\n\n# Cross-resource check: is there a FlowLog resource for this VPC?\nhas_flow_log(vpc_id) if {\n\tsome name, res in helpers.resources_by_type(\"ALIYUN::VPC::FlowLog\")\n\thelpers.is_referencing(helpers.get_property(res, \"ResourceId\", \"\"), vpc_id)\n}\n\ndeny contains result if {\n\tsome vpc_id, resource in helpers.resources_by_type(\"ALIYUN::ECS::VPC\")\n\tnot has_flow_log(vpc_id)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": vpc_id,\n\t\t\"violation_path\": [],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpc-network-acl-not-empty", Name: models.I18nString{"en": "VPC Network ACL Not Empty", "zh": "专有网络 ACL 不为空条目"}, Severity: "medium", Description: models.I18nString{"en": "Ensures VPC Network ACLs have at least one rule configured.", "zh": "确保 VPC 网络 ACL 至少配置了一条规则。"}, Reason: models.I18nString{"en": "An empty ACL provides no security filtering, which might lead to unintended access.", "zh": "空的 ACL 不提供任何安全过滤，可能导致非预期的访问。"}, Recommendation: models.I18nString{"en": "Add ingress and egress rules to the VPC Network ACL.", "zh": "为 VPC 网络 ACL 添加进方向和出方向规则。"}, ResourceTypes: []string{"ALIYUN::VPC::NetworkAcl"}, FilePath: "aliyun/rules/vpc-network-acl-not-empty.rego", PackageName: "infraguard.rules.aliyun.vpc_network_acl_not_empty", Content: "package infraguard.rules.aliyun.vpc_network_acl_not_empty\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"vpc-network-acl-not-empty\",\n\t\"name\": {\n\t\t\"en\": \"VPC Network ACL Not Empty\",\n\t\t\"zh\": \"专有网络 ACL 不为空条目\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures VPC Network ACLs have at least one rule configured.\",\n\t\t\"zh\": \"确保 VPC 网络 ACL 至少配置了一条规则。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"An empty ACL provides no security filtering, which might lead to unintended access.\",\n\t\t\"zh\": \"空的 ACL 不提供任何安全过滤，可能导致非预期的访问。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Add ingress and egress rules to the VPC Network ACL.\",\n\t\t\"zh\": \"为 VPC 网络 ACL 添加进方向和出方向规则。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::NetworkAcl\"],\n}\n\nis_compliant(resource) if {\n\tentries := helpers.get_property(resource, \"IngressAclEntries\", [])\n\tcount(entries) > 0\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::NetworkAcl\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"IngressAclEntries\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpc-network-acl-risky-ports-check", Name: models.I18nString{"en": "VPC Network ACL Risky Ports Check", "zh": "VPC 网络 ACL 禁用高风险端口"}, Severity: "high", Description: models.I18nString{"en": "Ensures VPC Network ACLs do not allow unrestricted access to risky ports (22, 3389).", "zh": "确保 VPC 网络 ACL 不允许对风险端口（22, 3389）的无限制访问。"}, Reason: models.I18nString{"en": "Opening management ports to all IPs (0.0.0.0/0) creates a significant security risk.", "zh": "向所有 IP（0.0.0.0/0）开放管理端口会造成重大的安全风险。"}, Recommendation: models.I18nString{"en": "Restrict access to ports 22 and 3389 to specific trusted IP ranges.", "zh": "将对 22 和 3389 端口的访问限制在特定的可信 IP 范围内。"}, ResourceTypes: []string{"ALIYUN::VPC::NetworkAcl"}, FilePath: "aliyun/rules/vpc-network-acl-risky-ports-check.rego", PackageName: "infraguard.rules.aliyun.vpc_network_acl_risky_ports_check", Content: "package infraguard.rules.aliyun.vpc_network_acl_risky_ports_check\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"vpc-network-acl-risky-ports-check\",\n\t\"name\": {\n\t\t\"en\": \"VPC Network ACL Risky Ports Check\",\n\t\t\"zh\": \"VPC 网络 ACL 禁用高风险端口\"\n\t},\n\t\"severity\": \"high\",\n\t\"description\": {\n\t\t\"en\": \"Ensures VPC Network ACLs do not allow unrestricted access to risky ports (22, 3389).\",\n\t\t\"zh\": \"确保 VPC 网络 ACL 不允许对风险端口（22, 3389）的无限制访问。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Opening management ports to all IPs (0.0.0.0/0) creates a significant security risk.\",\n\t\t\"zh\": \"向所有 IP（0.0.0.0/0）开放管理端口会造成重大的安全风险。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Restrict access to ports 22 and 3389 to specific trusted IP ranges.\",\n\t\t\"zh\": \"将对 22 和 3389 端口的访问限制在特定的可信 IP 范围内。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::NetworkAcl\"],\n}\n\nrisky_ports := [22, 3389]\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::NetworkAcl\")\n\tentries := helpers.get_property(resource, \"IngressAclEntries\", [])\n\tsome entry in entries\n\tentry.Policy == \"accept\"\n\thelpers.is_public_cidr(entry.SourceCidrIp)\n\tport_is_risky(entry.Port, risky_ports)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"IngressAclEntries\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n\nport_is_risky(port, _) if {\n\tport == \"all\"\n}\n\nport_is_risky(port, target_ports) if {\n\tis_number(port)\n\tport in target_ports\n}\n\nport_is_risky(port, target_ports) if {\n\tis_string(port)\n\tparts := split(port, \"/\")\n\tcount(parts) == 2\n\tstart := to_number(parts[0])\n\tend := to_number(parts[1])\n\tsome p in target_ports\n\tp >= start\n\tp <= end\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpn-connection-master-slave-established", Name: models.I18nString{"en": "VPN Connection Dual Tunnel Established", "zh": "双隧道 VPN 网关主备隧道都已建立连接"}, Severity: "medium", Description: models.I18nString{"en": "Use dual-tunnel VPN gateway and both master and slave tunnels are established with the peer.", "zh": "使用双隧道的 VPN 网关同时主备隧道都已和对端建立连接。"}, Reason: models.I18nString{"en": "The VPN connection does not have dual tunnels configured.", "zh": "VPN 连接未配置双隧道。"}, Recommendation: models.I18nString{"en": "Configure the VPN connection with both master and slave tunnels using TunnelOptionsSpecification.", "zh": "使用 TunnelOptionsSpecification 配置 VPN 连接的主备隧道。"}, ResourceTypes: []string{"ALIYUN::VPC::VpnConnection"}, FilePath: "aliyun/rules/vpn-connection-master-slave-established.rego", PackageName: "infraguard.rules.aliyun.vpn_connection_master_slave_established", Content: "package infraguard.rules.aliyun.vpn_connection_master_slave_established\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\nrule_meta := {\n\t\"id\": \"vpn-connection-master-slave-established\",\n\t\"name\": {\n\t\t\"en\": \"VPN Connection Dual Tunnel Established\",\n\t\t\"zh\": \"双隧道 VPN 网关主备隧道都已建立连接\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Use dual-tunnel VPN gateway and both master and slave tunnels are established with the peer.\",\n\t\t\"zh\": \"使用双隧道的 VPN 网关同时主备隧道都已和对端建立连接。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The VPN connection does not have dual tunnels configured.\",\n\t\t\"zh\": \"VPN 连接未配置双隧道。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure the VPN connection with both master and slave tunnels using TunnelOptionsSpecification.\",\n\t\t\"zh\": \"使用 TunnelOptionsSpecification 配置 VPN 连接的主备隧道。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::VpnConnection\"],\n}\n\n# Check if VPN connection has dual tunnels configured\nis_dual_tunnel(resource) if {\n\tcount(object.get(resource.Properties, \"TunnelOptionsSpecification\", [])) >= 2\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_dual_tunnel(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"TunnelOptionsSpecification\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpn-gateway-enabled-ssl-vpn", Name: models.I18nString{"en": "VPN Gateway SSL-VPN Enabled", "zh": "VPN 网关开启 SSL-VPN"}, Severity: "low", Description: models.I18nString{"en": "Ensures the VPN gateway has SSL-VPN enabled for secure client access.", "zh": "确保 VPN 网关开启了 SSL-VPN，以便客户端安全访问。"}, Reason: models.I18nString{"en": "SSL-VPN provides a secure way for remote users to access internal network resources.", "zh": "SSL-VPN 为远程用户访问内部网络资源提供了一种安全的方式。"}, Recommendation: models.I18nString{"en": "Set EnableSsl to 'true' for the VPN Gateway.", "zh": "为 VPN 网关将 EnableSsl 设置为 'true'。"}, ResourceTypes: []string{"ALIYUN::VPC::VpnGateway"}, FilePath: "aliyun/rules/vpn-gateway-enabled-ssl-vpn.rego", PackageName: "infraguard.rules.aliyun.vpn_gateway_enabled_ssl_vpn", Content: "package infraguard.rules.aliyun.vpn_gateway_enabled_ssl_vpn\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"vpn-gateway-enabled-ssl-vpn\",\n\t\"name\": {\n\t\t\"en\": \"VPN Gateway SSL-VPN Enabled\",\n\t\t\"zh\": \"VPN 网关开启 SSL-VPN\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures the VPN gateway has SSL-VPN enabled for secure client access.\",\n\t\t\"zh\": \"确保 VPN 网关开启了 SSL-VPN，以便客户端安全访问。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"SSL-VPN provides a secure way for remote users to access internal network resources.\",\n\t\t\"zh\": \"SSL-VPN 为远程用户访问内部网络资源提供了一种安全的方式。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Set EnableSsl to 'true' for the VPN Gateway.\",\n\t\t\"zh\": \"为 VPN 网关将 EnableSsl 设置为 'true'。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::VpnGateway\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"EnableSsl\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::VpnGateway\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"EnableSsl\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpn-gateway-multi-zone", Name: models.I18nString{"en": "VPN Gateway Multi-Zone Deployment", "zh": "使用多可用区的 VPN 网关"}, Severity: "medium", Description: models.I18nString{"en": "VPN Gateways should be configured with a disaster recovery VSwitch to support multi-zone availability.", "zh": "为 VPN 网关设置两个交换机，保障产品跨可用区的高可用性，视为合规。"}, Reason: models.I18nString{"en": "The VPN Gateway is not configured with a disaster recovery VSwitch.", "zh": "VPN 网关未配置容灾交换机。"}, Recommendation: models.I18nString{"en": "Configure DisasterRecoveryVSwitchId to enable dual-tunnel/multi-zone mode.", "zh": "配置 DisasterRecoveryVSwitchId 以启用双隧道/多可用区模式。"}, ResourceTypes: []string{"ALIYUN::VPC::VpnGateway"}, FilePath: "aliyun/rules/vpn-gateway-multi-zone.rego", PackageName: "infraguard.rules.aliyun.vpn_gateway_multi_zone", Content: "package infraguard.rules.aliyun.vpn_gateway_multi_zone\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"vpn-gateway-multi-zone\",\n\t\"name\": {\n\t\t\"en\": \"VPN Gateway Multi-Zone Deployment\",\n\t\t\"zh\": \"使用多可用区的 VPN 网关\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"VPN Gateways should be configured with a disaster recovery VSwitch to support multi-zone availability.\",\n\t\t\"zh\": \"为 VPN 网关设置两个交换机，保障产品跨可用区的高可用性，视为合规。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"The VPN Gateway is not configured with a disaster recovery VSwitch.\",\n\t\t\"zh\": \"VPN 网关未配置容灾交换机。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Configure DisasterRecoveryVSwitchId to enable dual-tunnel/multi-zone mode.\",\n\t\t\"zh\": \"配置 DisasterRecoveryVSwitchId 以启用双隧道/多可用区模式。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::VpnGateway\"],\n}\n\n# Check if instance is multi-zone\nis_multi_zone(resource) if {\n\t# Check if DisasterRecoveryVSwitchId is present and not empty\n\tobject.get(resource.Properties, \"DisasterRecoveryVSwitchId\", \"\") != \"\"\n}\n\n# Deny rule\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types(rule_meta.resource_types)\n\tnot is_multi_zone(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"DisasterRecoveryVSwitchId\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vpn-ipsec-connection-health-check-open", Name: models.I18nString{"en": "VPN IPsec Health Check Enabled", "zh": "VPN IPsec 连接开启健康检查"}, Severity: "low", Description: models.I18nString{"en": "Ensures VPN IPsec connections have health checks enabled to detect tunnel failures.", "zh": "确保 VPN IPsec 连接开启了健康检查，以便及时发现隧道故障。"}, Reason: models.I18nString{"en": "Health checks enable automatic failover and proactive monitoring of VPN stability.", "zh": "健康检查支持 VPN 稳定性的自动故障转移和主动监控。"}, Recommendation: models.I18nString{"en": "Enable health checks for the IPsec connection.", "zh": "为 IPsec 连接开启健康检查。"}, ResourceTypes: []string{"ALIYUN::VPC::VpnConnection"}, FilePath: "aliyun/rules/vpn-ipsec-connection-health-check-open.rego", PackageName: "infraguard.rules.aliyun.vpn_ipsec_connection_health_check_open", Content: "package infraguard.rules.aliyun.vpn_ipsec_connection_health_check_open\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"vpn-ipsec-connection-health-check-open\",\n\t\"name\": {\n\t\t\"en\": \"VPN IPsec Health Check Enabled\",\n\t\t\"zh\": \"VPN IPsec 连接开启健康检查\"\n\t},\n\t\"severity\": \"low\",\n\t\"description\": {\n\t\t\"en\": \"Ensures VPN IPsec connections have health checks enabled to detect tunnel failures.\",\n\t\t\"zh\": \"确保 VPN IPsec 连接开启了健康检查，以便及时发现隧道故障。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Health checks enable automatic failover and proactive monitoring of VPN stability.\",\n\t\t\"zh\": \"健康检查支持 VPN 稳定性的自动故障转移和主动监控。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable health checks for the IPsec connection.\",\n\t\t\"zh\": \"为 IPsec 连接开启健康检查。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::VPC::VpnConnection\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"HealthCheckConfig\", {}).Enable)\n}\n\n# Note: Properties might vary between IpsecConnection and IpsecServer in ROS.\n# Assuming ALIYUN::VPC::IpsecConnection for most tunnel checks.\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::VPC::VpnConnection\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"HealthCheckConfig\", \"Enable\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:vswitch-available-ip-count", Name: models.I18nString{"en": "VSwitch Available IP Count Check", "zh": "VSwitch 可用 IP 数量检测"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that the VSwitch has a sufficient number of available IP addresses.", "zh": "确保 VSwitch 具有足够数量的可用 IP 地址。"}, Reason: models.I18nString{"en": "Running out of available IP addresses prevents new resources from being created in the VSwitch.", "zh": "可用 IP 地址耗尽将阻止在 VSwitch 中创建新资源。"}, Recommendation: models.I18nString{"en": "Ensure that the VSwitch has enough available IP addresses or create a larger VSwitch.", "zh": "确保 VSwitch 具有足够的可用 IP 地址，或创建一个更大的 VSwitch。"}, ResourceTypes: []string{"ALIYUN::ECS::VSwitch"}, FilePath: "aliyun/rules/vswitch-available-ip-count.rego", PackageName: "infraguard.rules.aliyun.vswitch_available_ip_count", Content: "package infraguard.rules.aliyun.vswitch_available_ip_count\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"vswitch-available-ip-count\",\n\t\"name\": {\n\t\t\"en\": \"VSwitch Available IP Count Check\",\n\t\t\"zh\": \"VSwitch 可用 IP 数量检测\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that the VSwitch has a sufficient number of available IP addresses.\",\n\t\t\"zh\": \"确保 VSwitch 具有足够数量的可用 IP 地址。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Running out of available IP addresses prevents new resources from being created in the VSwitch.\",\n\t\t\"zh\": \"可用 IP 地址耗尽将阻止在 VSwitch 中创建新资源。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Ensure that the VSwitch has enough available IP addresses or create a larger VSwitch.\",\n\t\t\"zh\": \"确保 VSwitch 具有足够的可用 IP 地址，或创建一个更大的 VSwitch。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::ECS::VSwitch\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::ECS::VSwitch\")\n\n\t# Conceptual check for available IPs\n\t# Since it's runtime info, in template we might check CIDR size\n\tcidr := helpers.get_property(resource, \"CidrBlock\", \"\")\n\n\t# This is a bit complex to calculate accurately in Rego without helpers,\n\t# but we can detect very small subnets.\n\tendswith(cidr, \"/29\") # Example: Too small\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"CidrBlock\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:waf-instance-logging-enabled", Name: models.I18nString{"en": "WAF Instance Logging Enabled", "zh": "WAF 实例开启日志"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that logging is enabled for the WAF instance for auditing and security analysis.", "zh": "确保 WAF 实例开启了日志，以便进行审计和安全分析。"}, Reason: models.I18nString{"en": "WAF logs provide critical information about web attacks and traffic patterns.", "zh": "WAF 日志提供了关于 Web 攻击和流量模式的关键信息。"}, Recommendation: models.I18nString{"en": "Enable logging for the WAF instance.", "zh": "为 WAF 实例开启日志。"}, ResourceTypes: []string{"ALIYUN::WAF::Instance", "ALIYUN::WAF3::Instance"}, FilePath: "aliyun/rules/waf-instance-logging-enabled.rego", PackageName: "infraguard.rules.aliyun.waf_instance_logging_enabled", Content: "package infraguard.rules.aliyun.waf_instance_logging_enabled\n\nimport rego.v1\n\nimport data.infraguard.helpers\n\n# Rule metadata\nrule_meta := {\n\t\"id\": \"waf-instance-logging-enabled\",\n\t\"name\": {\n\t\t\"en\": \"WAF Instance Logging Enabled\",\n\t\t\"zh\": \"WAF 实例开启日志\",\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that logging is enabled for the WAF instance for auditing and security analysis.\",\n\t\t\"zh\": \"确保 WAF 实例开启了日志，以便进行审计和安全分析。\",\n\t},\n\t\"reason\": {\n\t\t\"en\": \"WAF logs provide critical information about web attacks and traffic patterns.\",\n\t\t\"zh\": \"WAF 日志提供了关于 Web 攻击和流量模式的关键信息。\",\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable logging for the WAF instance.\",\n\t\t\"zh\": \"为 WAF 实例开启日志。\",\n\t},\n\t\"resource_types\": [\"ALIYUN::WAF::Instance\", \"ALIYUN::WAF3::Instance\"],\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_types([\"ALIYUN::WAF::Instance\", \"ALIYUN::WAF3::Instance\"])\n\n\t# Conceptual check for logging\n\tnot helpers.has_property(resource, \"LogConfig\")\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\"],\n\t\t\"meta\": {\n\t\t\t\"severity\": rule_meta.severity,\n\t\t\t\"reason\": rule_meta.reason,\n\t\t\t\"recommendation\": rule_meta.recommendation,\n\t\t},\n\t}\n}\n"})
	addRule(&models.Rule{ID: "rule:aliyun:waf3-defense-resource-logging-enabled", Name: models.I18nString{"en": "WAF 3.0 Logging Enabled", "zh": "WAF 3.0 防护资源开启日志审计"}, Severity: "medium", Description: models.I18nString{"en": "Ensures that logging is enabled for resources protected by WAF 3.0.", "zh": "确保 WAF 3.0 防护的资源已开启日志审计。"}, Reason: models.I18nString{"en": "Logging is critical for tracking web attacks and security incidents.", "zh": "日志记录对于追踪网络攻击和安全事件至关重要。"}, Recommendation: models.I18nString{"en": "Enable log service for the WAF 3.0 instance.", "zh": "为 WAF 3.0 实例开启日志服务。"}, ResourceTypes: []string{"ALIYUN::WAF3::Instance"}, FilePath: "aliyun/rules/waf3-defense-resource-logging-enabled.rego", PackageName: "infraguard.rules.aliyun.waf3_defense_resource_logging_enabled", Content: "package infraguard.rules.aliyun.waf3_defense_resource_logging_enabled\n\nimport data.infraguard.helpers\nimport rego.v1\n\nrule_meta := {\n\t\"id\": \"waf3-defense-resource-logging-enabled\",\n\t\"name\": {\n\t\t\"en\": \"WAF 3.0 Logging Enabled\",\n\t\t\"zh\": \"WAF 3.0 防护资源开启日志审计\"\n\t},\n\t\"severity\": \"medium\",\n\t\"description\": {\n\t\t\"en\": \"Ensures that logging is enabled for resources protected by WAF 3.0.\",\n\t\t\"zh\": \"确保 WAF 3.0 防护的资源已开启日志审计。\"\n\t},\n\t\"reason\": {\n\t\t\"en\": \"Logging is critical for tracking web attacks and security incidents.\",\n\t\t\"zh\": \"日志记录对于追踪网络攻击和安全事件至关重要。\"\n\t},\n\t\"recommendation\": {\n\t\t\"en\": \"Enable log service for the WAF 3.0 instance.\",\n\t\t\"zh\": \"为 WAF 3.0 实例开启日志服务。\"\n\t},\n\t\"resource_types\": [\"ALIYUN::WAF3::Instance\"],\n}\n\nis_compliant(resource) if {\n\thelpers.is_true(helpers.get_property(resource, \"LogService\", false))\n}\n\ndeny contains result if {\n\tsome name, resource in helpers.resources_by_type(\"ALIYUN::WAF3::Instance\")\n\tnot is_compliant(resource)\n\tresult := {\n\t\t\"id\": rule_meta.id,\n\t\t\"resource_id\": name,\n\t\t\"violation_path\": [\"Properties\", \"LogService\"],\n\t\t\"meta\": {\"severity\": rule_meta.severity, \"reason\": rule_meta.reason, \"recommendation\": rule_meta.recommendation},\n\t}\n}\n"})

	addPack(&models.Pack{ID: "pack:aliyun:accesskey-permission-governance-best-practice", Name: models.I18nString{"en": "AccessKey and Permission Governance Best Practice", "zh": "AccessKey 及权限治理最佳实践"}, Description: models.I18nString{"en": "Best practices for AccessKey and permission governance", "zh": "AccessKey 及权限治理最佳实践"}, RuleIDs: []string{"rule:aliyun:ram-password-policy-check", "rule:aliyun:root-mfa-check", "rule:aliyun:root-ak-check", "rule:aliyun:actiontrail-trail-intact-enabled", "rule:aliyun:ack-cluster-rrsa-enabled", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:fc-service-bind-role", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-activated-ak-quantity-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:ram-user-login-check"}, FilePath: "aliyun/packs/accesskey-permission-governance-best-practice.rego", PackageName: "infraguard.packs.aliyun.accesskey_permission_governance_best_practice", Content: "package infraguard.packs.aliyun.accesskey_permission_governance_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"accesskey-permission-governance-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"AccessKey and Permission Governance Best Practice\",\n\t\t\"zh\": \"AccessKey 及权限治理最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for AccessKey and permission governance\",\n\t\t\"zh\": \"AccessKey 及权限治理最佳实践\",\n\t},\n\t\"rules\": [\n\t\t\"ram-password-policy-check\",\n\t\t\"root-mfa-check\",\n\t\t\"root-ak-check\",\n\t\t\"actiontrail-trail-intact-enabled\",\n\t\t\"ack-cluster-rrsa-enabled\",\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t\"fc-service-bind-role\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-activated-ak-quantity-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"ram-user-login-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:ai-model-training-architecture-best-practice", Name: models.I18nString{"en": "AI Model Training Architecture Best Practice", "zh": "AI 模型训练架构检测最佳实践"}, Description: models.I18nString{"en": "Best practices for AI model training architecture, covering ACK, ECS, NAS, OSS, VPC, and other resources.", "zh": "AI 模型训练架构最佳实践,涵盖 ACK、ECS、NAS、OSS、VPC 等资源。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-upgrade-latest-version", "rule:aliyun:ack-cluster-supported-version", "rule:aliyun:ack-cluster-encryption-enabled", "rule:aliyun:cr-instance-multi-zone", "rule:aliyun:cr-repository-immutablity-enable", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-image-expired-check", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:ecs-instance-not-bind-key-pair", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:kms-key-delete-protection-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:nas-filesystem-mount-target-access-group-check", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-tls-version-check", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:pai-eas-instances-multi-zone", "rule:aliyun:vpc-flow-logs-enabled", "rule:aliyun:vswitch-available-ip-count", "rule:aliyun:sls-project-multi-zone"}, FilePath: "aliyun/packs/ai-model-training-architecture-best-practice.rego", PackageName: "infraguard.packs.aliyun.ai_model_training_architecture_best_practice", Content: "package infraguard.packs.aliyun.ai_model_training_architecture_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"ai-model-training-architecture-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"AI Model Training Architecture Best Practice\",\n\t\t\"zh\": \"AI 模型训练架构检测最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for AI model training architecture, covering ACK, ECS, NAS, OSS, VPC, and other resources.\",\n\t\t\"zh\": \"AI 模型训练架构最佳实践,涵盖 ACK、ECS、NAS、OSS、VPC 等资源。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-upgrade-latest-version\",\n\t\t\"ack-cluster-supported-version\",\n\t\t\"ack-cluster-encryption-enabled\",\n\t\t\"cr-instance-multi-zone\",\n\t\t# \"cr-instance-public-access-check\",  # Commented: ROS CR::Instance does not support PublicNetworkAccess property\n\t\t\"cr-repository-immutablity-enable\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t\"ecs-instance-image-expired-check\",\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t\"ecs-instance-not-bind-key-pair\",\n\t\t\"kms-key-rotation-enabled\",\n\t\t\"kms-key-delete-protection-enabled\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t\"nas-filesystem-mount-target-access-group-check\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t# \"nas-filesystem-access-point-enabled-ram\",  # Commented: ROS does not support ALIYUN::NAS::AccessPoint resource type\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t# \"nas-filesystem-access-point-root-directory-check\",  # Commented: ROS does not support ALIYUN::NAS::AccessPoint resource type\n\t\t\"oss-default-encryption-kms\",\n\t\t\"oss-bucket-tls-version-check\",\n\t\t# \"oss-bucket-remote-replication\",  # Commented: ROS template does not support ReplicationConfiguration\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t\"pai-eas-instances-multi-zone\",\n\t\t# \"vpc-secondary-cidr-route-check\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t\"vswitch-available-ip-count\",\n\t\t\"sls-project-multi-zone\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:aliyun-platform-security-best-practice", Name: models.I18nString{"en": "Aliyun Platform Security Best Practice", "zh": "阿里云平台安全最佳实践"}, Description: models.I18nString{"en": "Best practices for Aliyun platform security", "zh": "阿里云平台安全最佳实践"}, RuleIDs: []string{"rule:aliyun:root-mfa-check", "rule:aliyun:root-ak-check", "rule:aliyun:api-gateway-api-internet-request-https", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:ecs-instance-login-use-keypair", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:mongodb-public-and-any-ip-access-check", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-anonymous-prohibited", "rule:aliyun:polardb-public-and-any-ip-access-check", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:redis-public-and-any-ip-access-check", "rule:aliyun:redis-instance-enabled-ssl", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-acl-public-access-check", "rule:aliyun:slb-listener-risk-ports-check", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:vpc-network-acl-risky-ports-check"}, FilePath: "aliyun/packs/aliyun-platform-security-best-practice.rego", PackageName: "infraguard.packs.aliyun.aliyun_platform_security_best_practice", Content: "package infraguard.packs.aliyun.aliyun_platform_security_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"aliyun-platform-security-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Aliyun Platform Security Best Practice\",\n\t\t\"zh\": \"阿里云平台安全最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for Aliyun platform security\",\n\t\t\"zh\": \"阿里云平台安全最佳实践\",\n\t},\n\t\"rules\": [\n\t\t\"root-mfa-check\",\n\t\t\"root-ak-check\",\n\t\t\"api-gateway-api-internet-request-https\",\n\t\t# \"cdn-domain-https-enabled\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t\"ecs-instances-in-vpc\",\n\t\t\"ecs-instance-login-use-keypair\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"mongodb-public-and-any-ip-access-check\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-anonymous-prohibited\",\n\t\t\"polardb-public-and-any-ip-access-check\",\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"rds-public-access-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t# \"rds-instance-tls-version-check\",\n\t\t\"redis-public-and-any-ip-access-check\",\n\t\t\"redis-instance-enabled-ssl\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t\"slb-acl-public-access-check\",\n\t\t\"slb-listener-risk-ports-check\",\n\t\t\"slb-listener-https-enabled\",\n\t\t\"vpc-network-acl-risky-ports-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:aliyun-well-architected-security-pillar-best-practice", Name: models.I18nString{"en": "Aliyun Well-Architected Security Pillar Best Practice", "zh": "阿里云卓越架构安全支柱最佳实践"}, Description: models.I18nString{"en": "Best practices for Aliyun well-architected security pillar", "zh": "阿里云卓越架构安全支柱最佳实践"}, RuleIDs: []string{"rule:aliyun:actiontrail-trail-intact-enabled", "rule:aliyun:ram-password-policy-check", "rule:aliyun:root-ak-check", "rule:aliyun:root-mfa-check", "rule:aliyun:security-center-version-check", "rule:aliyun:api-gateway-group-enabled-ssl", "rule:aliyun:ecs-disk-idle-check", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:ecs-running-instance-no-public-ip", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:ess-scaling-configuration-enabled-internet-check", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-service-vpc-binding", "rule:aliyun:fc-service-internet-access-disable", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-encryption-byok-check", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-no-product-admin-access", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:ram-user-group-membership-check", "rule:aliyun:rds-public-connection-and-any-ip-access-check", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:vpc-flow-logs-enabled", "rule:aliyun:waf-instance-logging-enabled"}, FilePath: "aliyun/packs/aliyun-well-architected-security-pillar-best-practice.rego", PackageName: "infraguard.packs.aliyun.aliyun_well_architected_security_pillar_best_practice", Content: "package infraguard.packs.aliyun.aliyun_well_architected_security_pillar_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"aliyun-well-architected-security-pillar-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Aliyun Well-Architected Security Pillar Best Practice\",\n\t\t\"zh\": \"阿里云卓越架构安全支柱最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for Aliyun well-architected security pillar\",\n\t\t\"zh\": \"阿里云卓越架构安全支柱最佳实践\",\n\t},\n\t\"rules\": [\n\t\t\"actiontrail-trail-intact-enabled\",\n\t\t\"ram-password-policy-check\",\n\t\t\"root-ak-check\",\n\t\t\"root-mfa-check\",\n\t\t\"security-center-version-check\",\n\t\t# \"adb-public-access-check\",  # Commented: ROS ADB::DBCluster does not support PublicEndpoint property\n\t\t# \"adb-cluster-maintain-time-check\",  # Commented: ROS ADB::DBCluster does not support MaintainTime property\n\t\t# \"api-gateway-group-domain-access-waf-or-waf3\",  # Commented: ROS ApiGateway::Group does not support PassthroughWaf property\n\t\t\"api-gateway-group-enabled-ssl\",\n\t\t\"ecs-disk-idle-check\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t\"ecs-instances-in-vpc\",\n\t\t\"ecs-running-instance-no-public-ip\",\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t# \"ecs-security-group-not-used\",  # Commented: ROS ECS::SecurityGroup does not support Used property\n\t\t\"ess-scaling-configuration-enabled-internet-check\",\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t# \"elasticsearch-instance-in-vpc\",  # Commented: ROS ALIYUN::ElasticSearch::Instance requires VSwitchId (all instances are in VPC)\n\t\t\"fc-service-vpc-binding\",\n\t\t\"fc-service-internet-access-disable\",\n\t\t# \"kms-key-origin-not-external\",  # Commented: ROS KMS::Key does not support Origin property\n\t\t\"kms-key-rotation-enabled\",\n\t\t# \"kms-key-state-not-pending-deletion\",  # Commented: ROS KMS::Key does not support KeyState property (runtime state only)\n\t\t\"kms-secret-rotation-enabled\",\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-encryption-byok-check\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t# \"ots-instance-all-table-encrypted\",  # ROS template does not support SSESpecification property\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-no-product-admin-access\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"ram-user-group-membership-check\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t\"slb-listener-https-enabled\",\n\t\t\"slb-instance-log-enabled\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t\"waf-instance-logging-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:change-management-best-practice", Name: models.I18nString{"en": "Change Management Best Practice", "zh": "变更管理最佳实践"}, Description: models.I18nString{"en": "From the change management dimension, detect the stability of cloud resources to help identify potential issues in advance and improve stability and operational efficiency.", "zh": "从变更管理维度,对云上资源的稳定性做检测,有助于提前发现隐患,提升稳定性和运维效率。"}, RuleIDs: []string{"rule:aliyun:ecs-snapshot-policy-timepoints-check", "rule:aliyun:ecs-snapshot-retention-days", "rule:aliyun:polardb-cluster-maintain-time-check", "rule:aliyun:rds-instance-maintain-time-check", "rule:aliyun:redis-instance-backup-time-check"}, FilePath: "aliyun/packs/change-management-best-practice.rego", PackageName: "infraguard.packs.aliyun.change_management_best_practice", Content: "package infraguard.packs.aliyun.change_management_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"change-management-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Change Management Best Practice\",\n\t\t\"zh\": \"变更管理最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"From the change management dimension, detect the stability of cloud resources to help identify potential issues in advance and improve stability and operational efficiency.\",\n\t\t\"zh\": \"从变更管理维度,对云上资源的稳定性做检测,有助于提前发现隐患,提升稳定性和运维效率。\",\n\t},\n\t\"rules\": [\n\t\t# \"adb-cluster-maintain-time-check\",  # Commented: ROS ADB::DBCluster does not support MaintainTime property\n\t\t\"ecs-snapshot-policy-timepoints-check\",\n\t\t\"ecs-snapshot-retention-days\",\n\t\t\"polardb-cluster-maintain-time-check\",\n\t\t\"rds-instance-maintain-time-check\",\n\t\t\"redis-instance-backup-time-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:china-gmp-annex-compliance", Name: models.I18nString{"en": "China GMP Annex Compliance", "zh": "中国 GMP 附录合规包"}, Description: models.I18nString{"en": "Compliance pack for pharmaceutical, biotechnology and medical device companies using cloud services that need to meet China GMP Annex standards. This pack provides mappings between standard requirements and Alibaba Cloud product settings.", "zh": "在制药、生物技术和医疗器械领域中使用计算机化系统的企业和组织，在用云过程需要满足中国 GMP 附录标准。本合规包模板提供了标准细则与阿里云的产品设置的对应关系。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-rrsa-enabled", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:alb-server-group-multi-zone", "rule:aliyun:api-gateway-api-internet-request-https", "rule:aliyun:ecs-snapshot-retention-days", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:eip-attached", "rule:aliyun:ess-scaling-group-attach-multi-switch", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-function-custom-domain-and-tls-enable", "rule:aliyun:fc-service-bind-role", "rule:aliyun:hbase-cluster-deletion-protection", "rule:aliyun:mse-cluster-config-auth-enabled", "rule:aliyun:mongodb-instance-release-protection", "rule:aliyun:mongodb-instance-multi-zone", "rule:aliyun:mongodb-instance-log-audit", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:privatelink-servier-endpoint-multi-zone", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-instance-enabled-ssl", "rule:aliyun:rds-instacne-delete-protection-enabled", "rule:aliyun:redis-instance-multi-zone", "rule:aliyun:redis-instance-enabled-ssl", "rule:aliyun:redis-instance-enabled-byok-tde", "rule:aliyun:redis-instance-release-protection", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-instance-multi-zone", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:slb-vserver-group-multi-zone", "rule:aliyun:sls-logstore-enabled-encrypt", "rule:aliyun:waf-instance-logging-enabled"}, FilePath: "aliyun/packs/china-gmp-annex-compliance.rego", PackageName: "infraguard.packs.aliyun.china_gmp_annex_compliance", Content: "package infraguard.packs.aliyun.china_gmp_annex_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"china-gmp-annex-compliance\",\n\t\"name\": {\n\t\t\"en\": \"China GMP Annex Compliance\",\n\t\t\"zh\": \"中国 GMP 附录合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for pharmaceutical, biotechnology and medical device companies using cloud services that need to meet China GMP Annex standards. This pack provides mappings between standard requirements and Alibaba Cloud product settings.\",\n\t\t\"zh\": \"在制药、生物技术和医疗器械领域中使用计算机化系统的企业和组织，在用云过程需要满足中国 GMP 附录标准。本合规包模板提供了标准细则与阿里云的产品设置的对应关系。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-rrsa-enabled\",\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t\"alb-instance-multi-zone\",\n\t\t\"alb-server-group-multi-zone\",\n\t\t\"api-gateway-api-internet-request-https\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"dts-instance-sync-job-ssl-enabled\",\n\t\t# \"dts-instance-migration-job-ssl-enabled\",\n\t\t\"ecs-snapshot-retention-days\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t# \"ecs-security-group-not-used\",  # Commented: ROS ECS::SecurityGroup does not support Used property\n\t\t\"eip-attached\",\n\t\t\"ess-scaling-group-attach-multi-switch\",\n\t\t# \"elasticsearch-instance-used-https-protocol\",  # Commented: ROS ALIYUN::ElasticSearch::Instance does not support Protocol property\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t# \"elasticsearch-instance-snapshot-enabled\",  # Commented: ROS does not support AutoSnapshot property for ALIYUN::ElasticSearch::Instance\n\t\t\"fc-function-custom-domain-and-tls-enable\",\n\t\t\"fc-service-bind-role\",\n\t\t\"hbase-cluster-deletion-protection\",\n\t\t\"mse-cluster-config-auth-enabled\",\n\t\t\"mongodb-instance-release-protection\",\n\t\t\"mongodb-instance-multi-zone\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t\"mongodb-instance-log-audit\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t# \"oceanbase-instance-enabled-backup\",  # Commented: ROS does not support ALIYUN::OceanBase::DBInstance resource type\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t\"privatelink-servier-endpoint-multi-zone\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t\"rds-instance-enabled-ssl\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"rds-instacne-delete-protection-enabled\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t\"redis-instance-multi-zone\",\n\t\t\"redis-instance-enabled-ssl\",\n\t\t\"redis-instance-enabled-byok-tde\",\n\t\t\"redis-instance-release-protection\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t# \"redis-instance-enabled-audit-log\",  # Commented: ROS ALIYUN::REDIS::Instance does not support AuditLogConfig property\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-instance-multi-zone\",\n\t\t\"slb-instance-log-enabled\",\n\t\t\"slb-vserver-group-multi-zone\",\n\t\t\"sls-logstore-enabled-encrypt\",\n\t\t# \"vpn-ipsec-connection-encrypt-enable\",\n\t\t\"waf-instance-logging-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:cloud-governance-center-compliance-practice", Name: models.I18nString{"en": "Cloud Governance Center Compliance Practice", "zh": "云治理中心合规实践"}, Description: models.I18nString{"en": "Compliance practices for cloud governance center", "zh": "云治理中心合规实践"}, RuleIDs: []string{"rule:aliyun:root-ak-check", "rule:aliyun:root-mfa-check", "rule:aliyun:ram-password-policy-check", "rule:aliyun:root-has-specified-role", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:sg-public-access-check", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-instances-in-vpc", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-listener-https-enabled"}, FilePath: "aliyun/packs/cloud-governance-center-compliance-practice.rego", PackageName: "infraguard.packs.aliyun.cloud_governance_center_compliance_practice", Content: "package infraguard.packs.aliyun.cloud_governance_center_compliance_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"cloud-governance-center-compliance-practice\",\n\t\"name\": {\n\t\t\"en\": \"Cloud Governance Center Compliance Practice\",\n\t\t\"zh\": \"云治理中心合规实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance practices for cloud governance center\",\n\t\t\"zh\": \"云治理中心合规实践\",\n\t},\n\t\"rules\": [\n\t\t\"root-ak-check\",\n\t\t\"root-mfa-check\",\n\t\t\"ram-password-policy-check\",\n\t\t\"root-has-specified-role\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t# \"contains-tag\",  # Commented: Some resources like ACTIONTRAIL::Trail do not support Tags property\n\t\t# \"required-tags\",  # Commented: Some resources like ACTIONTRAIL::Trail do not support Tags property\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"sg-public-access-check\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"rds-public-access-check\",\n\t\t\"rds-instances-in-vpc\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-listener-https-enabled\",\n\t\t# \"resource-region-limit\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:database-compliance-management-best-practice", Name: models.I18nString{"en": "Database Compliance Management Best Practice", "zh": "数据库合规管理最佳实践"}, Description: models.I18nString{"en": "Best practices for database compliance management", "zh": "数据库合规管理最佳实践"}, RuleIDs: []string{"rule:aliyun:hbase-cluster-expired-check", "rule:aliyun:hbase-cluster-type-check", "rule:aliyun:hbase-cluster-in-vpc", "rule:aliyun:hbase-cluster-deletion-protection", "rule:aliyun:mongodb-cluster-expired-check", "rule:aliyun:mongodb-public-access-check", "rule:aliyun:mongodb-instance-release-protection", "rule:aliyun:mongodb-instance-log-audit", "rule:aliyun:polardb-cluster-expired-check", "rule:aliyun:rds-instance-expired-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-instance-enabled-auditing", "rule:aliyun:rds-instances-in-vpc", "rule:aliyun:rds-instance-enabled-ssl", "rule:aliyun:redis-instance-expired-check", "rule:aliyun:redis-instance-release-protection"}, FilePath: "aliyun/packs/database-compliance-management-best-practice.rego", PackageName: "infraguard.packs.aliyun.database_compliance_management_best_practice", Content: "package infraguard.packs.aliyun.database_compliance_management_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"database-compliance-management-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Database Compliance Management Best Practice\",\n\t\t\"zh\": \"数据库合规管理最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for database compliance management\",\n\t\t\"zh\": \"数据库合规管理最佳实践\",\n\t},\n\t\"rules\": [\n\t\t\"hbase-cluster-expired-check\",\n\t\t\"hbase-cluster-type-check\",\n\t\t\"hbase-cluster-in-vpc\",\n\t\t# \"hbase-cluster-ha-check\",\n\t\t\"hbase-cluster-deletion-protection\",\n\t\t\"mongodb-cluster-expired-check\",\n\t\t# \"mongodb-instance-lock-mode\",\n\t\t\"mongodb-public-access-check\",\n\t\t\"mongodb-instance-release-protection\",\n\t\t# \"mongodb-instance-in-vpc\",\n\t\t\"mongodb-instance-log-audit\",\n\t\t\"polardb-cluster-expired-check\",\n\t\t# \"polardb-public-access-check\",\n\t\t# \"polardb-dbcluster-in-vpc\",\n\t\t# \"polardb-cluster-category-normal\",\n\t\t\"rds-instance-expired-check\",\n\t\t\"rds-public-access-check\",\n\t\t# \"rds-high-availability-category\",\n\t\t\"rds-multi-az-support\",\n\t\t# \"rds-instance-enabled-security-ip-list\",\n\t\t# \"rds-instance-enabled-safety-security-ip\",\n\t\t\"rds-instance-enabled-auditing\",\n\t\t\"rds-instances-in-vpc\",\n\t\t\"rds-instance-enabled-ssl\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t# \"redis-instance-disable-risk-commands\",\n\t\t\"redis-instance-expired-check\",\n\t\t# \"redis-public-access-check\",\n\t\t# \"redis-architecturetype-cluster-check\",\n\t\t\"redis-instance-release-protection\",\n\t\t# \"redis-instance-in-vpc\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:ecs-compliance-management-best-practice", Name: models.I18nString{"en": "ECS Compliance Management Best Practice", "zh": "ECS 合规管理最佳实践"}, Description: models.I18nString{"en": "Best practices for ECS compliance management", "zh": "ECS 合规管理最佳实践"}, RuleIDs: []string{"rule:aliyun:ecs-snapshot-retention-days", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-expired-check", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-instance-attached-security-group", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol"}, FilePath: "aliyun/packs/ecs-compliance-management-best-practice.rego", PackageName: "infraguard.packs.aliyun.ecs_compliance_management_best_practice", Content: "package infraguard.packs.aliyun.ecs_compliance_management_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"ecs-compliance-management-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"ECS Compliance Management Best Practice\",\n\t\t\"zh\": \"ECS 合规管理最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for ECS compliance management\",\n\t\t\"zh\": \"ECS 合规管理最佳实践\",\n\t},\n\t\"rules\": [\n\t\t# \"ecs-all-updated-security-vul\",\n\t\t# \"ecs-all-enabled-security-protection\",\n\t\t\"ecs-snapshot-retention-days\",\n\t\t# \"ecs-disk-no-lock\",  # Removed: Status is a runtime attribute, cannot be checked in templates\n\t\t\"ecs-disk-encrypted\",\n\t\t# \"ecs-disk-in-use\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t# \"ecs-disk-retain-auto-snapshot\",\n\t\t\"ecs-instance-expired-check\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t\"ecs-instance-attached-security-group\",\n\t\t# \"ecs-instance-no-lock\",\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t\"ecs-instances-in-vpc\",\n\t\t# \"ecs-instance-imageId-check\",\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t# \"ess-group-health-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:generative-ai-compliance-best-practice", Name: models.I18nString{"en": "Generative AI Compliance Best Practice", "zh": "生成式 AI 合规最佳实践"}, Description: models.I18nString{"en": "This compliance pack aims to help you comprehensively detect and manage potential compliance risks in security and stability aspects of Bailian, PAI platform, and their dependent core products (such as ACK, ACR, OSS, NAS, KMS, SLS, MaxCompute, etc.).", "zh": "本合规包旨在帮助您全面检测和管理百炼、人工智能平台 PAI 以及其依赖的核心产品(如 ACK、ACR、OSS、NAS、KMS、SLS、MaxCompute 等)在安全与稳定性方面的潜在合规风险。"}, RuleIDs: []string{"rule:aliyun:cr-repository-immutablity-enable", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:kms-key-delete-protection-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:maxcompute-project-encryption-enabled", "rule:aliyun:maxcompute-project-ip-whitelist-enabled", "rule:aliyun:nas-filesystem-mount-target-access-group-check", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:pai-eas-instances-multi-zone"}, FilePath: "aliyun/packs/generative-ai-compliance-best-practice.rego", PackageName: "infraguard.packs.aliyun.generative_ai_compliance_best_practice", Content: "package infraguard.packs.aliyun.generative_ai_compliance_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"generative-ai-compliance-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Generative AI Compliance Best Practice\",\n\t\t\"zh\": \"生成式 AI 合规最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"This compliance pack aims to help you comprehensively detect and manage potential compliance risks in security and stability aspects of Bailian, PAI platform, and their dependent core products (such as ACK, ACR, OSS, NAS, KMS, SLS, MaxCompute, etc.).\",\n\t\t\"zh\": \"本合规包旨在帮助您全面检测和管理百炼、人工智能平台 PAI 以及其依赖的核心产品(如 ACK、ACR、OSS、NAS、KMS、SLS、MaxCompute 等)在安全与稳定性方面的潜在合规风险。\",\n\t},\n\t\"rules\": [\n\t\t# \"cr-instance-public-access-check\",  # Commented: ROS CR::Instance does not support PublicNetworkAccess property\n\t\t\"cr-repository-immutablity-enable\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"kms-key-rotation-enabled\",\n\t\t\"kms-key-delete-protection-enabled\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t# \"maxcompute-project-multi-zone\",\n\t\t\"maxcompute-project-encryption-enabled\",\n\t\t\"maxcompute-project-ip-whitelist-enabled\",\n\t\t\"nas-filesystem-mount-target-access-group-check\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t# \"nas-filesystem-access-point-enabled-ram\",  # Commented: ROS does not support ALIYUN::NAS::AccessPoint resource type\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t\"oss-default-encryption-kms\",\n\t\t# \"oss-bucket-tls-version-check\",  # ROS template does not support TLS version configuration\n\t\t# \"oss-bucket-remote-replication\",  # ROS template does not support replication configuration\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t\"pai-eas-instances-multi-zone\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:gxp-eu-annex11-compliance", Name: models.I18nString{"en": "GxP EU Annex 11 Compliance", "zh": "GxP 欧盟附录 11 标准合规包"}, Description: models.I18nString{"en": "Compliance pack for pharmaceutical, biotechnology and medical device companies using cloud services that need to meet GxP EU Annex 11 standards. This pack provides mappings between standard requirements and Alibaba Cloud product settings.", "zh": "在制药、生物技术和医疗器械领域中使用计算机化系统的企业和组织，在用云过程需要满足 GxP 欧盟标准。本合规包模板提供了标准细则与阿里云的产品设置的对应关系。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-rrsa-enabled", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:alb-server-group-multi-zone", "rule:aliyun:api-gateway-api-internet-request-https", "rule:aliyun:ecs-snapshot-retention-days", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:eip-attached", "rule:aliyun:ess-scaling-group-attach-multi-switch", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-function-custom-domain-and-tls-enable", "rule:aliyun:fc-service-bind-role", "rule:aliyun:hbase-cluster-deletion-protection", "rule:aliyun:mse-cluster-config-auth-enabled", "rule:aliyun:mongodb-instance-release-protection", "rule:aliyun:mongodb-instance-multi-zone", "rule:aliyun:mongodb-instance-log-audit", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:privatelink-servier-endpoint-multi-zone", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-instance-enabled-ssl", "rule:aliyun:rds-instacne-delete-protection-enabled", "rule:aliyun:redis-instance-multi-zone", "rule:aliyun:redis-instance-enabled-ssl", "rule:aliyun:redis-instance-enabled-byok-tde", "rule:aliyun:redis-instance-release-protection", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-instance-multi-zone", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:slb-vserver-group-multi-zone", "rule:aliyun:sls-logstore-enabled-encrypt", "rule:aliyun:waf-instance-logging-enabled"}, FilePath: "aliyun/packs/gxp-eu-annex11-compliance.rego", PackageName: "infraguard.packs.aliyun.gxp_eu_annex11_compliance", Content: "package infraguard.packs.aliyun.gxp_eu_annex11_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"gxp-eu-annex11-compliance\",\n\t\"name\": {\n\t\t\"en\": \"GxP EU Annex 11 Compliance\",\n\t\t\"zh\": \"GxP 欧盟附录 11 标准合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for pharmaceutical, biotechnology and medical device companies using cloud services that need to meet GxP EU Annex 11 standards. This pack provides mappings between standard requirements and Alibaba Cloud product settings.\",\n\t\t\"zh\": \"在制药、生物技术和医疗器械领域中使用计算机化系统的企业和组织，在用云过程需要满足 GxP 欧盟标准。本合规包模板提供了标准细则与阿里云的产品设置的对应关系。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-rrsa-enabled\",\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t\"alb-instance-multi-zone\",\n\t\t\"alb-server-group-multi-zone\",\n\t\t\"api-gateway-api-internet-request-https\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"dts-instance-sync-job-ssl-enabled\",\n\t\t# \"dts-instance-migration-job-ssl-enabled\",\n\t\t\"ecs-snapshot-retention-days\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t# \"ecs-security-group-not-used\",  # Commented: ROS ECS::SecurityGroup does not support Used property\n\t\t\"eip-attached\",\n\t\t\"ess-scaling-group-attach-multi-switch\",\n\t\t# \"elasticsearch-instance-used-https-protocol\",  # Commented: ROS ALIYUN::ElasticSearch::Instance does not support Protocol property\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t# \"elasticsearch-instance-snapshot-enabled\",  # Commented: ROS does not support AutoSnapshot property for ALIYUN::ElasticSearch::Instance\n\t\t\"fc-function-custom-domain-and-tls-enable\",\n\t\t\"fc-service-bind-role\",\n\t\t\"hbase-cluster-deletion-protection\",\n\t\t\"mse-cluster-config-auth-enabled\",\n\t\t\"mongodb-instance-release-protection\",\n\t\t\"mongodb-instance-multi-zone\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t\"mongodb-instance-log-audit\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t# \"oceanbase-instance-enabled-backup\",  # Commented: ROS does not support ALIYUN::OceanBase::DBInstance resource type\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t\"privatelink-servier-endpoint-multi-zone\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t\"rds-instance-enabled-ssl\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"rds-instacne-delete-protection-enabled\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t\"redis-instance-multi-zone\",\n\t\t\"redis-instance-enabled-ssl\",\n\t\t\"redis-instance-enabled-byok-tde\",\n\t\t\"redis-instance-release-protection\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t# \"redis-instance-enabled-audit-log\",  # Commented: ROS ALIYUN::REDIS::Instance does not support AuditLogConfig property\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-instance-multi-zone\",\n\t\t\"slb-instance-log-enabled\",\n\t\t\"slb-vserver-group-multi-zone\",\n\t\t\"sls-logstore-enabled-encrypt\",\n\t\t# \"vpn-ipsec-connection-encrypt-enable\",\n\t\t\"waf-instance-logging-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:iso-27001-compliance", Name: models.I18nString{"en": "ISO-27001 Security Management Standard Compliance", "zh": "ISO-27001 安全管理标准合规包"}, Description: models.I18nString{"en": "Compliance pack for ISO-27001 Information Security Management System standard. This pack helps organizations verify their cloud resources meet ISO-27001 security requirements.", "zh": "ISO-27001 信息安全管理体系标准合规包。本合规包帮助组织验证其云资源是否符合 ISO-27001 安全要求。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-public-endpoint-check", "rule:aliyun:ack-cluster-node-multi-zone", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:alb-all-listener-health-check-enabled", "rule:aliyun:ecs-snapshot-policy-timepoints-check", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-available-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-running-instance-no-public-ip", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:ess-scaling-group-attach-multi-switch", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-function-custom-domain-and-tls-enable", "rule:aliyun:fc-service-vpc-binding", "rule:aliyun:fc-service-internet-access-disable", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:maxcompute-project-encryption-enabled", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-maintain-time-check", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-instance-maintain-time-check", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:vpc-flow-logs-enabled", "rule:aliyun:vswitch-available-ip-count"}, FilePath: "aliyun/packs/iso-27001-compliance.rego", PackageName: "infraguard.packs.aliyun.iso_27001_compliance", Content: "package infraguard.packs.aliyun.iso_27001_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"iso-27001-compliance\",\n\t\"name\": {\n\t\t\"en\": \"ISO-27001 Security Management Standard Compliance\",\n\t\t\"zh\": \"ISO-27001 安全管理标准合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for ISO-27001 Information Security Management System standard. This pack helps organizations verify their cloud resources meet ISO-27001 security requirements.\",\n\t\t\"zh\": \"ISO-27001 信息安全管理体系标准合规包。本合规包帮助组织验证其云资源是否符合 ISO-27001 安全要求。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-public-endpoint-check\",\n\t\t# \"ack-cluster-node-monitorenabled\",\n\t\t\"ack-cluster-node-multi-zone\",\n\t\t# \"ack-cluster-deletion-protection-enabled\",\n\t\t# \"adb-public-access-check\",  # Commented: ROS ADB::DBCluster does not support PublicEndpoint property\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t\"alb-instance-multi-zone\",\n\t\t\"alb-all-listener-health-check-enabled\",\n\t\t# \"api-gateway-group-log-enabled\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"dts-instance-sync-job-ssl-enabled\",\n\t\t\"ecs-snapshot-policy-timepoints-check\",\n\t\t# \"resource-group-default-used-check\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-available-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t# \"resources-inherit-resourcegroup-from-ecs-instance\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t# \"ecs-running-instances-in-vpc\",\n\t\t# \"ecs-instance-meta-data-mode-check\",\n\t\t\"ecs-running-instance-no-public-ip\",\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t# \"ess-group-health-check\",\n\t\t\"ess-scaling-group-attach-multi-switch\",\n\t\t# \"elasticsearch-instance-enabled-public-check\",\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t\"fc-function-custom-domain-and-tls-enable\",\n\t\t# \"fc-function-settings-check\",\n\t\t\"fc-service-vpc-binding\",\n\t\t\"fc-service-internet-access-disable\",\n\t\t\"kms-key-rotation-enabled\",\n\t\t# \"kms-key-state-not-pending-deletion\",  # Commented: ROS KMS::Key does not support KeyState property (runtime state only)\n\t\t# \"kms-secret-last-rotation-date-check\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t\"maxcompute-project-encryption-enabled\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-default-encryption-kms\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t# \"ots-instance-all-table-encrypted\",  # ROS template does not support SSESpecification property\n\t\t# \"polardb-cluster-address-no-public\",\n\t\t# \"polardb-public-access-check\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-maintain-time-check\",\n\t\t# \"polardb-cluster-level-one-backup-retention\",\n\t\t# \"polardb-cluster-enabled-auditing\",  # ROS does not support SQLCollectorStatus property\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t# \"ram-group-in-use-check\",\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"rds-public-access-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"rds-instance-maintain-time-check\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t\"slb-listener-https-enabled\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-instance-log-enabled\",\n\t\t# \"slb-aliyun-certificate-required\",\n\t\t# \"ssl-certificate-expired-check\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t\"vswitch-available-ip-count\",\n\t\t# \"vpn-ipsec-connection-status-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:mlps-level-2-pre-check-compliance-pack", Name: models.I18nString{"en": "MLPS Level 2 Pre-check Compliance Pack", "zh": "等保二级预检合规包"}, Description: models.I18nString{"en": "Compliance pack for MLPS level 2 pre-check", "zh": "等保二级预检合规包"}, RuleIDs: []string{"rule:aliyun:use-waf-instance-for-security-protection", "rule:aliyun:actiontrail-trail-intact-enabled", "rule:aliyun:security-center-version-check", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:eip-bandwidth-limit", "rule:aliyun:elasticsearch-public-and-any-ip-access-check", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-authorize-specified-ip", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:rds-public-connection-and-any-ip-access-check", "rule:aliyun:rds-instance-enabled-auditing", "rule:aliyun:redis-instance-open-auth-mode", "rule:aliyun:slb-acl-public-access-check", "rule:aliyun:slb-loadbalancer-bandwidth-limit", "rule:aliyun:vpc-network-acl-risky-ports-check", "rule:aliyun:vpc-flow-logs-enabled"}, FilePath: "aliyun/packs/mlps-level-2-pre-check-compliance-pack.rego", PackageName: "infraguard.packs.aliyun.mlps_level_2_pre_check_compliance_pack", Content: "package infraguard.packs.aliyun.mlps_level_2_pre_check_compliance_pack\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"mlps-level-2-pre-check-compliance-pack\",\n\t\"name\": {\n\t\t\"en\": \"MLPS Level 2 Pre-check Compliance Pack\",\n\t\t\"zh\": \"等保二级预检合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for MLPS level 2 pre-check\",\n\t\t\"zh\": \"等保二级预检合规包\",\n\t},\n\t\"rules\": [\n\t\t# \"use-ddos-instance-for-security-protection\",\n\t\t# \"use-cloud-fire-wall-for-security-protection\",\n\t\t# \"security-center-defense-config-check\",\n\t\t\"use-waf-instance-for-security-protection\",\n\t\t\"actiontrail-trail-intact-enabled\",\n\t\t# \"ram-password-require-char-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t# \"ram-password-max-age-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t# \"ram-password-max-login-attemps-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t\"security-center-version-check\",\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t# \"alb-all-listener-enabled-acl\",  # Commented: ROS ALB::Listener does not support AclConfig property\n\t\t# \"cen-cross-region-bandwidth-check\",\n\t\t# \"cr-instance-any-ip-access-check\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"eip-bandwidth-limit\",\n\t\t\"elasticsearch-public-and-any-ip-access-check\",\n\t\t# \"natgateway-snat-eip-bandwidth-check\",\n\t\t# \"nat-risk-ports-check\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-authorize-specified-ip\",\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t\t\"rds-instance-enabled-auditing\",\n\t\t\"redis-instance-open-auth-mode\",\n\t\t\"slb-acl-public-access-check\",\n\t\t# \"slb-all-listener-enabled-acl\",\n\t\t\"slb-loadbalancer-bandwidth-limit\",\n\t\t\"vpc-network-acl-risky-ports-check\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"waf3-instance-enabled-specified-defense-rules\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:mlps-level-3-pre-check-compliance-pack", Name: models.I18nString{"en": "MLPS Level 3 Pre-check Compliance Pack", "zh": "等保三级预检合规包"}, Description: models.I18nString{"en": "Compliance pack for MLPS level 3 pre-check requirements on Aliyun resources.", "zh": "基于等保三级的部分要求，对阿里云上资源的合规性做检测。"}, RuleIDs: []string{"rule:aliyun:use-waf-instance-for-security-protection", "rule:aliyun:actiontrail-trail-intact-enabled", "rule:aliyun:root-mfa-check", "rule:aliyun:security-center-version-check", "rule:aliyun:ack-cluster-public-endpoint-check", "rule:aliyun:ack-cluster-node-multi-zone", "rule:aliyun:ack-cluster-encryption-enabled", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:firewall-asset-open-protect", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:ecs-running-instance-no-public-ip", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:eip-bandwidth-limit", "rule:aliyun:elasticsearch-public-and-any-ip-access-check", "rule:aliyun:elasticsearch-instance-multi-zone", "rule:aliyun:mongodb-instance-multi-zone", "rule:aliyun:nas-filesystem-mount-target-access-group-check", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-policy-outside-organization-check", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:oss-bucket-authorize-specified-ip", "rule:aliyun:polardb-public-and-any-ip-access-check", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:rds-public-connection-and-any-ip-access-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-instances-in-vpc", "rule:aliyun:rds-instance-enabled-auditing", "rule:aliyun:rds-instance-enabled-disk-encryption", "rule:aliyun:rds-instance-has-guard-instance", "rule:aliyun:redis-instance-open-auth-mode", "rule:aliyun:redis-public-and-any-ip-access-check", "rule:aliyun:redis-instance-multi-zone", "rule:aliyun:slb-acl-public-access-check", "rule:aliyun:slb-all-listenter-tls-policy-check", "rule:aliyun:slb-listener-risk-ports-check", "rule:aliyun:slb-all-listener-servers-multi-zone", "rule:aliyun:slb-loadbalancer-bandwidth-limit", "rule:aliyun:sls-logstore-enabled-encrypt", "rule:aliyun:vpc-network-acl-risky-ports-check", "rule:aliyun:vpc-flow-logs-enabled"}, FilePath: "aliyun/packs/mlps-level-3-pre-check-compliance-pack.rego", PackageName: "infraguard.packs.aliyun.mlps_level_3_pre_check_compliance_pack", Content: "package infraguard.packs.aliyun.mlps_level_3_pre_check_compliance_pack\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"mlps-level-3-pre-check-compliance-pack\",\n\t\"name\": {\n\t\t\"en\": \"MLPS Level 3 Pre-check Compliance Pack\",\n\t\t\"zh\": \"等保三级预检合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for MLPS level 3 pre-check requirements on Aliyun resources.\",\n\t\t\"zh\": \"基于等保三级的部分要求，对阿里云上资源的合规性做检测。\",\n\t},\n\t\"rules\": [\n\t\t\"use-waf-instance-for-security-protection\",\n\t\t# \"use-ddos-instance-for-security-protection\",\n\t\t# \"use-cloud-fire-wall-for-security-protection\",\n\t\t# \"security-center-defense-config-check\",\n\t\t\"actiontrail-trail-intact-enabled\",\n\t\t# \"ram-password-require-char-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t# \"ram-password-max-age-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t# \"ram-password-max-login-attemps-check\",  # Commented: ROS does not support ALIYUN::RAM::PasswordPolicy resource type\n\t\t\"root-mfa-check\",\n\t\t# \"security-center-notice-config-check\",\n\t\t\"security-center-version-check\",\n\t\t\"ack-cluster-public-endpoint-check\",\n\t\t\"ack-cluster-node-multi-zone\",\n\t\t\"ack-cluster-encryption-enabled\",\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t\"alb-instance-multi-zone\",\n\t\t# \"alb-all-listener-enabled-acl\",  # Commented: ROS ALB::Listener does not support AclConfig property\n\t\t# \"api-gateway-group-https-policy-check\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"cen-cross-region-bandwidth-check\",\n\t\t# \"cr-instance-any-ip-access-check\",\n\t\t\"firewall-asset-open-protect\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t\"ecs-instances-in-vpc\",\n\t\t\"ecs-running-instance-no-public-ip\",\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"eip-bandwidth-limit\",\n\t\t\"elasticsearch-public-and-any-ip-access-check\",\n\t\t\"elasticsearch-instance-multi-zone\",\n\t\t# \"elasticsearch-instance-snapshot-enabled\",  # Commented: ROS does not support AutoSnapshot property for ALIYUN::ElasticSearch::Instance\n\t\t\"mongodb-instance-multi-zone\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t\"nas-filesystem-mount-target-access-group-check\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t# \"natgateway-snat-eip-bandwidth-check\",\n\t\t# \"nat-risk-ports-check\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-policy-outside-organization-check\",\n\t\t\"oss-default-encryption-kms\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t\"oss-bucket-authorize-specified-ip\",\n\t\t# \"oss-bucket-referer-enabled\",\n\t\t\"polardb-public-and-any-ip-access-check\",\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t# \"polardb-cluster-level-two-backup-retention\",\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t\"rds-instances-in-vpc\",\n\t\t# \"rds-instance-tls-version-check\",\n\t\t\"rds-instance-enabled-auditing\",\n\t\t\"rds-instance-enabled-disk-encryption\",\n\t\t\"rds-instance-has-guard-instance\",\n\t\t\"redis-instance-open-auth-mode\",\n\t\t\"redis-public-and-any-ip-access-check\",\n\t\t\"redis-instance-multi-zone\",\n\t\t# \"redis-instance-in-vpc\",\n\t\t# \"redis-instance-enabled-tde\",\n\t\t\"slb-acl-public-access-check\",\n\t\t\"slb-all-listenter-tls-policy-check\",\n\t\t\"slb-listener-risk-ports-check\",\n\t\t\"slb-all-listener-servers-multi-zone\",\n\t\t# \"slb-no-public-ip\",\n\t\t# \"slb-all-listener-enabled-acl\",\n\t\t\"slb-loadbalancer-bandwidth-limit\",\n\t\t\"sls-logstore-enabled-encrypt\",\n\t\t\"vpc-network-acl-risky-ports-check\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"waf3-instance-enabled-specified-defense-rules\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:multi-zone-architecture-best-practice", Name: models.I18nString{"en": "Multi-zone Architecture Best Practice", "zh": "多可用区架构最佳实践"}, Description: models.I18nString{"en": "Best practices for high availability architecture of products such as relational databases, NoSQL databases, and load balancers to build availability zone-level disaster recovery capabilities and ensure service availability and data reliability.", "zh": "关系型数据库、NoSQL 数据库、负载均衡等产品高可用架构最佳实践，构建可用区级别的容灾能力，保障服务可用性和数据可靠性。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-node-multi-zone", "rule:aliyun:acs-cluster-node-multi-zone", "rule:aliyun:adb-cluster-multi-zone", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:alb-server-group-multi-zone", "rule:aliyun:kafka-instance-multi-zone", "rule:aliyun:apigateway-instance-multi-zone", "rule:aliyun:bastionhost-instance-spec-check", "rule:aliyun:cdn-domain-multiple-origin-servers", "rule:aliyun:transit-router-vpc-attachment-multi-zone", "rule:aliyun:cr-instance-multi-zone", "rule:aliyun:clickhouse-dbcluster-multi-zone", "rule:aliyun:dcdn-domain-multiple-origin-servers", "rule:aliyun:polardb-x2-instance-multi-zone", "rule:aliyun:ecs-disk-regional-auto-check", "rule:aliyun:ess-scaling-group-attach-multi-switch", "rule:aliyun:elasticsearch-instance-multi-zone", "rule:aliyun:gpdb-instance-multi-zone", "rule:aliyun:gwlb-loadbalancer-multi-zone", "rule:aliyun:hbase-cluster-multi-zone", "rule:aliyun:kms-instance-multi-zone", "rule:aliyun:lindorm-instance-multi-zone", "rule:aliyun:mse-cluster-multi-availability-area-architecture-check", "rule:aliyun:mse-gateway-multi-availability-area-architecture-check", "rule:aliyun:mongodb-instance-multi-zone", "rule:aliyun:nlb-loadbalancer-multi-zone", "rule:aliyun:nlb-server-group-multi-zone", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:privatelink-server-endpoint-multi-zone", "rule:aliyun:rds-multi-az-support", "rule:aliyun:redis-instance-multi-zone", "rule:aliyun:rocketmq-v5-instance-multi-zone", "rule:aliyun:slb-instance-multi-zone", "rule:aliyun:slb-all-listener-servers-multi-zone", "rule:aliyun:sls-project-multi-zone", "rule:aliyun:vpn-connection-master-slave-established", "rule:aliyun:vpn-gateway-multi-zone"}, FilePath: "aliyun/packs/multi-zone-architecture-best-practice.rego", PackageName: "infraguard.packs.aliyun.multi_zone_architecture_best_practice", Content: "package infraguard.packs.aliyun.multi_zone_architecture_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"multi-zone-architecture-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Multi-zone Architecture Best Practice\",\n\t\t\"zh\": \"多可用区架构最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for high availability architecture of products such as relational databases, NoSQL databases, and load balancers to build availability zone-level disaster recovery capabilities and ensure service availability and data reliability.\",\n\t\t\"zh\": \"关系型数据库、NoSQL 数据库、负载均衡等产品高可用架构最佳实践，构建可用区级别的容灾能力，保障服务可用性和数据可靠性。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-node-multi-zone\",\n\t\t\"acs-cluster-node-multi-zone\",\n\t\t\"adb-cluster-multi-zone\",\n\t\t\"alb-instance-multi-zone\",\n\t\t\"alb-server-group-multi-zone\",\n\t\t\"kafka-instance-multi-zone\",\n\t\t\"apigateway-instance-multi-zone\",\n\t\t\"bastionhost-instance-spec-check\",\n\t\t\"cdn-domain-multiple-origin-servers\",\n\t\t\"transit-router-vpc-attachment-multi-zone\",\n\t\t\"cr-instance-multi-zone\",\n\t\t\"clickhouse-dbcluster-multi-zone\",\n\t\t# \"csg-gateway-multi-zone\",\n\t\t\"dcdn-domain-multiple-origin-servers\",\n\t\t\"polardb-x2-instance-multi-zone\",\n\t\t\"ecs-disk-regional-auto-check\",\n\t\t\"ess-scaling-group-attach-multi-switch\",\n\t\t\"elasticsearch-instance-multi-zone\",\n\t\t# \"expressconnect-physicalconnection-multi-zone\",\n\t\t\"gpdb-instance-multi-zone\",\n\t\t\"gwlb-loadbalancer-multi-zone\",\n\t\t\"hbase-cluster-multi-zone\",\n\t\t\"kms-instance-multi-zone\",\n\t\t\"lindorm-instance-multi-zone\",\n\t\t\"mse-cluster-multi-availability-area-architecture-check\",\n\t\t\"mse-gateway-multi-availability-area-architecture-check\",\n\t\t# \"maxcompute-project-multi-zone\",\n\t\t\"mongodb-instance-multi-zone\",\n\t\t\"nlb-loadbalancer-multi-zone\",\n\t\t\"nlb-server-group-multi-zone\",\n\t\t\"oss-zrs-enabled\",\n\t\t# \"ots-instance-multi-zone\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t\"privatelink-server-endpoint-multi-zone\",\n\t\t\"rds-multi-az-support\",\n\t\t# \"realtimecompute-vvpinstance-multi-zone\",\n\t\t\"redis-instance-multi-zone\",\n\t\t\"rocketmq-v5-instance-multi-zone\",\n\t\t\"slb-instance-multi-zone\",\n\t\t\"slb-all-listener-servers-multi-zone\",\n\t\t\"sls-project-multi-zone\",\n\t\t\"vpn-connection-master-slave-established\",\n\t\t\"vpn-gateway-multi-zone\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:network-data-security-best-practice", Name: models.I18nString{"en": "Network and Data Security Best Practice", "zh": "网络及数据安全最佳实践"}, Description: models.I18nString{"en": "Best practices for network and data security including ECS instance security, OSS bucket encryption and access control, RDS instance security configurations.", "zh": "网络及数据安全最佳实践，包括 ECS 实例安全、OSS 存储空间加密和访问控制、RDS 实例安全配置。"}, RuleIDs: []string{"rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-encryption-byok-check", "rule:aliyun:rds-public-access-check"}, FilePath: "aliyun/packs/network-data-security-best-practice.rego", PackageName: "infraguard.packs.aliyun.network_data_security_best_practice", Content: "# Network and Data Security Best Practice Pack\n# Best practices for network and data security including encryption, access control, and secure configurations.\npackage infraguard.packs.aliyun.network_data_security_best_practice\n\nimport rego.v1\n\n# Pack metadata with i18n support\npack_meta := {\n\t\"id\": \"network-data-security-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Network and Data Security Best Practice\",\n\t\t\"zh\": \"网络及数据安全最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for network and data security including ECS instance security, OSS bucket encryption and access control, RDS instance security configurations.\",\n\t\t\"zh\": \"网络及数据安全最佳实践，包括 ECS 实例安全、OSS 存储空间加密和访问控制、RDS 实例安全配置。\",\n\t},\n\t\"rules\": [\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-instances-in-vpc\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-encryption-byok-check\",\n\t\t\"rds-public-access-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:nist800-53-compliance", Name: models.I18nString{"en": "NIST 800-53 Compliance", "zh": "NIST800-53 合规包"}, Description: models.I18nString{"en": "Compliance pack for NIST 800-53 Security and Privacy Controls. This pack helps organizations verify their cloud resources meet NIST 800-53 security control requirements.", "zh": "NIST 800-53 安全与隐私控制合规包。本合规包帮助组织验证其云资源是否符合 NIST 800-53 安全控制要求。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-public-endpoint-check", "rule:aliyun:ack-cluster-encryption-enabled", "rule:aliyun:ack-cluster-supported-version", "rule:aliyun:ack-cluster-upgrade-latest-version", "rule:aliyun:alb-instance-multi-zone", "rule:aliyun:api-gateway-group-enabled-ssl", "rule:aliyun:cr-repository-immutablity-enable", "rule:aliyun:firewall-asset-open-protect", "rule:aliyun:ecs-in-use-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-not-bind-key-pair", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:eip-attached", "rule:aliyun:ess-scaling-configuration-enabled-internet-check", "rule:aliyun:ess-scaling-group-attach-multi-switch", "rule:aliyun:elasticsearch-public-and-any-ip-access-check", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-service-vpc-binding", "rule:aliyun:fc-service-internet-access-disable", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:mongodb-instance-log-audit", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-public-connection-and-any-ip-access-check", "rule:aliyun:rds-instance-enabled-disk-encryption", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-all-listener-servers-multi-zone", "rule:aliyun:slb-all-listenter-tls-policy-check", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:vpc-network-acl-risky-ports-check", "rule:aliyun:vpc-flow-logs-enabled"}, FilePath: "aliyun/packs/nist800-53-compliance.rego", PackageName: "infraguard.packs.aliyun.nist800_53_compliance", Content: "package infraguard.packs.aliyun.nist800_53_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"nist800-53-compliance\",\n\t\"name\": {\n\t\t\"en\": \"NIST 800-53 Compliance\",\n\t\t\"zh\": \"NIST800-53 合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for NIST 800-53 Security and Privacy Controls. This pack helps organizations verify their cloud resources meet NIST 800-53 security control requirements.\",\n\t\t\"zh\": \"NIST 800-53 安全与隐私控制合规包。本合规包帮助组织验证其云资源是否符合 NIST 800-53 安全控制要求。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-public-endpoint-check\",\n\t\t\"ack-cluster-encryption-enabled\",\n\t\t\"ack-cluster-supported-version\",\n\t\t\"ack-cluster-upgrade-latest-version\",\n\t\t# \"ack-cluster-control-plane-log-enable\",\n\t\t# \"adb-public-access-check\",  # Commented: ROS ADB::DBCluster does not support PublicEndpoint property\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t# \"adb-cluster-maintain-time-check\",  # Commented: ROS ADB::DBCluster does not support MaintainTime property\n\t\t\"alb-instance-multi-zone\",\n\t\t# \"api-gateway-group-domain-access-waf-or-waf3\",  # Commented: ROS ApiGateway::Group does not support PassthroughWaf property\n\t\t\"api-gateway-group-enabled-ssl\",\n\t\t# \"api-gateway-group-log-enabled\",\n\t\t# \"api-group-custom-trace-enabled\",\n\t\t# \"cdn-domain-https-enabled\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"cr-repository-image-scanning-enabled\",\n\t\t\"cr-repository-immutablity-enable\",\n\t\t\"firewall-asset-open-protect\",\n\t\t# \"dts-instance-migration-job-ssl-enabled\",\n\t\t# \"eci-containergroup-environment-no-specified-keys\",\n\t\t\"ecs-in-use-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t# \"ecs-disk-in-use\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t# \"ecs-instance-meta-data-mode-check\",\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t\"ecs-instance-not-bind-key-pair\",\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t# \"ecs-security-group-not-used\",  # Commented: ROS ECS::SecurityGroup does not support Used property\n\t\t\"eip-attached\",\n\t\t\"ess-scaling-configuration-enabled-internet-check\",\n\t\t# \"ess-group-health-check\",\n\t\t\"ess-scaling-group-attach-multi-switch\",\n\t\t\"elasticsearch-public-and-any-ip-access-check\",\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t# \"elasticsearch-instance-used-https-protocol\",  # Commented: ROS ALIYUN::ElasticSearch::Instance does not support Protocol property\n\t\t# \"fc-function-settings-check\",\n\t\t\"fc-service-vpc-binding\",\n\t\t\"fc-service-internet-access-disable\",\n\t\t# \"fc-service-log-enable\",\n\t\t# \"kms-key-origin-not-external\",  # Commented: ROS KMS::Key does not support Origin property\n\t\t# \"kms-key-state-not-pending-deletion\",  # Commented: ROS KMS::Key does not support KeyState property (runtime state only)\n\t\t# \"kms-secret-last-rotation-date-check\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t\"mongodb-instance-log-audit\",\n\t\t# \"nas-filesystem-access-point-enabled-ram\",  # Commented: ROS does not support ALIYUN::NAS::AccessPoint resource type\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t# \"nas-filesystem-access-point-root-directory-check\",  # Commented: ROS does not support ALIYUN::NAS::AccessPoint resource type\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-default-encryption-kms\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t# \"ots-instance-all-table-encrypted\",  # ROS template does not support SSESpecification property\n\t\t# \"polardb-cluster-enabled-auditing\",  # ROS does not support SQLCollectorStatus property\n\t\t# \"polardb-cluster-level-one-backup-retention\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t# \"polardb-dbversion-status-check\",\n\t\t\"ram-group-has-member-check\",\n\t\t# \"ram-group-in-use-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t\"rds-instance-enabled-disk-encryption\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t# \"redis-instance-upgrade-latest-version\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t\"slb-all-listener-servers-multi-zone\",\n\t\t\"slb-all-listenter-tls-policy-check\",\n\t\t\"slb-listener-https-enabled\",\n\t\t\"slb-instance-log-enabled\",\n\t\t# \"ssl-certificate-expired-check\",\n\t\t\"vpc-network-acl-risky-ports-check\",\n\t\t# \"vpc-network-acl-unused-check\",\n\t\t# \"vpc-routetable-destination-cidr-check\",  # ROS does not support ALIYUN::VPC::RouteEntry resource type\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"vpn-ipsec-connection-status-check\",\n\t\t# \"waf3-instance-enabled-specified-defense-rules\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:oceanbase-best-practice", Name: models.I18nString{"en": "OceanBase Best Practice", "zh": "OceanBase 最佳实践"}, Description: models.I18nString{"en": "Continuously check OceanBase compliance based on security practices.", "zh": "基于安全实践持续检查 OceanBase 的合规性。"}, RuleIDs: []string(nil), FilePath: "aliyun/packs/oceanbase-best-practice.rego", PackageName: "infraguard.packs.aliyun.oceanbase_best_practice", Content: "package infraguard.packs.aliyun.oceanbase_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"oceanbase-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"OceanBase Best Practice\",\n\t\t\"zh\": \"OceanBase 最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Continuously check OceanBase compliance based on security practices.\",\n\t\t\"zh\": \"基于安全实践持续检查 OceanBase 的合规性。\",\n\t},\n\t\"rules\": [],\n\t# \"oceanbase-instance-enabled-backup\",  # Commented: ROS does not support ALIYUN::OceanBase::DBInstance resource type\n\t# \"oceanbase-instance-enabled-ssl\",\n\t# \"oceanbase-instance-enabled-sql-diagnosis\",\n\t# \"oceanbase-tenant-security-ip-check\",\n\t# \"oceanbase-tenant-enabled-encryption\",\n\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:oss-compliance-management-best-practice", Name: models.I18nString{"en": "OSS Compliance Management Best Practice", "zh": "OSS 合规管理最佳实践"}, Description: models.I18nString{"en": "Best practices for OSS bucket compliance management, covering access control, encryption, logging, versioning, and security policies.", "zh": "OSS 存储空间合规管理最佳实践,涵盖访问控制、加密、日志、版本控制和安全策略。"}, RuleIDs: []string{"rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-policy-no-any-anonymous", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-policy-outside-organization-check", "rule:aliyun:oss-bucket-referer-limit"}, FilePath: "aliyun/packs/oss-compliance-management-best-practice.rego", PackageName: "infraguard.packs.aliyun.oss_compliance_management_best_practice", Content: "package infraguard.packs.aliyun.oss_compliance_management_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"oss-compliance-management-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"OSS Compliance Management Best Practice\",\n\t\t\"zh\": \"OSS 合规管理最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for OSS bucket compliance management, covering access control, encryption, logging, versioning, and security policies.\",\n\t\t\"zh\": \"OSS 存储空间合规管理最佳实践,涵盖访问控制、加密、日志、版本控制和安全策略。\",\n\t},\n\t\"rules\": [\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-policy-no-any-anonymous\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-policy-outside-organization-check\",\n\t\t\"oss-bucket-referer-limit\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:pci-dss-compliance", Name: models.I18nString{"en": "PCI-DSS Data Security Standard Compliance", "zh": "PCI-DSS 数据安全标准合规包"}, Description: models.I18nString{"en": "Compliance pack for Payment Card Industry Data Security Standard (PCI-DSS). This pack helps organizations verify their cloud resources meet PCI-DSS requirements for protecting cardholder data.", "zh": "支付卡行业数据安全标准(PCI-DSS)合规包。本合规包帮助组织验证其云资源是否符合 PCI-DSS 保护持卡人数据的要求。"}, RuleIDs: []string{"rule:aliyun:api-gateway-api-internet-request-https", "rule:aliyun:ecs-snapshot-retention-days", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:fc-function-custom-domain-and-tls-enable", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:kms-key-delete-protection-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:oss-bucket-anonymous-prohibited", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-encryption-byok-check", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:polardb-public-and-any-ip-access-check", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-maintain-time-check", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-group-membership-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:ram-user-ak-used-expired-check", "rule:aliyun:rds-public-connection-and-any-ip-access-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-instance-enabled-auditing", "rule:aliyun:rds-instance-maintain-time-check", "rule:aliyun:rds-instance-enabled-disk-encryption", "rule:aliyun:slb-all-listenter-tls-policy-check", "rule:aliyun:sls-logstore-enabled-encrypt", "rule:aliyun:vpc-flow-logs-enabled", "rule:aliyun:waf-instance-logging-enabled"}, FilePath: "aliyun/packs/pci-dss-compliance.rego", PackageName: "infraguard.packs.aliyun.pci_dss_compliance", Content: "package infraguard.packs.aliyun.pci_dss_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"pci-dss-compliance\",\n\t\"name\": {\n\t\t\"en\": \"PCI-DSS Data Security Standard Compliance\",\n\t\t\"zh\": \"PCI-DSS 数据安全标准合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for Payment Card Industry Data Security Standard (PCI-DSS). This pack helps organizations verify their cloud resources meet PCI-DSS requirements for protecting cardholder data.\",\n\t\t\"zh\": \"支付卡行业数据安全标准(PCI-DSS)合规包。本合规包帮助组织验证其云资源是否符合 PCI-DSS 保护持卡人数据的要求。\",\n\t},\n\t\"rules\": [\n\t\t\"api-gateway-api-internet-request-https\",\n\t\t# \"api-gateway-group-domain-access-waf\",\n\t\t# \"cdn-domain-https-enabled\",\n\t\t\"ecs-snapshot-retention-days\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t# \"ecs-instance-no-public-ip\",\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t# \"ecs-instance-os-name-check\",\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t# \"elasticsearch-instance-used-https-protocol\",  # Commented: ROS ALIYUN::ElasticSearch::Instance does not support Protocol property\n\t\t\"fc-function-custom-domain-and-tls-enable\",\n\t\t\"kms-key-rotation-enabled\",\n\t\t\"kms-key-delete-protection-enabled\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"oss-bucket-anonymous-prohibited\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-encryption-byok-check\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t\"polardb-public-and-any-ip-access-check\",\n\t\t# \"polardb-cluster-default-time-zone-not-system\",\n\t\t# \"polardb-cluster-level-one-backup-retention\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-maintain-time-check\",\n\t\t# \"polardb-cluster-enabled-auditing\",  # ROS does not support SQLCollectorStatus property\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t# \"ram-user-no-has-specified-policy\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-group-membership-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"ram-user-ak-used-expired-check\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-instance-enabled-auditing\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t# \"rds-instance-enabled-byok-tde\",\n\t\t\"rds-instance-maintain-time-check\",\n\t\t\"rds-instance-enabled-disk-encryption\",\n\t\t# \"redis-instance-enabled-tde\",\n\t\t\"slb-all-listenter-tls-policy-check\",\n\t\t\"sls-logstore-enabled-encrypt\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"waf-domain-enabled-specified-protection-module\",\n\t\t\"waf-instance-logging-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:polardb-application-best-practice", Name: models.I18nString{"en": "PolarDB Application Best Practice", "zh": "PolarDB 应用最佳实践"}, Description: models.I18nString{"en": "Best practices for PolarDB cluster configuration, covering security, backup, version management, and operational settings.", "zh": "PolarDB 集群配置最佳实践,涵盖安全、备份、版本管理和运维设置。"}, RuleIDs: []string{"rule:aliyun:polardb-cluster-expired-check", "rule:aliyun:polardb-public-and-any-ip-access-check", "rule:aliyun:polardb-cluster-maintain-time-check", "rule:aliyun:polardb-cluster-delete-protection-enabled"}, FilePath: "aliyun/packs/polardb-application-best-practice.rego", PackageName: "infraguard.packs.aliyun.polardb_application_best_practice", Content: "package infraguard.packs.aliyun.polardb_application_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"polardb-application-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"PolarDB Application Best Practice\",\n\t\t\"zh\": \"PolarDB 应用最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for PolarDB cluster configuration, covering security, backup, version management, and operational settings.\",\n\t\t\"zh\": \"PolarDB 集群配置最佳实践,涵盖安全、备份、版本管理和运维设置。\",\n\t},\n\t\"rules\": [\n\t\t# \"polardb-revision-version-used-check\",\n\t\t\"polardb-cluster-expired-check\",\n\t\t\"polardb-public-and-any-ip-access-check\",\n\t\t# \"polardb-cluster-default-time-zone-not-system\",\n\t\t# \"polardb-cluster-enabled-auditing\",  # ROS does not support SQLCollectorStatus property\n\t\t\"polardb-cluster-maintain-time-check\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t# \"polardb-cluster-category-normal\",\n\t\t# \"polardb-cluster-level-two-backup-retention\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:quick-start-compliance-pack", Name: models.I18nString{"en": "Quick Start Compliance Pack", "zh": "快速体验合规包"}, Description: models.I18nString{"en": "A quick start compliance pack covering basic security best practices for ECS, OSS, RAM, and RDS.", "zh": "快速体验合规包,涵盖 ECS、OSS、RAM 和 RDS 的基本安全最佳实践。"}, RuleIDs: []string{"rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-activated-ak-quantity-check", "rule:aliyun:rds-public-connection-and-any-ip-access-check"}, FilePath: "aliyun/packs/quick-start-compliance-pack.rego", PackageName: "infraguard.packs.aliyun.quick_start_compliance_pack", Content: "package infraguard.packs.aliyun.quick_start_compliance_pack\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"quick-start-compliance-pack\",\n\t\"name\": {\n\t\t\"en\": \"Quick Start Compliance Pack\",\n\t\t\"zh\": \"快速体验合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"A quick start compliance pack covering basic security best practices for ECS, OSS, RAM, and RDS.\",\n\t\t\"zh\": \"快速体验合规包,涵盖 ECS、OSS、RAM 和 RDS 的基本安全最佳实践。\",\n\t},\n\t\"rules\": [\n\t\t# \"ecs-instance-no-public-ip\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-user-mfa-check-v2\",\n\t\t# \"ram-user-ak-create-date-expired-check-v2\",\n\t\t\"ram-user-activated-ak-quantity-check\",\n\t\t\"rds-public-connection-and-any-ip-access-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:redis-application-best-practice", Name: models.I18nString{"en": "Redis Application Best Practice", "zh": "Redis 应用最佳实践"}, Description: models.I18nString{"en": "Best practices for Redis instance configuration, covering high availability, security, backup, performance, and operational settings.", "zh": "Redis 实例配置最佳实践,涵盖高可用、安全、备份、性能和运维设置。"}, RuleIDs: []string{"rule:aliyun:redis-instance-multi-zone", "rule:aliyun:redis-public-and-any-ip-access-check", "rule:aliyun:redis-instance-expired-check", "rule:aliyun:redis-instance-enabled-byok-tde", "rule:aliyun:redis-instance-enabled-ssl", "rule:aliyun:redis-instance-release-protection", "rule:aliyun:redis-instance-backup-time-check", "rule:aliyun:redis-instance-backup-log-enabled"}, FilePath: "aliyun/packs/redis-application-best-practice.rego", PackageName: "infraguard.packs.aliyun.redis_application_best_practice", Content: "package infraguard.packs.aliyun.redis_application_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"redis-application-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Redis Application Best Practice\",\n\t\t\"zh\": \"Redis 应用最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for Redis instance configuration, covering high availability, security, backup, performance, and operational settings.\",\n\t\t\"zh\": \"Redis 实例配置最佳实践,涵盖高可用、安全、备份、性能和运维设置。\",\n\t},\n\t\"rules\": [\n\t\t\"redis-instance-multi-zone\",\n\t\t# \"redis-instance-double-node-type\",\n\t\t# \"redis-instance-disable-risk-commands\",\n\t\t\"redis-public-and-any-ip-access-check\",\n\t\t\"redis-instance-expired-check\",\n\t\t# \"redis-instance-audit-log-retention\",\n\t\t\"redis-instance-enabled-byok-tde\",\n\t\t\"redis-instance-enabled-ssl\",\n\t\t# \"redis-instance-upgrade-latest-version\",\n\t\t\"redis-instance-release-protection\",\n\t\t\"redis-instance-backup-time-check\",\n\t\t# \"redis-instance-enabled-audit-log\",  # Commented: ROS ALIYUN::REDIS::Instance does not support AuditLogConfig property\n\t\t# \"redis-min-qps-limit\",\n\t\t# \"redis-min-bandwidth-limit\",\n\t\t# \"redis-min-capacity-limit\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-backup-best-practice", Name: models.I18nString{"en": "Resource Backup Best Practice", "zh": "资源备份功能开启最佳实践"}, Description: models.I18nString{"en": "Best practices for enabling backup features on cloud resources to ensure data protection and disaster recovery.", "zh": "为云资源开启备份功能的最佳实践,确保数据保护和灾难恢复。"}, RuleIDs: []string{"rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:redis-instance-backup-log-enabled"}, FilePath: "aliyun/packs/resource-backup-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_backup_best_practice", Content: "package infraguard.packs.aliyun.resource_backup_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"resource-backup-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Backup Best Practice\",\n\t\t\"zh\": \"资源备份功能开启最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for enabling backup features on cloud resources to ensure data protection and disaster recovery.\",\n\t\t\"zh\": \"为云资源开启备份功能的最佳实践,确保数据保护和灾难恢复。\",\n\t},\n\t\"rules\": [\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t# \"eci-container-group-volumn-mounts\",\n\t\t# \"ecs-instance-backup-enable\",\n\t\t# \"elasticsearch-instance-snapshot-enabled\",  # Commented: ROS does not support AutoSnapshot property for ALIYUN::ElasticSearch::Instance\n\t\t# \"gpdb-has-backup-set\",\n\t\t# \"hologram-instance-remote-backup-enable\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t# \"ots-instance-remote-replication\",\n\t\t# \"polardb-cluster-log-backup-retention\",  # ROS does not support LogBackupRetentionPeriod property\n\t\t# \"polardb-cluster-level-two-backup-retention\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-expiration-notification-best-practice", Name: models.I18nString{"en": "Resource Expiration Notification Best Practice", "zh": "资源到期提醒最佳实践"}, Description: models.I18nString{"en": "Detects stability risks related to resource expiration, helping to discover hidden dangers in advance and improve stability and operational efficiency.", "zh": "从到期风险维度，对云上资源的稳定性做检测，有助于提前发现隐患，提升稳定性和运维效率。"}, RuleIDs: []string{"rule:aliyun:bastionhost-instance-expired-check", "rule:aliyun:ecs-instance-expired-check", "rule:aliyun:hbase-cluster-expired-check", "rule:aliyun:mongodb-cluster-expired-check", "rule:aliyun:polardb-cluster-expired-check", "rule:aliyun:rds-instance-expired-check", "rule:aliyun:redis-instance-expired-check"}, FilePath: "aliyun/packs/resource-expiration-notification-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_expiration_notification_best_practice", Content: "package infraguard.packs.aliyun.resource_expiration_notification_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"resource-expiration-notification-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Expiration Notification Best Practice\",\n\t\t\"zh\": \"资源到期提醒最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Detects stability risks related to resource expiration, helping to discover hidden dangers in advance and improve stability and operational efficiency.\",\n\t\t\"zh\": \"从到期风险维度，对云上资源的稳定性做检测，有助于提前发现隐患，提升稳定性和运维效率。\",\n\t},\n\t\"rules\": [\n\t\t# \"adb-cluster-expired-check\",\n\t\t\"bastionhost-instance-expired-check\",\n\t\t# \"polardb-x1-instance-expired-check\",\n\t\t# \"polardb-x2-instance-expired-check\",\n\t\t\"ecs-instance-expired-check\",\n\t\t# \"eip-address-expired-check\",\n\t\t\"hbase-cluster-expired-check\",\n\t\t\"mongodb-cluster-expired-check\",\n\t\t\"polardb-cluster-expired-check\",\n\t\t\"rds-instance-expired-check\",\n\t\t\"redis-instance-expired-check\",\n\t\t# \"slb-instance-expired-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-idle-detection-best-practice", Name: models.I18nString{"en": "Resource Idle Detection Best Practice", "zh": "资源空闲检测最佳实践"}, Description: models.I18nString{"en": "Detect common cloud resources that are idle after purchase, involving EIP, shared bandwidth, VPC, VPN and other cloud products. Idle resources lead to enterprise cost waste and should be identified and managed in time.", "zh": "检测常见的云资源在购买以后是否被闲置，涉及弹性公网 IP、共享带宽、VPC、VPN 等云产品。资源购买后未启用会导致企业成本的浪费，建议及时发现并治理。"}, RuleIDs: []string{"rule:aliyun:ecs-disk-idle-check"}, FilePath: "aliyun/packs/resource-idle-detection-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_idle_detection_best_practice", Content: "# Resource Idle Detection Best Practice Pack\n# Detect common cloud resources that are idle after purchase, involving EIP, shared bandwidth, VPC, VPN, etc.\n# Idle resources lead to cost waste and should be identified and managed in time.\npackage infraguard.packs.aliyun.resource_idle_detection_best_practice\n\nimport rego.v1\n\n# Pack metadata with i18n support\npack_meta := {\n\t\"id\": \"resource-idle-detection-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Idle Detection Best Practice\",\n\t\t\"zh\": \"资源空闲检测最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Detect common cloud resources that are idle after purchase, involving EIP, shared bandwidth, VPC, VPN and other cloud products. Idle resources lead to enterprise cost waste and should be identified and managed in time.\",\n\t\t\"zh\": \"检测常见的云资源在购买以后是否被闲置，涉及弹性公网 IP、共享带宽、VPC、VPN 等云产品。资源购买后未启用会导致企业成本的浪费，建议及时发现并治理。\",\n\t},\n\t\"rules\": [\"ecs-disk-idle-check\"], # \"cr-instance-idle-check\", # \"alb-instance-idle-check\", # \"cbwp-bandwidth-package-idle-check\",\n\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t# \"eip-idle-check\",\n\t# \"nas-filesystem-idle-check\",\n\t# \"internet-natgateway-idle-check\",\n\t# \"intranet-natgateway-idle-check\",\n\t# \"slb-instance-idle-check\",\n\t# \"vpn-gateway-idle-check\"\n\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-protection-best-practice", Name: models.I18nString{"en": "Resource Protection Best Practice", "zh": "资源开启保护最佳实践"}, Description: models.I18nString{"en": "Best practices for enabling protection features on cloud resources to prevent accidental deletion or modification.", "zh": "为云资源开启保护功能的最佳实践,防止意外删除或修改。"}, RuleIDs: []string{"rule:aliyun:alb-delete-protection-enabled", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:eip-delete-protection-enabled", "rule:aliyun:hbase-cluster-deletion-protection", "rule:aliyun:kms-key-delete-protection-enabled", "rule:aliyun:mongodb-instance-release-protection", "rule:aliyun:natgateway-delete-protection-enabled", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:rds-instacne-delete-protection-enabled", "rule:aliyun:redis-instance-release-protection", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-modify-protection-check"}, FilePath: "aliyun/packs/resource-protection-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_protection_best_practice", Content: "package infraguard.packs.aliyun.resource_protection_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"resource-protection-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Protection Best Practice\",\n\t\t\"zh\": \"资源开启保护最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for enabling protection features on cloud resources to prevent accidental deletion or modification.\",\n\t\t\"zh\": \"为云资源开启保护功能的最佳实践,防止意外删除或修改。\",\n\t},\n\t\"rules\": [\n\t\t# \"ack-cluster-deletion-protection-enabled\",\n\t\t\"alb-delete-protection-enabled\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t\"eip-delete-protection-enabled\",\n\t\t\"hbase-cluster-deletion-protection\",\n\t\t\"kms-key-delete-protection-enabled\",\n\t\t\"mongodb-instance-release-protection\",\n\t\t\"natgateway-delete-protection-enabled\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"rds-instacne-delete-protection-enabled\",\n\t\t\"redis-instance-release-protection\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-modify-protection-check\",\n\t\t# \"waf-domain-enabled-specified-protection-mode\",\n\t\t# \"waf-domain-enabled-specified-protection-module\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-public-access-detection-best-practice", Name: models.I18nString{"en": "Resource Public Access Detection Best Practice", "zh": "资源开启公网检测最佳实践"}, Description: models.I18nString{"en": "Best practices for detecting and managing public access to cloud resources to ensure security.", "zh": "检测和管理云资源公网访问的最佳实践,确保安全性。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-public-endpoint-check", "rule:aliyun:cr-repository-type-private", "rule:aliyun:ecs-running-instance-no-public-ip", "rule:aliyun:sg-public-access-check", "rule:aliyun:emr-cluster-master-public-access-check", "rule:aliyun:elasticsearch-public-and-any-ip-access-check", "rule:aliyun:mse-cluster-config-auth-enabled", "rule:aliyun:mongodb-public-and-any-ip-access-check", "rule:aliyun:polardb-public-and-any-ip-access-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:redis-public-and-any-ip-access-check"}, FilePath: "aliyun/packs/resource-public-access-detection-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_public_access_detection_best_practice", Content: "package infraguard.packs.aliyun.resource_public_access_detection_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"resource-public-access-detection-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Public Access Detection Best Practice\",\n\t\t\"zh\": \"资源开启公网检测最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for detecting and managing public access to cloud resources to ensure security.\",\n\t\t\"zh\": \"检测和管理云资源公网访问的最佳实践,确保安全性。\",\n\t},\n\t\"rules\": [\n\t\t\"ack-cluster-public-endpoint-check\",\n\t\t# \"adb-public-access-check\",  # Commented: ROS ADB::DBCluster does not support PublicEndpoint property\n\t\t# \"kafka-instance-public-access-check\",\n\t\t# \"apigateway-ipv4-public-access-check\",\n\t\t# \"apigateway-ipv6-public-access-check\",\n\t\t# \"cr-instance-public-access-check\",  # Commented: ROS CR::Instance does not support PublicNetworkAccess property\n\t\t\"cr-repository-type-private\",\n\t\t\"ecs-running-instance-no-public-ip\",\n\t\t\"sg-public-access-check\",\n\t\t\"emr-cluster-master-public-access-check\",\n\t\t\"elasticsearch-public-and-any-ip-access-check\",\n\t\t# \"hbase-public-access-check\",\n\t\t# \"lindorm-instance-public-access-check\",\n\t\t\"mse-cluster-config-auth-enabled\",\n\t\t\"mongodb-public-and-any-ip-access-check\",\n\t\t# \"nas-access-group-public-access-check\",\n\t\t# \"ots-instance-network-not-normal\",\n\t\t# \"oceanbase-public-and-any-ip-access-check\",\n\t\t\"polardb-public-and-any-ip-access-check\",\n\t\t\"rds-public-access-check\",\n\t\t\"redis-public-and-any-ip-access-check\",\n\t\t# \"tsdb-instance-public-access-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:resource-stability-best-practice", Name: models.I18nString{"en": "Resource Stability Best Practice", "zh": "资源稳定性最佳实践"}, Description: models.I18nString{"en": "Detect resource stability from six dimensions: high availability architecture, capacity protection, change management, monitoring management, backup management, and fault isolation, which helps to identify risks in advance and improve stability and O&M efficiency.", "zh": "从高可用基础架构、容量保护、变更管理、监控管理、备份管理、故障隔离六大维度对云上资源的稳定性做检测，有助于提前发现隐患，提升稳定性和运维效率。"}, RuleIDs: []string{"rule:aliyun:ack-cluster-upgrade-latest-version", "rule:aliyun:alb-all-listener-health-check-enabled", "rule:aliyun:alb-all-listenter-has-server", "rule:aliyun:alb-delete-protection-enabled", "rule:aliyun:bastionhost-instance-expired-check", "rule:aliyun:ecs-snapshot-policy-timepoints-check", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-expired-check", "rule:aliyun:ecs-instance-deletion-protection-enabled", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:eip-delete-protection-enabled", "rule:aliyun:elasticsearch-public-and-any-ip-access-check", "rule:aliyun:elasticsearch-instance-multi-zone", "rule:aliyun:mongodb-cluster-expired-check", "rule:aliyun:mongodb-public-access-check", "rule:aliyun:mongodb-instance-release-protection", "rule:aliyun:mongodb-instance-multi-zone", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:polardb-cluster-expired-check", "rule:aliyun:polardb-cluster-maintain-time-check", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:polardb-cluster-multi-zone", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-multi-az-support", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-instance-expired-check", "rule:aliyun:rds-instance-maintain-time-check", "rule:aliyun:rds-instacne-delete-protection-enabled", "rule:aliyun:redis-instance-expired-check", "rule:aliyun:redis-instance-multi-zone", "rule:aliyun:redis-instance-backup-time-check", "rule:aliyun:redis-instance-release-protection", "rule:aliyun:redis-instance-backup-log-enabled", "rule:aliyun:slb-all-listener-health-check-enabled", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-all-listener-servers-multi-zone", "rule:aliyun:slb-instance-multi-zone"}, FilePath: "aliyun/packs/resource-stability-best-practice.rego", PackageName: "infraguard.packs.aliyun.resource_stability_best_practice", Content: "# Resource Stability Best Practice Pack\n# Detect resource stability from six dimensions: high availability, capacity protection,\n# change management, monitoring, backup, and fault isolation.\npackage infraguard.packs.aliyun.resource_stability_best_practice\n\nimport rego.v1\n\n# Pack metadata with i18n support\npack_meta := {\n\t\"id\": \"resource-stability-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Resource Stability Best Practice\",\n\t\t\"zh\": \"资源稳定性最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Detect resource stability from six dimensions: high availability architecture, capacity protection, change management, monitoring management, backup management, and fault isolation, which helps to identify risks in advance and improve stability and O&M efficiency.\",\n\t\t\"zh\": \"从高可用基础架构、容量保护、变更管理、监控管理、备份管理、故障隔离六大维度对云上资源的稳定性做检测，有助于提前发现隐患，提升稳定性和运维效率。\",\n\t},\n\t\"rules\": [\n\t\t# \"region-vswitch-no-crossed-cidr\",\n\t\t\"ack-cluster-upgrade-latest-version\",\n\t\t# \"ack-cluster-deletion-protection-enabled\",\n\t\t# \"ack-cluster-spec-check\",\n\t\t# \"adb-cluster-expired-check\",\n\t\t# \"adb-cluster-maintain-time-check\",  # Commented: ROS ADB::DBCluster does not support MaintainTime property\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t\"alb-all-listener-health-check-enabled\",\n\t\t\"alb-all-listenter-has-server\",\n\t\t\"alb-delete-protection-enabled\",\n\t\t# \"kafka-instance-public-access-check\",\n\t\t\"bastionhost-instance-expired-check\",\n\t\t# \"cbwp-bandwidth-package-expired-check\",\n\t\t# \"cdn-domain-enabled-cache\",\n\t\t# \"cdn-domain-oss-source-check\",\n\t\t# \"cen-bandwidth-package-expired-check\",\n\t\t# \"cen-all-vbr-health-check-enabled\",\n\t\t# \"cen-cross-region-bandwidth-check\",\n\t\t# \"polardb-x1-instance-expired-check\",\n\t\t# \"polardb-x2-instance-expired-check\",\n\t\t# \"ddoscoo-instance-expired-check\",\n\t\t# \"eci-container-group-volumn-mounts\",\n\t\t\"ecs-snapshot-policy-timepoints-check\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-expired-check\",\n\t\t\"ecs-instance-deletion-protection-enabled\",\n\t\t# \"ecs-instance-status-no-stopped\",  # Commented: ROS ECS::Instance does not support Status property\n\t\t# \"ecs-instance-type-family-not-deprecated\",\n\t\t# \"ecs-instance-os-name-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t# \"eip-address-expired-check\",\n\t\t\"eip-delete-protection-enabled\",\n\t\t\"elasticsearch-public-and-any-ip-access-check\",\n\t\t# \"elasticsearch-instance-version-not-deprecated\",\n\t\t# \"elasticsearch-instance-enabled-kibana-public-check\",\n\t\t\"elasticsearch-instance-multi-zone\",\n\t\t# \"elasticsearch-instance-node-not-use-specified-spec\",\n\t\t# \"elasticsearch-instance-snapshot-enabled\",  # Commented: ROS does not support AutoSnapshot property for ALIYUN::ElasticSearch::Instance\n\t\t\"mongodb-cluster-expired-check\",\n\t\t\"mongodb-public-access-check\",\n\t\t# \"mongodb-instance-multi-node\",\n\t\t\"mongodb-instance-release-protection\",\n\t\t\"mongodb-instance-multi-zone\",\n\t\t# \"mongodb-instance-backup-log-enabled\",  # Commented: ROS does not support ALIYUN::MongoDB::DBInstance resource type\n\t\t# \"mongodb-instance-class-not-shared\",\n\t\t# \"natgateway-eip-used-check\",\n\t\t# \"natgateway-snat-eip-bandwidth-check\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t# \"ons-instance-type-check\",\n\t\t\"polardb-cluster-expired-check\",\n\t\t# \"polardb-public-access-check\",\n\t\t\"polardb-cluster-maintain-time-check\",\n\t\t# \"polardb-dbversion-status-check\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"polardb-cluster-multi-zone\",\n\t\t# \"polardb-cluster-category-normal\",\n\t\t# \"polardb-cluster-level-two-backup-retention\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-multi-az-support\",\n\t\t\"rds-public-access-check\",\n\t\t# \"rds-instance-enabled-security-ip-list\",\n\t\t\"rds-instance-expired-check\",\n\t\t# \"rds-instance-class-type-check\",\n\t\t# \"rds-instance-sql-collector-retention\",  # Commented: ROS RDS::DBInstance does not support SQLCollectorRetention property\n\t\t\"rds-instance-maintain-time-check\",\n\t\t\"rds-instacne-delete-protection-enabled\",\n\t\t# \"rds-instance-category-check\",\n\t\t\"redis-instance-expired-check\",\n\t\t# \"redis-public-access-check\",\n\t\t# \"redis-instance-disable-risk-commands\",\n\t\t# \"redis-architecturetype-cluster-check\",\n\t\t\"redis-instance-multi-zone\",\n\t\t\"redis-instance-backup-time-check\",\n\t\t# \"redis-instance-upgrade-latest-version\",\n\t\t\"redis-instance-release-protection\",\n\t\t# \"redis-instance-edition-type-check\",\n\t\t\"redis-instance-backup-log-enabled\",\n\t\t\"slb-all-listener-health-check-enabled\",\n\t\t# \"slb-instance-expired-check\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-all-listener-servers-multi-zone\",\n\t\t\"slb-instance-multi-zone\",\n\t\t# \"slb-instance-spec-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:rmit-financial-standard-compliance-pack", Name: models.I18nString{"en": "RMiT Financial Standard Compliance Pack", "zh": "RMiT 金融标准检查合规包"}, Description: models.I18nString{"en": "Compliance pack for RMiT financial standards", "zh": "RMiT 金融标准检查合规包"}, RuleIDs: []string{"rule:aliyun:actiontrail-trail-intact-enabled", "rule:aliyun:ram-password-policy-check", "rule:aliyun:root-ak-check", "rule:aliyun:actiontrail-enabled", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instances-in-vpc", "rule:aliyun:sg-public-access-check", "rule:aliyun:kms-key-rotation-enabled", "rule:aliyun:oss-bucket-anonymous-prohibited", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-encryption-byok-check", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-default-encryption-kms", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-last-login-expired-check", "rule:aliyun:ram-user-group-membership-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-multi-az-support", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:vpc-flow-logs-enabled", "rule:aliyun:waf-instance-logging-enabled"}, FilePath: "aliyun/packs/rmit-financial-standard-compliance-pack.rego", PackageName: "infraguard.packs.aliyun.rmit_financial_standard_compliance_pack", Content: "package infraguard.packs.aliyun.rmit_financial_standard_compliance_pack\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"rmit-financial-standard-compliance-pack\",\n\t\"name\": {\n\t\t\"en\": \"RMiT Financial Standard Compliance Pack\",\n\t\t\"zh\": \"RMiT 金融标准检查合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for RMiT financial standards\",\n\t\t\"zh\": \"RMiT 金融标准检查合规包\",\n\t},\n\t\"rules\": [\n\t\t\"actiontrail-trail-intact-enabled\",\n\t\t\"ram-password-policy-check\",\n\t\t\"root-ak-check\",\n\t\t\"actiontrail-enabled\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t# \"ecs-instance-no-public-ip\",\n\t\t\"ecs-instances-in-vpc\",\n\t\t\"sg-public-access-check\",\n\t\t# \"elasticsearch-instance-in-vpc\",  # Commented: ROS ALIYUN::ElasticSearch::Instance requires VSwitchId (all instances are in VPC)\n\t\t\"kms-key-rotation-enabled\",\n\t\t\"oss-bucket-anonymous-prohibited\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-encryption-byok-check\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-default-encryption-kms\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t\"ram-group-has-member-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-last-login-expired-check\",\n\t\t\"ram-user-group-membership-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"rds-public-access-check\",\n\t\t\"rds-multi-az-support\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-listener-https-enabled\",\n\t\t# \"slb-server-certificate-expired\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"vpn-ipsec-connection-status-check\",\n\t\t\"waf-instance-logging-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:ros-best-practice", Name: models.I18nString{"en": "ROS Best Practice Pack", "zh": "ROS 最佳实践合规包"}, Description: models.I18nString{"en": "A compliance pack covering ROS template best practices, including metadata configuration and sensitive parameter protection.", "zh": "涵盖 ROS 模板最佳实践的合规包，包括元数据配置和敏感参数保护等。"}, RuleIDs: []string{"rule:aliyun:metadata-ros-composer-check", "rule:aliyun:parameter-sensitive-noecho-check"}, FilePath: "aliyun/packs/ros-best-practice.rego", PackageName: "infraguard.packs.aliyun.ros_best_practice", Content: "package infraguard.packs.aliyun.ros_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"ros-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"ROS Best Practice Pack\",\n\t\t\"zh\": \"ROS 最佳实践合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"A compliance pack covering ROS template best practices, including metadata configuration and sensitive parameter protection.\",\n\t\t\"zh\": \"涵盖 ROS 模板最佳实践的合规包，包括元数据配置和敏感参数保护等。\",\n\t},\n\t\"rules\": [\n\t\t\"metadata-ros-composer-check\",\n\t\t\"parameter-sensitive-noecho-check\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:security-group-best-practice", Name: models.I18nString{"en": "Security Group Best Practice", "zh": "安全组最佳实践"}, Description: models.I18nString{"en": "Continuously check security group rules for compliance to reduce security risks.", "zh": "持续检查安全组规则的合规性，降低安全风险。"}, RuleIDs: []string{"rule:aliyun:ecs-instance-attached-security-group", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-not-open-all-port", "rule:aliyun:ecs-security-group-not-open-all-protocol", "rule:aliyun:ecs-security-group-not-internet-cidr-access", "rule:aliyun:ecs-security-group-egress-not-all-access", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol"}, FilePath: "aliyun/packs/security-group-best-practice.rego", PackageName: "infraguard.packs.aliyun.security_group_best_practice", Content: "# Security Group Best Practice Pack\n# A collection of rules for checking security group compliance to reduce security risks.\npackage infraguard.packs.aliyun.security_group_best_practice\n\nimport rego.v1\n\n# Pack metadata with i18n support\npack_meta := {\n\t\"id\": \"security-group-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Best Practice\",\n\t\t\"zh\": \"安全组最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Continuously check security group rules for compliance to reduce security risks.\",\n\t\t\"zh\": \"持续检查安全组规则的合规性，降低安全风险。\",\n\t},\n\t\"rules\": [\n\t\t\"ecs-instance-attached-security-group\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-not-open-all-port\",\n\t\t\"ecs-security-group-not-open-all-protocol\",\n\t\t\"ecs-security-group-not-internet-cidr-access\",\n\t\t\"ecs-security-group-egress-not-all-access\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:security-group-best-practice-v2", Name: models.I18nString{"en": "Security Group Best Practice", "zh": "安全组最佳实践"}, Description: models.I18nString{"en": "Best practices for ECS security group configuration to ensure network security and access control. Includes checks for risky ports, access restrictions, and security group settings.", "zh": "ECS 安全组配置最佳实践，确保网络安全和访问控制。包括危险端口检查、访问限制和安全组设置检查。"}, RuleIDs: []string{"rule:aliyun:ecs-instance-attached-security-group", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:sg-public-access-check", "rule:aliyun:ecs-security-group-not-open-all-port", "rule:aliyun:ecs-security-group-not-open-all-protocol", "rule:aliyun:ecs-security-group-not-internet-cidr-access", "rule:aliyun:ecs-security-group-egress-not-all-access", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol"}, FilePath: "aliyun/packs/security-group-best-practice-v2.rego", PackageName: "infraguard.packs.aliyun.security_group_best_practice_v2", Content: "package infraguard.packs.aliyun.security_group_best_practice_v2\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"security-group-best-practice-v2\",\n\t\"name\": {\n\t\t\"en\": \"Security Group Best Practice\",\n\t\t\"zh\": \"安全组最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for ECS security group configuration to ensure network security and access control. Includes checks for risky ports, access restrictions, and security group settings.\",\n\t\t\"zh\": \"ECS 安全组配置最佳实践，确保网络安全和访问控制。包括危险端口检查、访问限制和安全组设置检查。\",\n\t},\n\t\"rules\": [\n\t\t\"ecs-instance-attached-security-group\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t\"sg-public-access-check\",\n\t\t\"ecs-security-group-not-open-all-port\",\n\t\t\"ecs-security-group-not-open-all-protocol\",\n\t\t\"ecs-security-group-not-internet-cidr-access\",\n\t\t\"ecs-security-group-egress-not-all-access\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:slb-application-best-practice", Name: models.I18nString{"en": "SLB Application Best Practice", "zh": "负载均衡应用最佳实践"}, Description: models.I18nString{"en": "Best practices for SLB and ALB configuration, covering high availability, security, health checks, and operational settings.", "zh": "SLB 和 ALB 配置最佳实践,涵盖高可用、安全、健康检查和运维设置。"}, RuleIDs: []string{"rule:aliyun:alb-all-listener-health-check-enabled", "rule:aliyun:alb-address-type-check", "rule:aliyun:slb-acl-public-access-check", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:slb-all-listener-servers-multi-zone", "rule:aliyun:slb-all-listenter-tls-policy-check", "rule:aliyun:slb-all-listener-health-check-enabled", "rule:aliyun:slb-instance-loadbalancerspec-check", "rule:aliyun:slb-instance-multi-zone", "rule:aliyun:slb-delete-protection-enabled", "rule:aliyun:slb-modify-protection-check"}, FilePath: "aliyun/packs/slb-application-best-practice.rego", PackageName: "infraguard.packs.aliyun.slb_application_best_practice", Content: "package infraguard.packs.aliyun.slb_application_best_practice\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"slb-application-best-practice\",\n\t\"name\": {\n\t\t\"en\": \"SLB Application Best Practice\",\n\t\t\"zh\": \"负载均衡应用最佳实践\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Best practices for SLB and ALB configuration, covering high availability, security, health checks, and operational settings.\",\n\t\t\"zh\": \"SLB 和 ALB 配置最佳实践,涵盖高可用、安全、健康检查和运维设置。\",\n\t},\n\t\"rules\": [\n\t\t# \"alb-instance-idle-check\",\n\t\t\"alb-all-listener-health-check-enabled\",\n\t\t# \"alb-acl-has-specified-ip\",\n\t\t# \"alb-all-listener-enabled-acl\",  # Commented: ROS ALB::Listener does not support AclConfig property\n\t\t\"alb-address-type-check\",\n\t\t\"slb-acl-public-access-check\",\n\t\t\"slb-listener-https-enabled\",\n\t\t\"slb-all-listener-servers-multi-zone\",\n\t\t# \"slb-instance-idle-check\",\n\t\t\"slb-all-listenter-tls-policy-check\",\n\t\t\"slb-all-listener-health-check-enabled\",\n\t\t# \"slb-acl-has-specified-ip\",\n\t\t# \"slb-instance-autorenewal-check\",\n\t\t# \"slb-instance-expired-check\",\n\t\t\"slb-instance-loadbalancerspec-check\",\n\t\t\"slb-instance-multi-zone\",\n\t\t\"slb-delete-protection-enabled\",\n\t\t\"slb-modify-protection-check\",\n\t\t# \"slb-instance-listener-count-check\",\n\t\t# \"slb-listener-health-check-interval-check\",\n\t\t# \"slb-listener-health-check-timeout-check\",\n\t\t# \"slb-listener-health-check-threshold-check\",\n\t\t# \"slb-listener-connection-drain-enabled\",\n\t\t# \"slb-listener-http2-enabled\",\n\t\t# \"slb-listener-gzip-enabled\",\n\t],\n}\n"})
	addPack(&models.Pack{ID: "pack:aliyun:soc2-audit-compliance", Name: models.I18nString{"en": "SOC 2 Audit Standard Compliance", "zh": "SOC2 审计标准实践合规包"}, Description: models.I18nString{"en": "Compliance pack for SOC 2 (Service Organization Control 2) audit standards. This pack helps organizations verify their cloud resources meet SOC 2 trust principles for security, availability, and confidentiality.", "zh": "SOC 2(服务组织控制 2)审计标准合规包。本合规包帮助组织验证其云资源是否符合 SOC 2 安全性、可用性和保密性信任原则。"}, RuleIDs: []string{"rule:aliyun:api-gateway-group-enabled-ssl", "rule:aliyun:firewall-asset-open-protect", "rule:aliyun:ecs-disk-encrypted", "rule:aliyun:ecs-disk-auto-snapshot-policy", "rule:aliyun:ecs-instance-enabled-security-protection", "rule:aliyun:ecs-running-instance-no-public-ip", "rule:aliyun:ecs-instance-ram-role-attached", "rule:aliyun:ecs-security-group-white-list-port-check", "rule:aliyun:ecs-security-group-risky-ports-check-with-protocol", "rule:aliyun:eip-attached", "rule:aliyun:ess-scaling-configuration-enabled-internet-check", "rule:aliyun:elasticsearch-instance-enabled-data-node-encryption", "rule:aliyun:fc-service-vpc-binding", "rule:aliyun:fc-service-internet-access-disable", "rule:aliyun:kms-key-delete-protection-enabled", "rule:aliyun:kms-secret-rotation-enabled", "rule:aliyun:nas-filesystem-encrypt-type-check", "rule:aliyun:oss-zrs-enabled", "rule:aliyun:oss-bucket-server-side-encryption-enabled", "rule:aliyun:oss-bucket-public-read-prohibited", "rule:aliyun:oss-bucket-public-write-prohibited", "rule:aliyun:oss-bucket-versioning-enabled", "rule:aliyun:oss-bucket-logging-enabled", "rule:aliyun:oss-bucket-only-https-enabled", "rule:aliyun:polardb-cluster-delete-protection-enabled", "rule:aliyun:polardb-cluster-enabled-tde", "rule:aliyun:polardb-cluster-enabled-ssl", "rule:aliyun:ram-group-has-member-check", "rule:aliyun:ram-policy-no-statements-with-admin-access-check", "rule:aliyun:ram-user-mfa-check", "rule:aliyun:ram-user-ak-create-date-expired-check", "rule:aliyun:ram-user-login-check", "rule:aliyun:ram-user-no-policy-check", "rule:aliyun:ram-user-group-membership-check", "rule:aliyun:rds-instance-enabled-log-backup", "rule:aliyun:rds-public-access-check", "rule:aliyun:rds-instacne-delete-protection-enabled", "rule:aliyun:redis-instance-enabled-ssl", "rule:aliyun:slb-listener-https-enabled", "rule:aliyun:slb-all-listenter-tls-policy-check", "rule:aliyun:slb-instance-log-enabled", "rule:aliyun:vpc-flow-logs-enabled"}, FilePath: "aliyun/packs/soc2-audit-compliance.rego", PackageName: "infraguard.packs.aliyun.soc2_audit_compliance", Content: "package infraguard.packs.aliyun.soc2_audit_compliance\n\nimport rego.v1\n\npack_meta := {\n\t\"id\": \"soc2-audit-compliance\",\n\t\"name\": {\n\t\t\"en\": \"SOC 2 Audit Standard Compliance\",\n\t\t\"zh\": \"SOC2 审计标准实践合规包\",\n\t},\n\t\"description\": {\n\t\t\"en\": \"Compliance pack for SOC 2 (Service Organization Control 2) audit standards. This pack helps organizations verify their cloud resources meet SOC 2 trust principles for security, availability, and confidentiality.\",\n\t\t\"zh\": \"SOC 2(服务组织控制 2)审计标准合规包。本合规包帮助组织验证其云资源是否符合 SOC 2 安全性、可用性和保密性信任原则。\",\n\t},\n\t\"rules\": [\n\t\t# \"ack-running-cluster-node-monitorenabled\",\n\t\t# \"ack-cluster-node-monitorenabled\",\n\t\t# \"ack-cluster-ram-authenticator-enabled\",\n\t\t# \"adb-public-access-check\",  # Commented: ROS ADB::DBCluster does not support PublicEndpoint property\n\t\t# \"adb-cluster-log-backup-enabled\",\n\t\t# \"adb-cluster-audit-log-enabled\",  # Commented: ROS ADB::DBCluster does not support AuditLog property\n\t\t# \"alb-http-drop-invalid-header-enabled\",\n\t\t# \"api-gateway-api-auth-required\",\n\t\t# \"api-gateway-group-log-enabled\",\n\t\t# \"api-gateway-group-domain-access-waf-or-waf3\",  # Commented: ROS ApiGateway::Group does not support PassthroughWaf property\n\t\t\"api-gateway-group-enabled-ssl\",\n\t\t# \"cdn-domain-tls13-enabled\",\n\t\t# \"cr-instance-public-access-check\",  # Commented: ROS CR::Instance does not support PublicNetworkAccess property\n\t\t\"firewall-asset-open-protect\",\n\t\t# \"dts-instance-sync-job-ssl-enabled\",\n\t\t\"ecs-disk-encrypted\",\n\t\t\"ecs-disk-auto-snapshot-policy\",\n\t\t\"ecs-instance-enabled-security-protection\",\n\t\t# \"ecs-instance-monitor-enabled\",  # Commented: ROS ECS::Instance does not support CloudMonitorFlags property\n\t\t\"ecs-running-instance-no-public-ip\",\n\t\t# \"ecs-running-instances-in-vpc\",\n\t\t# \"ecs-instance-updated-security-vul\",  # Commented: ROS ECS::Instance does not support Vulnerabilities property\n\t\t# \"ecs-instance-no-public-ip\",\n\t\t\"ecs-instance-ram-role-attached\",\n\t\t\"ecs-security-group-white-list-port-check\",\n\t\t\"ecs-security-group-risky-ports-check-with-protocol\",\n\t\t\"eip-attached\",\n\t\t\"ess-scaling-configuration-enabled-internet-check\",\n\t\t# \"elasticsearch-instance-enabled-public-check\",\n\t\t\"elasticsearch-instance-enabled-data-node-encryption\",\n\t\t# \"elasticsearch-instance-used-https-protocol\",  # Commented: ROS ALIYUN::ElasticSearch::Instance does not support Protocol property\n\t\t# \"fc-function-settings-check\",\n\t\t\"fc-service-vpc-binding\",\n\t\t\"fc-service-internet-access-disable\",\n\t\t\"kms-key-delete-protection-enabled\",\n\t\t# \"kms-key-state-not-pending-deletion\",  # Commented: ROS KMS::Key does not support KeyState property (runtime state only)\n\t\t# \"kms-secret-last-rotation-date-check\",\n\t\t\"kms-secret-rotation-enabled\",\n\t\t# \"nas-filesystem-enable-backup-plan\",\n\t\t\"nas-filesystem-encrypt-type-check\",\n\t\t# \"nat-risk-ports-check\",\n\t\t\"oss-zrs-enabled\",\n\t\t\"oss-bucket-server-side-encryption-enabled\",\n\t\t\"oss-bucket-public-read-prohibited\",\n\t\t\"oss-bucket-public-write-prohibited\",\n\t\t\"oss-bucket-versioning-enabled\",\n\t\t\"oss-bucket-logging-enabled\",\n\t\t\"oss-bucket-only-https-enabled\",\n\t\t# \"polardb-public-access-check\",\n\t\t# \"polardb-cluster-address-no-public\",\n\t\t# \"polardb-cluster-level-one-backup-retention\",\n\t\t\"polardb-cluster-delete-protection-enabled\",\n\t\t\"polardb-cluster-enabled-tde\",\n\t\t\"polardb-cluster-enabled-ssl\",\n\t\t# \"polardb-cluster-enabled-auditing\",  # ROS does not support SQLCollectorStatus property\n\t\t\"ram-group-has-member-check\",\n\t\t# \"ram-group-in-use-check\",\n\t\t\"ram-policy-no-statements-with-admin-access-check\",\n\t\t# \"ram-policy-in-use-check\",\n\t\t\"ram-user-mfa-check\",\n\t\t\"ram-user-ak-create-date-expired-check\",\n\t\t\"ram-user-login-check\",\n\t\t\"ram-user-no-policy-check\",\n\t\t\"ram-user-group-membership-check\",\n\t\t# \"ram-user-active-ak-check\",\n\t\t\"rds-instance-enabled-log-backup\",\n\t\t\"rds-public-access-check\",\n\t\t\"rds-instacne-delete-protection-enabled\",\n\t\t# \"rds-instance-enabled-tde\",\n\t\t\"redis-instance-enabled-ssl\",\n\t\t\"slb-listener-https-enabled\",\n\t\t\"slb-all-listenter-tls-policy-check\",\n\t\t# \"slb-no-public-ip\",\n\t\t\"slb-instance-log-enabled\",\n\t\t# \"slb-aliyun-certificate-required\",\n\t\t# \"ssl-certificate-expired-check\",\n\t\t\"vpc-flow-logs-enabled\",\n\t\t# \"waf3-instance-enabled-specified-defense-rules\",\n\t],\n}\n"})
}

func addRule(r *models.Rule) {
	EmbeddedIndex.Rules[r.ID] = r
	EmbeddedIndex.RuleList = append(EmbeddedIndex.RuleList, r)
}

func addPack(p *models.Pack) {
	EmbeddedIndex.Packs[p.ID] = p
	EmbeddedIndex.PackList = append(EmbeddedIndex.PackList, p)
}
